[{"title":"MySQL","url":"/hexo-blog/2023/03/03/MySQL/","content":"\n# MySQL\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2023.03.03 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n>  [MySQL | DB-TUTORIAL (gitee.io)](https://turnon.gitee.io/db-tutorial/pages/0a031b/)\n\n## SQL其他\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031334282.png)\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335112.png)\n\n![image-20230303131813682](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335113.png)\n\n![sql-join](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335114.png)\n\n## MySQL基础\n\n### 2 存储引擎\n\n**不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 Mysql 服务层统一处理的。**\n\n```sql\nmysql> SHOW ENGINES;\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |\n| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |\n| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |\n| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |\n| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |\n| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |\n| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |\n| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |\n| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n9 rows in set (0.00 sec)\n```\n\n- **InnoDB** - Mysql 的默认事务型存储引擎，并且提供了行级锁和外键的约束。性能不错且支持自动崩溃恢复。\n- **MyISAM** - **Mysql 5.5 版本前的默认存储引擎**。特性丰富但不支持事务，也不支持行级锁和外键，也没有崩溃恢复功能。\n- **CSV** - 可以将 CSV 文件作为 Mysql 的表来处理，但这种表不支持索引。\n- **Memory** - 适合快速访问数据，且数据不会被修改，重启丢失也没有关系。\n- **NDB** - 用于 Mysql 集群场景。\n\n#### 2.1 MyISAM\n\nMyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。\n\nMyISAM 引擎使用 B+Tree 作为索引结构，**叶节点的 data 域存放的是数据记录的地址**。\n\nMyISAM 提供了大量的特性，包括：全文索引、压缩表、空间函数等。但是，MyISAM 不支持事务和行级锁。并且 MyISAM 不支持崩溃后的安全恢复。\n\n#### 2.2 InnoDB\n\nInnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。\n\nMyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而**在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构**，这棵树的叶节点 data 域保存了完整的数据记录。这个**索引的 key 是数据表的主键**，因此**InnoDB 表数据文件本身就是主索引**。\n\n**InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）防止幻读。**\n\nInnoDB 是基于聚簇索引建立的，与其他存储引擎有很大不同。在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n\n### 3 数据类型\n\n#### 3.1 整型\n\n`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT` 分别使用 `8`, `16`, `24`, `32`, `64` 位存储空间，一般情况下越小的列越好。\n\n**`UNSIGNED` 表示不允许负值，大致可以使正数的上限提高一倍**。\n\n`INT(11)` 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。\n\n####  3.2 浮点型\n\n`FLOAT` 和 `DOUBLE` 为浮点类型。\n\n`DECIMAL` 类型主要用于精确计算，代价较高，应该尽量只在对小数进行精确计算时才使用 `DECIMAL` ——例如存储财务数据。数据量比较大的时候，可以使用 `BIGINT` 代替 `DECIMAL`。\n\n`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL(18, 9)` 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。\n\n#### 3.3 字符串\n\n主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的。\n\n**`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长**。当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。\n\n`VARCHAR` 会保留字符串末尾的空格，而 `CHAR` 会删除。\n\n#### 3.4 时间和日期\n\nMySQL 提供了两种相似的日期时间类型：`DATATIME` 和 `TIMESTAMP`。\n\n默认情况下，MySQL 以一种可排序的、无歧义的格式显示 `DATATIME` 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。\n\n`TIMESTAMP`和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。\n\n应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。\n\n| 类型        | 范围                    | 时区相关性 | 大小   |\n| ----------- | ----------------------- | ---------- | ------ |\n| `DATETIME`  | 1001年-9999年，精度为秒 | 无关       | 8 byte |\n| `TIMESTAMP` | 1970年-2038年，精度为秒 | 有关       | 4 byte |\n\n#### 3.5 BLOB和TEXT\n\n`BLOB` 和 `TEXT` 都是为了存储大的数据而设计，前者存储二进制数据，后者存储字符串数据。\n\n不能对 `BLOB` 和 `TEXT` 类型的全部内容进行排序、索引。\n\n#### 3.6 枚举类型\n\n大多数情况下没有使用枚举类型的必要。\n\n#### 3.7 类型的选择\n\n- 整数类型通常是标识列最好的选择，因为它们很快并且可以使用 `AUTO_INCREMENT`。\n- `ENUM` 和 `SET` 类型通常是一个糟糕的选择，应尽量避免。\n- 应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 `MD5`、`SHA`、`UUID` 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 `INSERT` 以及一些 `SELECT` 语句变得很慢。\n  - 如果存储 UUID ，应该移除 `-` 符号；更好的做法是，用 `UNHEX()` 函数转换 UUID 值为 16 字节的数字，并存储在一个 `BINARY(16)` 的列中，检索时，可以通过 `HEX()` 函数来格式化为 16 进制格式。\n\n### 4 复制\n\n#### 4.1 主从复制\n\nMysql 支持两种复制：基于行的复制和基于语句的复制。\n\n这两种方式都是在主库上记录二进制日志，然后在从库重放日志的方式来实现异步的数据复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。\n\n主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。\n\n- **binlog 线程** ：负责将主服务器上的数据更改写入二进制文件（binlog）中。\n- **I/O 线程** ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。\n- **SQL 线程** ：负责读取中继日志并重放其中的 SQL 语句。\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335115.png)\n\n#### 4.2 读写分离\n\n主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。\n\n读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。\n\nMySQL 读写分离能提高性能的原因在于：\n\n- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；\n- 从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；\n- 增加冗余，提高可用性。\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335116.png)\n\n## MySQL工作流\n\n### 1 基础架构\n\n> 大体来说，MySQL 可以分为 **Server 层**和**存储引擎层**两部分。\n\n> **Server 层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\n>\n> **存储引擎层负责数据的存储和提取**。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。\n\n![](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335117.jpg)\n\n### 2 查询过程\n\nMySQL 整个查询执行过程，总的来说分为 6 个步骤：\n\n1. 客户端和 MySQL 服务器建立连接；客户端向 MySQL 服务器发送一条查询请求。\n2. MySQL 服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。\n3. MySQL 服务器进行 SQL 分析：语法分析、词法分析。\n4. MySQL 服务器用优化器生成对应的执行计划。\n5. MySQL 服务器根据执行计划，调用存储引擎的 API 来执行查询。\n6. MySQL 服务器将结果返回给客户端，同时缓存查询结果\n\n#### 2.1（一）连接\n\nMySQL 客户端/服务端通信是**半双工模式**：即任一时刻，要么是服务端向客户端发送数据，要么是客户端向服务器发送数据。\n\nMySQL 客户端连接命令：`mysql -h<主机> -P<端口> -u<用户名> -p<密码>`。如果没有显式指定密码，会要求输入密码才能访问。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 `show processlist` 命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。**客户端连接维持时间是由参数 `wait_timeout` 控制的，默认值是 8 小时**。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： `Lost connection to MySQL server during query`。这时候如果你要继续，就需要重连，然后再执行请求了。\n\n#### 2.2（二）查询缓存\n\n> **不建议使用数据库缓存，因为往往弊大于利**。\n\n> 注意：MySQL 8.0 版本直接将查询缓存的整块功能删掉了。\n\n#### 2.3（三）语法分析\n\nMySQL 通过关键字对 SQL 语句进行解析，并生成一颗对应的语法解析树。\n\n1. 分析器先会先做“**词法分析**”。\n2. 接下来，要做“**语法分析**”。 \n\n#### 2.4（四）查询优化\n\n经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成执行计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。**优化器的作用就是找到这其中最好的执行计划。**\n\nMySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：\n\n- 重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）\n- 优化`MIN()`和`MAX()`函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）\n- 提前终止查询（比如：使用 Limit 时，查找到满足数量的结果集后会立即终止查询）\n- 优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I/O 密集型应用，效率会高很多）\n\n#### 2.5（五）查询执行引擎\n\n在完成解析和优化阶段以后，MySQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。\n\n#### 2.6（六）返回结果\n\n查询过程的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。\n\n### 3 更新过程\n\nMySQL 更新过程和 MySQL 查询过程类似，也会将流程走一遍。不一样的是：更新流程还涉及两个重要的日志模块，：<font color=red>**redo log（重做日志）和 bin log（归档日志）**</font>。\n\n#### 3.1 redo log\n\n**redo log 是 InnoDB 引擎特有的日志**。**redo log 即重做日志**。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”\n\n**redo log 是基于 WAL 技术**。WAL 的全称是 **Write-Ahead Logging**，它的关键点就是**先写日志，再写磁盘**。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。\n\n有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。\n\n#### 3.2 bin log\n\n**bin log 即归档日志**。binlog 是逻辑日志，记录的是这个语句的原始逻辑。\n\n**binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用**。\n\n#### 3.3 redo log vs. bin log\n\n- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n简单update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335118.png)\n\n#### 3.4 两阶段提交\n\nredo log 的写入拆成了两个步骤：`prepare` 和 `commit`，这就是\"两阶段提交\"。为什么日志需要“两阶段提交”。\n\n由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。\n\n- **先写 redo log 后写 binlog**。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。\n- **先写 binlog 后写 redo log**。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。\n\n可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。\n\n## MySQL索引\n\n### 1 索引简介\n\n> **索引是数据库为了提高查找效率的一种数据结构**。\n\n索引对于良好的性能非常关键，在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，索引优化应该是查询性能优化的最有效手段。\n\n#### 1.1 索引的优缺点\n\n✔ 索引的优点：\n\n- **索引大大减少了服务器需要扫描的数据量**，从而加快检索速度。\n- **索引可以帮助服务器避免排序和临时表**。\n- **索引可以将随机 I/O 变为顺序 I/O**。\n- 支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。**使用索引可以减少访问的行数，从而减少锁的竞争，提高并发**。\n- 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。\n\n❌ 索引的缺点：\n\n- **创建和维护索引要耗费时间**，这会随着数据量的增加而增加。\n- **索引需要占用额外的物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。\n- **写操作（`INSERT`/`UPDATE`/`DELETE`）时很可能需要更新索引，导致数据库的写操作性能降低**。\n\n#### 1.2 何时使用索引\n\n✔ 什么情况**适用**索引：\n\n- **频繁读操作（ `SELECT` ）**\n- **表的数据量比较大**。\n- **列名经常出现在 `WHERE` 或连接（`JOIN`）条件中**。\n\n❌ 什么情况**不适用**索引：\n\n- **频繁写操作**（ `INSERT`/`UPDATE`/`DELETE` ），也就意味着需要更新索引。\n- **列名不经常出现在 `WHERE` 或连接（`JOIN`）条件中**，也就意味着索引会经常无法命中，没有意义，还增加空间开销。\n- **非常小的表**，对于非常小的表，大部分情况下简单的全表扫描更高效。\n- **特大型的表**，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 NoSQL。\n\n### 2 索引的数据结构\n\n> 在 Mysql 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准；不同存储引擎的索引的数据结构也不相同。\n\n#### 2.1 哈希索引\n\n哈希索引基于哈希表实现，**只适用于等值查询**。\n\n在 Mysql 中，只有 Memory 存储引擎显示支持哈希索引。\n\n✔ 哈希索引的**优点**：\n\n- 因为索引数据结构紧凑，所以**查询速度非常快**。\n\n❌ 哈希索引的**缺点**：\n\n- 哈希索引值包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。\n\n- **哈希索引数据不是按照索引值顺序存储的**，所以**无法用于排序**。\n\n- 哈希索引**不支持部分索引匹配查找**，因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。\n\n- 哈希索引**只支持等值比较查询**，包括 `=`、`IN()`、`<=>`；不支持任何范围查询，如 `WHERE price > 100`。\n\n- 哈希索引有\n\n  可能出现哈希冲突\n\n  - 出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。\n  - 如果哈希冲突多的话，维护索引的代价会很高。\n\n> 因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。\n\n#### 2.2 B 树索引\n\n+ **二叉搜索树**\n\n一种行之有效的解决方法是减少树的深度，将**二叉树变为 N 叉树**（多路搜索树），而 **B+ 树就是一种多路搜索树**。\n\n+ **B+ 树**\n\nB+ 树索引适用于**全键值查找**、**键值范围查找**和**键前缀查找**，其中键前缀查找只适用于最左前缀查找。\n\n理解`B+Tree`时，只需要理解其最重要的两个特征即可：\n\n- 第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。\n\n- 其次，所有的叶子节点由指针连接。如下图为简化了的`B+Tree`。\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335119.jpg)\n\n根据叶子节点的内容，索引类型分为主键索引和非主键索引。\n\n- **聚簇索引（clustered）**：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。**InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行**。\n- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为**二级索引（secondary）**。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。\n\n**聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快**。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。\n\n**聚簇索引和非聚簇索引的查询有什么区别**\n\n- 如果语句是 `select * from T where ID=500`，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；\n- 如果语句是 `select * from T where k=5`，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<font color=red>**回表**</font>。\n\n也就是说，**基于非聚簇索引的查询需要多扫描一棵索引树**。因此，我们在应用中应该尽量使用主键查询。\n\n**显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。**\n\n自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：\n\n- 只有一个索引；\n- 该索引必须是唯一索引。\n\n由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。\n\n这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。\n\n#### 2.3 全文索引\n\nMyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\nInnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。\n\n#### 2.4 空间数据索引\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 3 索引的类型\n\n#### 3.1 主键索引（`PRIMAY`）\n\n一种特殊的唯一索引，不允许有空值。一个表只能有一个主键（在 InnoDB 中本质上即聚簇索引），一般是在建表的时候同时创建主键索引。\n\n#### 3.2 唯一索引（`UNIQUE`）\n\n唯一索引：**索引列的值必须唯一，但允许有空值**。如果是组合索引，则列值的组合必须唯一。\n\n#### 3.1 普通索引（`INDEX`）\n\n普通索引：最基本的索引，没有任何限制。\n\n#### 3.1 全文索引（`FULLTEXT`）\n\n全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。\n\n#### 3.1 联合索引\n\n组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。\n\n### 4  索引的策略\n\n#### 4.1 索引基本原则\n\n- **索引不是越多越好，不要为所有列都创建索引**。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。\n- 要**尽量避免冗余和重复索引**。\n- 要**考虑删除未使用的索引**。\n- **尽量的扩展索引，不要新建索引**。\n- **频繁作为 `WHERE` 过滤条件的列应该考虑添加索引**。\n\n#### 4.2 独立的列\n\n**“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数**。\n\n**对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。**\n\n如果查询中的列不是独立的列，则数据库不会使用索引。\n\n#### 4.3 覆盖索引\n\n**覆盖索引是指，索引上的信息足够满足查询请求，不需要回表查询数据。**\n\n**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**\n\n#### 4.4 使用索引来排序\n\nMysql 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。\n\n**索引最好既满足排序，又用于查找行**。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。\n\n#### 4.5 前缀索引\n\n有时候需要索引很长的字符列，这会让索引变得大且慢。\n\n这时，可以使用前缀索引，即只索引开始的部分字符，这样可以**大大节约索引空间**，从而**提高索引效率**。但这样也**会降低索引的选择性**。对于 `BLOB`/`TEXT`/`VARCHAR` 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。\n\n**索引的选择性**是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。\n\n**使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。**\n\n此外，**`order by` 无法使用前缀索引，无法把前缀索引用作覆盖索引**。\n\n#### 4.6 最左前缀匹配原则\n\nMySQL 会一直向右匹配直到遇到范围查询 `(>,<,BETWEEN,LIKE)` 就停止匹配。\n\n- 索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即**联合索引**。\n- 如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否**存在（相等）**，遇到范围查询(>、<、between、like 左匹配)等就**不能进一步匹配**了，后续退化为线性查找。\n- 因此，**列的排列顺序决定了可命中索引的列数**。\n\n**不要为每个列都创建独立索引**。\n\n**将选择性高的列或基数大的列优先排在多列索引最前列**。但有时，也需要考虑 `WHERE` 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。\n\n#### 4.7 `=`和`in`可以乱序\n\n**不需要考虑 `=`、`IN` 等的顺序**，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。\n\n### 5 索引最佳实践\n\n+ 创建了索引，并非一定有效。比如不满足前缀索引、最左前缀匹配原则、查询条件涉及函数计算等情况都无法使用索引。\n+ 此外，即使 SQL 本身符合索引的使用条件，MySQL 也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。\n\n因此，在尝试通过索引进行 SQL 性能优化的时候，务必通过执行计划（`EXPLAIN`）或实际的效果来确认索引是否能有效改善性能问题，否则增加了索引不但没解决性能问题，还增加了数据库增删改的负担。如果对 EXPLAIN 给出的执行计划有疑问的话，你还可以利用 `optimizer_trace` 查看详细的执行计划做进一步分析。\n\n## MySQL锁\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335120.png)\n\n### 1 悲观锁和乐观锁\n\n确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，**乐观锁和悲观锁是并发控制主要采用的技术手段。**\n\n- `悲观锁`\\- 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作\n\n  - 在查询完数据的时候就把事务锁起来，直到提交事务（`COMMIT`）\n  - 实现方式：**使用数据库中的锁机制**。\n\n- `乐观锁`\\- 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。\n\n  - 在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定\n\n  - 实现方式：**使用 version 版本或者时间戳**。\n\n    ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335121.png)\n\n### 2 表级锁和行级锁\n\n从数据库的锁粒度来看，MySQL 中提供了两种封锁粒度：行级锁和表级锁。\n\n- **表级锁（table lock）** - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。\n- **行级锁（row lock）** - 锁定指定的行记录。这样其它进程还是可以对同一个表中的其它记录进行操作。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高**。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此**锁粒度越小，系统开销就越大**。\n\n在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n在 `InnoDB` 中，**行锁是通过给索引上的索引项加锁来实现的**。**如果没有索引，`InnoDB` 将会通过隐藏的聚簇索引来对记录加锁**。\n\n### 3 读写锁\n\n- 独享锁（Exclusive），简写为 X 锁，又称写锁。使用方式：`SELECT ... FOR UPDATE;`\n- 共享锁（Shared），简写为 S 锁，又称读锁。使用方式：`SELECT ... LOCK IN SHARE MODE;`\n\n写锁和读锁的关系，简言之：**独享锁存在，其他事务就不能做任何操作**。\n\n**`InnoDB` 下的行锁、间隙锁、next-key 锁统统属于独享锁**。\n\n### 4 意向锁\n\n**当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁**。使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n**意向锁是 `InnoDB` 自动加的，不需要用户干预**。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁规定：\n\n- IX/IS 是表锁；\n- X/S 是行锁。\n- 一个事务在获得某个数据行的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n|  -   |  X   |  IX  |  S   |  IS  |\n| :--: | :--: | :--: | :--: | :--: |\n|  X   |  ❌   |  ❌   |  ❌   |  ❌   |\n|  IX  |  ❌   |  ✔️   |  ❌   |  ✔️   |\n|  S   |  ❌   |  ❌   |  ✔️   |  ✔️   |\n|  IS  |  ❌   |  ✔️   |  ✔️   |  ✔️   |\n\n解释如下：\n\n- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；\n- 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）\n\n### 5 MVCC\n\n**多版本并发控制（Multi-Version Concurrency Control, MVCC）可以视为行级锁的一个变种。它在很多情况下都避免了加锁操作，因此开销更低**。不仅是 Mysql，包括 Oracle、PostgreSQL 等其他数据库都实现了各自的 MVCC，实现机制没有统一标准。\n\nMVCC 是 `InnoDB` 存储引擎实现隔离级别的一种具体方式，**用于实现提交读和可重复读这两种隔离级别**。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。\n\n#### 5.1 MVCC思想\n\n加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。\n\nMVCC 的思想是：\n\n- **保存数据在某个时间点的快照，写操作（DELETE、INSERT、UPDATE）更新最新的版本快照；而读操作去读旧版本快照，没有互斥关系**。这一点和 `CopyOnWrite` 类似。\n- 脏读和不可重复读最根本的原因是**事务读取到其它事务未提交的修改**。在事务进行读取操作时，为了解决脏读和不可重复读问题，**MVCC 规定只能读取已经提交的快照**。当然一个事务可以读取自身未提交的快照，这不算是脏读。\n\n#### 5.2 版本号\n\nInnoDB 的 MVCC 实现是：在每行记录后面保存两个隐藏列，一个列保存行的创建时间，另一个列保存行的过期时间（这里的时间是指系统版本号）。每开始一个新事务，系统版本号会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\n\n- 系统版本号 `SYS_ID`：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。\n- 事务版本号 `TRX_ID` ：事务开始时的系统版本号。\n\n#### 5.3 Undo日志\n\nMVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 `ROLL_PTR` 把一个数据行的所有快照连接起来。\n\n因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 `AUTOCOMMIT` 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。\n\n`INSERT`、`UPDATE`、`DELETE` 操作会创建一个日志，并将事务版本号 `TRX_ID` 写入。`DELETE` 可以看成是一个特殊的 `UPDATE`，还会额外将 DEL 字段设置为 1。\n\n#### 5.4 ReadView\n\nMVCC 维护了一个一致性读视图 `consistent read view` ，主要包含了当前系统**未提交的事务列表** `TRX_IDs {TRX_ID_1, TRX_ID_2, ...}`，还有该列表的最小值 `TRX_ID_MIN` 和 `TRX_ID_MAX`。\n\n<img src=\"https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335122.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：\n\n1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；\n2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；\n3. 如果落在黄色部分，那就包括两种情况 a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。\n\n在进行 `SELECT` 操作时，根据数据行快照的 `TRX_ID` 与 `TRX_ID_MIN` 和 `TRX_ID_MAX` 之间的关系，从而判断数据行快照是否可以使用：\n\n- `TRX_ID` < `TRX_ID_MIN`，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。\n\n- `TRX_ID` > `TRX_ID_MAX`，表示该数据行快照是在事务启动之后被更改的，因此不可使用。\n\n- `TRX_ID_MIN`<=`TRX_ID`<=`TRX_ID_MAX`，需要根据隔离级别再进行判断：\n  - 提交读：如果 `TRX_ID` 在 `TRX_IDs` 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。\n  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。\n\n在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。\n\n#### 5.5 快照读与当前读\n\n快照读\n\nMVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。\n\n```sql\nSELECT * FROM table ...;\n```\n\n当前读\n\nMVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。**可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。**\n\n```sql\nINSERT;\nUPDATE;\nDELETE;\n```\n\n在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。\n\n```sql\nSELECT * FROM table WHERE ? lock in share mode;\nSELECT * FROM table WHERE ? for update;\n```\n\n### 6 行锁\n\n行锁的具体实现算法有三种：`record lock`、`gap lock` 以及 `next-key lock`。\n\n- `Record Lock` - **行锁对索引项加锁，若没有索引则使用表锁**。\n- `Gap Lock` - **对索引项之间的间隙加锁**。锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：`SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;`。**在 MySQL 中，gap lock 默认是开启的**，即 `innodb_locks_unsafe_for_binlog` 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。\n- `Next-key lock` -它是 `Record Lock` 和 `Gap Lock` 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。\n\n只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock。在 `Select`、`Update` 和 `Delete` 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。\n\n**MVCC 不能解决幻读问题，Next-Key 锁就是为了解决幻读问题。<font color=red>在可重复读（`REPEATABLE READ`）隔离级别下，使用 MVCC + Next-Key 锁可以解决幻读问题</font>。**\n\n索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 `UPDATE`、`DELETE` 操作时，MySQL 不仅锁定 `WHERE` 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 `next-key lock`。\n\n**当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，`InnoDB` 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。**\n\n## MySQL事务\n\n> 不是所有的 Mysql 存储引擎都实现了事务处理。支持事务的存储引擎有：`InnoDB` 和 `NDB Cluster`。不支持事务的存储引擎，代表有：`MyISAM`。\n>\n> 用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335123.png)\n\n### 1 事务简介\n\n> 事务简单来说：**一个 Session 中所进行所有的操作，要么同时成功，要么同时失败**。进一步说，事务指的是满足 ACID 特性的一组操作，可以通过 `Commit` 提交一个事务，也可以使用 `Rollback` 进行回滚。\n\n<img src=\"https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335124.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n**事务就是一组原子性的 SQL 语句**。**事务内的 SQL 语句，要么全执行成功，要么全执行失败**。\n\n**通过加锁的方式，可以实现不同的事务隔离机制**。\n\n### 2 事务用法\n\n#### 2.1 事务处理指令\n\nMySQL 中，使用 `START TRANSACTION` 语句开始一个事务；使用 `COMMIT` 语句提交所有的修改；使用 `ROLLBACK` 语句撤销所有的修改。不能回退 `SELECT` 语句，回退 `SELECT` 语句也没意义；也不能回退 `CREATE` 和 `DROP` 语句。\n\n- `START TRANSACTION` - 指令用于标记事务的起始点。\n- `SAVEPOINT` - 指令用于创建保留点。\n- `ROLLBACK TO` - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 `START TRANSACTION` 语句处。\n- `COMMIT` - 提交事务。\n\n#### 2.2 `AUTOCOMMIT`\n\n**MySQL 默认采用隐式提交策略（`autocommit`）**。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。\n\n通过 `set autocommit=0` 可以取消自动提交，直到 `set autocommit=1` 才会提交；`autocommit` 标记是针对每个连接而不是针对服务器的。\n\n```sql\n-- 查看 AUTOCOMMIT\nSHOW VARIABLES LIKE 'AUTOCOMMIT';\n\n-- 关闭 AUTOCOMMIT\nSET autocommit = 0;\n\n-- 开启 AUTOCOMMIT\nSET autocommit = 1;\n```\n\n### 3 ACID\n\nACID 是数据库事务正确执行的四个基本要素。\n\n- 原子性（Atomicity）\n  - 事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。\n  - 回滚可以用(redo log)日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n- 一致性（Consistency）\n  - 数据库在事务执行前后都保持一致性状态。\n  - 在一致性状态下，所有事务对一个数据的读取结果都是相同的。\n- 隔离性（Isolation）\n  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n- 持久性（Durability）\n  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n  - 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。\n\n> - 只有满足一致性，事务的执行结果才是正确的。\n> - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n> - 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n> - 事务满足持久化是为了能应对系统崩溃的情况。\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335125.png)\n\n### 4 事务隔离级别\n\n#### 4.1 事务隔离简介\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题：\n\n- **丢失修改**\n- **脏读**\n- **不可重复读**\n- **幻读**\n\n在 SQL 标准中，定义了四种事务隔离级别（级别由低到高）：\n\n- **未提交读(Read Uncommited)**\n- **提交读(Read Commited)**\n- **可重复读(Repeatable Read)**\n- **串行化(Serialiable)**\n\n```sql\n-- 查看事务隔离级别\nSHOW VARIABLES LIKE 'transaction_isolation';\n\n-- 设置事务隔离级别为 READ UNCOMMITTED\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n-- 设置事务隔离级别为 READ COMMITTED\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n\n-- 设置事务隔离级别为 REPEATABLE READ\nSET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n\n-- 设置事务隔离级别为 SERIALIZABLE\nSET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n```\n\n#### 4.2 未提交读\n\n**`未提交读（READ UNCOMMITTED）` 是指事务中的修改，即使没有提交，对其它事务也是可见的**。\n\n未提交读的问题：事务可以读取未提交的数据，也被称为 **脏读（Dirty Read）**。\n\n#### 4.3 提交读\n\n**`提交读（READ COMMITTED）` 是指：事务提交后，其他事务才能看到它的修改**。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。提交读解决了脏读的问题。\n\n提交读是大多数数据库的默认事务隔离级别。\n\n提交读有时也叫不可重复读，它的问题是：执行两次相同的查询，得到的结果可能不一致。\n\n#### 4.4 可重复读\n\n**`可重复读（REPEATABLE READ）` 是指：保证在同一个事务中多次读取同样数据的结果是一样的**。可重复读解决了不可重复读问题。\n\n**<font color=blue>可重复读是 MySQL 的默认事务隔离级别</font>。**\n\n可重复读的问题：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，会产生 **幻读（Phantom Read）**。\n\n#### 4.5 串行化\n\n**`串行化（SERIALIXABLE）` 是指：强制事务串行执行**。\n\n强制事务串行执行，则避免了所有的并发问题。串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。\n\n数据库隔离级别解决的问题：\n\n| 隔离级别 | 丢失修改 | 脏读 | 不可重复读 | 幻读 |\n| :------: | :------: | :--: | :--------: | :--: |\n| 未提交读 |    ✔️     |  ❌   |     ❌      |  ❌   |\n|  提交读  |    ✔️     |  ✔️   |     ❌      |  ❌   |\n| 可重复读 |    ✔️     |  ✔️   |     ✔️      |  ❌   |\n| 可串行化 |    ✔️     |  ✔️   |     ✔️      |  ✔️   |\n\n### 5 死锁\n\n**死锁是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象**。\n\n产生死锁的场景：\n\n- 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。\n- 多个事务同时锁定同一个资源时，也会产生死锁。\n\n#### 5.1 死锁的原因\n\n行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。\n\n只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。\n\n在 MySQL 中，gap lock 默认是开启的，即 innodb_locks_unsafe_for_binlog 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。\n\n当我们执行以下查询 SQL 时，由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 gap lock，这里的 gap 范围是 (4,+∞）。\n\n> SELECT id FROM `demo`.`order_record` where `order_no` = 4 for update;\n\n执行查询 SQL 语句获取的 gap lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。\n\n以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。\n\n> INSERT INTO `demo`.`order_record`(`order_no`, `status`, `create_date`) VALUES (5, 1, ‘2019-07-13 10:57:03’);\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335126.png)\n\n**另一个死锁场景**\n\nInnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。\n\n![](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335127.png)\n\n出现死锁的步骤：\n\n![](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031335128.png)\n\n综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。\n\n#### 5.2 避免死锁\n\n- 在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；\n- 在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导致的死锁问题；\n- 更新表时，**尽量使用主键更新**；\n- 避免长事务，**尽量将长事务拆解**，可以降低与其它事务发生冲突的概率；\n- **设置合理的锁等待超时参数**，我们可以通过 `innodb_lock_wait_timeout` 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。\n\n#### 5.3 解决死锁\n\n当出现死锁以后，有两种策略：\n\n- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置。\n- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 on，表示开启这个逻辑。\n\n在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。\n\n但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。\n\n所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 `innodb_deadlock_detect` 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：**将持有最少行级排它锁的事务进行回滚**。\n\n主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。\n\n### 6 分布式事务\n\n在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 **本地事务**。\n\n**分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。**\n\n分布式事务的常见方案如下：\n\n- **两阶段提交（2PC）** - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。\n- **三阶段提交（3PC）** - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。\n- 补偿事务（TCC）\n  - **Try** - 操作作为一阶段，负责资源的检查和预留。\n  - **Confirm** - 操作作为二阶段提交操作，执行真正的业务。\n  - **Cancel** - 是预留资源的取消。\n- **本地消息表** - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。\n- **MQ 事务** - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。\n- **SAGA** - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。\n\n分布式事务方案分析：\n\n- 2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。\n- TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。\n- 本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。\n- Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。\n\n### 7 事务最佳实践\n\n高并发场景下的事务到底该如何调优？\n\n1. 尽量使用低级别事务隔离\n\n结合业务场景，尽量使用低级别事务隔离\n\n2. 避免行锁升级表锁\n\n在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。\n\n3. 缩小事务范围\n\n有时候，数据库并发访问量太大，会出现以下异常：\n\n```sql\nMySQLQueryInterruptedException: Query execution was interrupted\n```\n\n高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。\n\n又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。\n\n**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**\n\n知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。\n\n## MySQL性能优化\n\n### 1 数据结构优化\n\n良好的逻辑设计和物理设计是高性能的基石。\n\n#### 1.1 数据类型优化\n\n**数据类型优化基本原则**：\n\n- **更小的通常更好**\\- 越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。\n  - 例如：整型比字符类型操作代价低，因而会使用整型来存储 IP 地址，使用 `DATETIME` 来存储时间，而不是使用字符串。\n- **简单就好**\\- 如整型比字符型操作代价低。\n  - 例如：很多软件会用整型来存储 IP 地址。\n  - 例如：**`UNSIGNED` 表示不允许负值，大致可以使正数的上限提高一倍**。\n- **尽量避免 NULL** - 可为 NULL 的列会使得索引、索引统计和值比较都更复杂。\n\n**类型的选择**\n\n- 整数类型通常是标识列最好的选择，因为它们很快并且可以使用 `AUTO_INCREMENT`。\n- `ENUM` 和 `SET` 类型通常是一个糟糕的选择，应尽量避免。\n- 应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 `MD5`、`SHA`、`UUID` 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 `INSERT` 以及一些 `SELECT` 语句变得很慢。\n  - 如果存储 UUID ，应该移除 `-` 符号；更好的做法是，用 `UNHEX()` 函数转换 UUID 值为 16 字节的数字，并存储在一个 `BINARY(16)` 的列中，检索时，可以通过 `HEX()` 函数来格式化为 16 进制格式。\n\n#### 1.2 表设计\n\n应该避免的设计问题：\n\n- **太多的列** - 设计者为了图方便，将大量冗余列加入表中，实际查询中，表中很多列是用不到的。这种宽表模式设计，会造成不小的性能代价，尤其是 `ALTER TABLE` 非常耗时。\n- **太多的关联** - 所谓的实体 - 属性 - 值（EVA）设计模式是一个常见的糟糕设计模式。Mysql 限制了每个关联操作最多只能有 61 张表，但 EVA 模式需要许多自关联。\n- **枚举** - 尽量不要用枚举，因为添加和删除字符串（枚举选项）必须使用 `ALTER TABLE`。\n- 尽量避免 `NULL`。\n\n#### 1.4 范式和反范式\n\n**范式化目标是尽量减少冗余，而反范式化则相反**。\n\n范式化的优点：\n\n- 比反范式更节省空间\n- 更新操作比反范式快\n- 更少需要 `DISTINCT` 或 `GROUP BY` 语句\n\n范式化的缺点：\n\n- 通常需要关联查询。而关联查询代价较高，如果是分表的关联查询，代价更是高昂。\n\n在真实世界中，很少会极端地使用范式化或反范式化。实际上，应该权衡范式和反范式的利弊，混合使用。\n\n#### 1.4 索引优化\n\n> 索引优化应该是查询性能优化的最有效手段。\n\n##### 1.4.1 何时使用索引\n\n- 对于非常小的表，大部分情况下简单的全表扫描更高效。\n- 对于中、大型表，索引非常有效。\n- 对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术。\n- 如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。\n\n##### 1.4.2 索引优化策略\n\n- **索引基本原则**\n  - 索引不是越多越好，不要为所有列都创建索引。\n  - 要尽量避免冗余和重复索引。\n  - 要考虑删除未使用的索引。\n  - 尽量的扩展索引，不要新建索引。\n  - 频繁作为 `WHERE` 过滤条件的列应该考虑添加索引。\n- **独立的列** - “独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。\n- **前缀索引** - 索引很长的字符列，可以索引开始的部分字符，这样可以大大节约索引空间。\n- **最左匹配原则** - 将选择性高的列或基数大的列优先排在多列索引最前列。\n- **使用索引来排序** - 索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。\n- `=`、`IN` 可以乱序 - 不需要考虑 `=`、`IN` 等的顺序\n- **覆盖索引**\n- **自增字段作主键**\n\n### 2 SQL优化\n\n使用 `EXPLAIN` 命令查看当前 SQL 是否使用了索引，优化后，再通过执行计划（`EXPLAIN`）来查看优化效果。\n\nSQL 优化基本思路：\n\n- **只返回必要的列** - 最好不要使用 `SELECT *` 语句。\n- **只返回必要的行** - 使用 `WHERE` 子查询语句进行过滤查询，有时候也需要使用 `LIMIT` 语句来限制返回的数据。\n- **缓存重复查询的数据** - 应该考虑在客户端使用缓存，尽量不要使用 Mysql 服务器缓存（存在较多问题和限制）。\n- **使用索引来覆盖查询**。\n\n#### 2.1 优化`COUNT()`语句\n\n`COUNT()` 有两种作用：\n\n- 统计某个列值的数量。统计列值时，要求列值是非 `NULL` 的，它不会统计 `NULL`。\n- 统计行数。\n\n**统计列值时，要求列值是非空的，它不会统计 NULL**。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用 `COUNT(*)` 时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。\n\n我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用 `COUNT(*)`，意义清晰，且性能更好。\n\n（1）简单优化\n\n```sql\nSELECT count(*) FROM world.city WHERE id > 5;\n\nSELECT (SELECT count(*) FROM world.city) - count(*)\nFROM world.city WHERE id <= 5;\n```\n\n（2）使用近似值\n\n有时候某些业务场景并不需要完全精确的统计值，可以用近似值来代替，`EXPLAIN` 出来的行数就是一个不错的近似值，而且执行 `EXPLAIN` 并不需要真正地去执行查询，所以成本非常低。通常来说，执行 `COUNT()` 都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 Redis 这样的外部缓存系统。\n\n#### 2.2. 优化关联查询\n\n在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用 `JOIN` 有更好的性能。\n\n如果确实需要使用关联查询的情况下，需要特别注意的是：\n\n- **确保 `ON` 和 `USING` 字句中的列上有索引**。在创建索引的时候就要考虑到关联的顺序。当表 A 和表 B 用某列 column 关联的时候，如果优化器关联的顺序是 A、B，那么就不需要在 A 表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。\n- **确保任何的 `GROUP BY` 和 `ORDER BY` 中的表达式只涉及到一个表中的列**，这样 MySQL 才有可能使用索引来优化。\n\n要理解优化关联查询的第一个技巧，就需要理解 MySQL 是如何执行关联查询的。当前 MySQL 关联执行的策略非常简单，它对任何的关联都执行**嵌套循环关联**操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。\n\n#### 2.3 优化`GROUP BY`和`DISTINCT`\n\nMySQL 优化器会在内部处理的时候相互转化这两类查询。它们都**可以使用索引来优化，这也是最有效的优化方法**。\n\n#### 2.4 优化`LIMIT`\n\n当需要分页操作时，通常会使用 `LIMIT` 加上偏移量的办法实现，同时加上合适的 `ORDER BY` 字句。**如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作**。\n\n一个常见的问题是当偏移量非常大的时候，比如：`LIMIT 10000 20`这样的查询，MySQL 需要查询 10020 条记录然后只返回 20 条记录，前面的 10000 条都将被抛弃，这样的代价非常高。\n\n<font color=red>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列</font>。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：\n\n```sql\nSELECT film_id,description FROM film ORDER BY title LIMIT 50,5;\n```\n\n如果这张表非常大，那么这个查询最好改成下面的样子：\n\n```sql\nSELECT film.film_id,film.description\nFROM film INNER JOIN (\n    SELECT film_id FROM film ORDER BY title LIMIT 50,5\n) AS tmp USING(film_id);\n```\n\n这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。\n\n有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用`OFFSET`，比如下面的查询：\n\n```sql\nSELECT id FROM t LIMIT 10000, 10;\n改为：\nSELECT id FROM t WHERE id > 10000 LIMIT 10;\n```\n\n其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。\n\n#### 2.5 优化`UNION`\n\nMySQL 总是通过创建并填充临时表的方式来执行 `UNION` 查询。因此很多优化策略在`UNION`查询中都没有办法很好的时候。经常需要手动将`WHERE`、`LIMIT`、`ORDER BY`等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。\n\n**除非确实需要服务器去重，否则就一定要使用`UNION ALL`**，如果没有`ALL`关键字，MySQL 会给临时表加上`DISTINCT`选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用 ALL 关键字，MySQL 总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。\n\n#### 2.6 优化查询方式\n\n##### 2.6.1 切分大查询\n\n一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\n\n```sql\nDELEFT FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    \"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")\n} while rows_affected > 0\n```\n\n##### 2.6.2 分解大连接查询\n\n将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：\n\n- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。\n- 减少锁竞争；\n- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。\n- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n### 3 执行计划（`EXPLAIN`）\n\n如何判断当前 SQL 是否使用了索引？如何检验修改后的 SQL 确实有优化效果？\n\n在 SQL 中，可以通过执行计划（`EXPLAIN`）分析 `SELECT` 查询效率。\n\n### 4 optimizer trace\n\n在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。\n\n### 5 数据模型和业务\n\n- 表字段比较复杂、易变动、结构难以统一的情况下，可以考虑使用 Nosql 来代替关系数据库表存储，如 ElasticSearch、MongoDB。\n- 在高并发情况下的查询操作，可以使用缓存（如 Redis）代替数据库操作，提高并发性能。\n- 数据量增长较快的表，需要考虑水平分表或分库，避免单表操作的性能瓶颈。\n- 除此之外，我们应该通过一些优化，尽量避免比较复杂的 JOIN 查询操作，例如冗余一些字段，减少 JOIN 查询；创建一些中间表，减少 JOIN 查询。\n","tags":["SQL","MySQL"],"categories":["学习笔记"]},{"title":"Vue3","url":"/hexo-blog/2023/03/03/Vue/","content":"\n# Vue3\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2023.03.03 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 1 简介\n\n> Node.js；VsCode+VsCode扩展Volar；浏览器调试工具Vue.js devtools\n\n> `Vue`是一款用于构建用户界面的`JavaScript` 框架；它基于标准`HTML`、`CSS` 和`JavaScript` 构建，并提供了一套声明式的、组件化的编程模型，帮助你事效地开发用户界面。\n\n### 1.1 MVVM（Model，View，ViewModel）\n\n`MVVM`指的是`Model`，`View`和`ViewModel`\n●`Model` ：页面渲染用到的数据源。\n●`View` ：页面所渲染的`DOM`结构。\n●`ViewModel` ：表示`vue`的实例。\n\n![image-20230302105615927](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340790.png)\n\n## 2 创建单页面应用程序\n\n![image-20230302105743440](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340792.png)\n\n脚本标签，视图标签，样式标签\n\n选项式API，组合式API\n\n## 3 响应式数据\n\n### 3.1 选项式API的响应式数据\n\n1. `data`声明组件的响应式状态\n2. `this`组件实例\n\n### 3.2 组合式API的响应式数据\n\n1. 在组合式API中直接声明普通变量的数据源，不具备响应式数据。\n\n   ![image-20230219142613684](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340793.png)\n\n#### 3.2.1 `reactive()`函数\n\n+ `reactive()`函数只对对象类型（对象，数组，`Map`，`Set`）有效，对原始类型（`string`，`number`，`boolean`）无效。\n\n  ![image-20230219143249234](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340794.png)\n\n#### 3.2.2 `ref()`函数\n\n+ 可创建任何类型的响应式数据，获取时需要通过`。value`来进行获取。\n\n+ 当值为对象类型时，会用`reactive()`自动转换它的`.value`。\n\n  ![image-20230219144135005](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340795.png)\n\n## 4 模板语法\n\n### 4.1 内容渲染指令\n\n#### 4.1.1 `v-text`\n\n+ 将数据采用纯文本形式填充其空元素中。\n\n  ```vue\n  <!-- 脚本标签 -->\n  <script setup>\n  \n  import { reactive } from 'vue'\n  \n  let student = reactive({\n      name: 'Jack',\n      desc: '<h3>我来自中国！</h3>'\n  })\n  \n  </script>\n  \n  <!-- 视图标签 -->\n  <template>\n      <div v-text=\"student.name\"></div>\n      <!-- v-text：以纯文本的方式显示数据 -->\n      <div v-text=\"student.desc\"></div>\n      <!-- div不是空元素，会报错 -->\n  <!-- <div v-text=\"student.desc\">这是原始div数据</div> -->\n  </template>\n  ```\n\n\n#### 4.1.2 `v-html`\n\n+ 将数据以`HTML`语法填充其空元素中。\n\n  ```vue\n  <!-- 脚本标签 -->\n  <script setup>\n  \n  import { reactive } from 'vue'\n  \n  let student = reactive({\n      name: 'Jack',\n      desc: '<h3>我来自中国！</h3>'\n  })\n  \n  </script>\n  \n  <!-- 视图标签 -->\n  <template>\n      <div v-html=\"student.name\"></div>\n      <!-- v-html：以html语法显示数据 -->\n      <div v-html=\"student.desc\"></div>\n  </template>\n  ```\n\n#### 4.1.3 `{{}}`插值表达式\n\n+ 在元素中的某一位置采用纯文本方式渲染数据。\n\n  ```vue\n  <!-- 脚本标签 -->\n  <script setup>\n  \n  import { reactive } from 'vue'\n  \n  let student = reactive({\n      name: 'Jack',\n      desc: '<h3>我来自中国！</h3>'\n  })\n  \n  </script>\n  \n  <!-- 视图标签 -->\n  <template><!-- 插值表达式：在元素中的某一位置采用纯文本方式渲染数据 -->\n      <div>这是一个div元素，{{ student.name }}，{{ student.desc }}</div>\n  </template>\n  ```\n\n### 4.2 双向绑定指令\n\n#### 4.2.1 `v-model`\n\n+ `v-model`双向绑定数据指令，视图数据和数据源同步\n\n+ 一般情况下用在表单元素中：\n\n  +  文本类型的`<input>`和`<textarea>`元素会绑定`value`属性并监听`input`事件；\n  + `<input type=\"checkbox\">` 和`<input type=\"radio\">`会绑定`checked`属性并监听`change`事件；\n  + `<select>`会绑定`value`属性并监听`change`事件\n\n  ```vue\n  <!-- 脚本标签 -->\n  <script>\n  export default {\n      data: () => ({\n          inputText: 'ABC',\n          message: 'dvdvvv',\n          open: true,\n          determine: false,\n      })\n  }\n  </script>\n  \n  <!-- 视图标签 -->\n  <template>\n       <!-- 单行文本框 -->\n      <input type=\"text\" v-model=\"inputText\">\n  \n      <hr>\n      <!-- 多行文本框 -->\n      <textarea v-model=\"message\"></textarea>\n  \n      <hr>\n      <!-- 默认情况下，复选框的值：true/false -->\n      <input type=\"checkbox\" v-model=\"open\">灯\n  \n      <hr>\n      <!-- 自定义复选框，true-value/false-value -->\n      <input type=\"checkbox\" true-value=\"确定\" false-value=\"不确定\" v-model=\"determine\">是否确定\n  </template>\n  ```\n\n  #### 4.2.2 `v-model`的修饰符\n\n  | 修饰符    | 作用                                          | 示例                           |\n  | --------- | --------------------------------------------- | ------------------------------ |\n  | `.number` | 自动将用户的输入值转为数值类型                | `<input v-model.number=\"age\">` |\n  | `.trim`   | 自动过滤用户输入的首尾空白字符                | `<input v-model.trim=\"msg\">`   |\n  | `.lazy`   | 在\"change\"时而非\"input\"时更新(失去焦点时触发) | `<input v-model.lazy=\"msg\">`   |\n\n  ![image-20230219155304307](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340796.png)\n\n### 4.3 属性绑定指令\n\n+ `v-bind:`：响应式地绑定一个元素属性\n\n+ 如果绑定的值为`null`或`undefined`，那么该属性将会从渲染的元素上移除\n\n  ```vue\n  <!-- 脚本标签 -->\n  <script setup>\n  import { ref } from 'vue'\n  let picture = ref({\n      width: 200,\n      src: 'https://w.wallhaven.cc/full/l8/wallhaven-l83o92.jpg'\n  })\n  </script>\n  \n  <!-- 视图标签 -->\n  <template>\n      <!-- v-bind: 属性绑定指令，想让属性有一个响应式数据 -->\n      <img v-bind:src=\"picture.src\" v-bind:width=\"picture.width\">\n  \n      <hr>\n      <!-- 简写语法 -->\n      <img :src=\"picture.src\" :width=\"picture.width\">\n          \n      <hr>   \n      <!-- 如果将属性绑定的数据源设置成null或undefined，会将该属性移除 -->\n      <button @click=\"picture.width = null\"></button>\n  </template>\n  ```\n\n#### 4.3.1 动态绑定多个属性值\n\n```vue\n<script setup>\nimport { reactive } from 'vue'\n\nlet attr = reactive({\n    class: 'error',\n    id: 'borderblue'\n})\n\n</script>\n\n<template>\n    <!-- 直接使用v-bind来为元素绑定多个属性及其值 -->\n    <button v-bind=\"attr\">我是一个普通按钮</button>\n</template>\n\n<style>\n.error {\n    background-color: rgb(116, 75, 75);\n    color: white;\n}\n\n.borderblue {\n    border: 2px solid rgb(100, 75, 116);\n}\n</style>\n```\n\n#### 4.3.2 绑定`class`和`style`属性\n\n+ `class`绑定数组和对象\n\n```vue\n<script setup>\nimport { reactive } from 'vue'\n\nlet btnClassObject = reactive({\n    error: false,\n    flat: false\n})\n\n</script>\n\n<template>\n    <input type=\"checkbox\" v-model=\"btnClassObject.error\">主题\n    <input type=\"checkbox\" v-model=\"btnClassObject.flat\">阴影\n    <br>\n    <br>\n    <button :class=\"btnClassObject\">我是一个普通按钮</button>\n</template>\n\n<style>\nbutton {\n    border: none;\n    padding: 15px 20px;\n    background-color: blue;\n}\n\n.error {\n    background-color: rgb(155, 35, 35);\n    color: white;\n}\n\n.flat {\n    border: 0 0 8px gray;\n}\n</style>\n```\n\n+ `style`绑定数组和对象\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet btnTheme = ref({\n    backgroundColor: '#FF0000',//背景色\n    color: '#000000' //文本色\n})\nlet backColor = ref('#0000FF')//背景色\nlet textColor = ref('#000000')//文本色\nlet borRadius = ref(20)//边框圆角\n\n</script>\n\n<template>\n    背景色：<input type=\"color\" v-model=\"btnTheme.backgroundColor\">\n    文本色：<input type=\"color\" v-model=\"btnTheme.color\">\n    <br>\n    <br>\n    <!-- style: 可以直接绑定对象数据源，但是对象数据源的属性名作为样式属性（注意命名） -->\n    <button :style=\"btnTheme\">我是一个普通按钮</button>\n\n    <hr>\n    背景色：<input type=\"color\" v-model=\"backColor\">\n    文本色：<input type=\"color\" v-model=\"textColor\">\n    边框圆角：<input type=\"range\" min=\"0\" max=\"20\" v-model=\"borRadius\">\n    <br>\n    <br>\n    <!-- 可以传入对象 -->\n    <button :style=\"{\n        backgroundColor: backColor,\n        color: textColor,\n        'border-radius': borRadius + 'px'\n    }\">我是一个普通按钮</button>\n</template>\n\n<style>\nbutton {\n    border: none;\n    padding: 15px 20px;\n    background-color: blue;\n}\n</style>\n```\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet btnTheme = ref([\n    {\n        backgroundColor: '#FF0000',//背景色\n        color: '#FFFFFF' //文本色\n    },\n    {\n        borderRadius: 0\n    }\n])\n\n</script>\n\n<template>\n    背景色：<input type=\"color\" v-model=\"btnTheme[0].backgroundColor\">\n    文本色：<input type=\"color\" v-model=\"btnTheme[0].color\">\n    边框圆角：<input type=\"checkbox\" true-value=\"10px\" false-value=\"0\" v-model=\"btnTheme[1].borderRadius\">\n    <br>\n    <br>\n    <!-- style: 绑定数组 -->\n    <button :style=\"btnTheme\">我是一个普通按钮</button>\n</template>\n\n<style>\nbutton {\n    border: none;\n    padding: 15px 20px;\n    background-color: blue;\n}\n</style>\n```\n\n### 4.4 条件渲染指令\n\n#### 4.4.1 `v-if`, `v-else-if`,`v-else`\n\n+ 为`true`才渲染\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet isShow = ref(false)\nlet age = ref(20)\nlet week = ref(3)//星期\n\n</script>\n\n<template>\n    是否显示：<input type=\"checkbox\" v-model=\"isShow\">\n    <h3 v-if=\"isShow\">这是一个普通的标题标签</h3>\n    <hr>\n    年龄{{ age }}: <input type=\"range\" min=\"0\" max=\"100\" v-model=\"age\">\n    <h3 v-if=\"age < 18\">未成年</h3>\n    <h3 v-else-if=\"age < 35\">青年</h3>\n    <h3 v-else-if=\"age < 50\">中年</h3>\n    <h3 v-else>老年</h3>\n    <hr>\n\n    <!-- 可以配合template使用，template元素不渲染 -->\n    星期{{ week }}：<input type=\"range\" min=\"1\" max=\"7\" v-model=\"week\">\n    <template v-if=\"week == 1 || week == 3 || week == 5\">\n        <h1>可以游泳</h1>\n    </template>\n    <template v-else>\n        <h1>不可以游泳</h1>\n    </template>\n</template>\n```\n\n#### 4.4.2 `v-show`\n\n+ `false`也会渲染，但是不显示（样式属性：`display: none`）。\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet isShow = ref(false)\nlet age = ref(20)\n\n</script>\n\n<template>\n    是否显示：<input type=\"checkbox\" v-model=\"isShow\">\n    <h3 v-show=\"isShow\">这是一个普通的标题标签</h3>\n    <hr>\n    年龄{{ age }}: <input type=\"range\" min=\"0\" max=\"100\" v-model=\"age\">\n    <h3 v-show=\"age < 18\">未成年</h3>\n    <h3 v-show=\"age >= 18 && age < 35\">青年</h3>\n    <h3 v-show=\"age >= 35 && age < 50\">中年</h3>\n    <h3 v-show=\"age >= 50\">老年</h3>\n    <hr>\n</template>\n```\n\n### 4.5 事件绑定指令\n\n+ `v-on:`(简写为`@`)监听事件，用法：`v-on:click=\"\"`或`@click=\"\"`\n\n#### 4.5.1 事件修饰符\n\n+ `.prevent`：阻止默认行为\n+ `.stop`：阻止事件冒泡\n+ `.capture`：使事件触发从包含这个元素的顶层开始往下触发\n+ `.once`：绑定了事件以后只能触发一次，第二次就不会触发\n+ `.self`：只当在 event.target 是当前元素自身时触发处理函数\n+ `.passive`：不阻止事件的默认行为\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\n\nfunction say(value) {\n    window.alert('你好,' + value)\n}\n\nfunction passive() {\n    //阻止事件默认行为\n    event.preventDefault()\n}\n\n</script>\n\n<template>\n    <br>\n    <!-- .prevent修饰符阻止了超链接的默认行为 -->\n    <a href=\"https://www.baidu.com\" @click.prevent=\"say('BAIDU')\">百度</a>\n    <hr>\n\n    <div class=\"divArea\" @click=\"say('DIV')\">\n        <!-- .stop: 阻止产生冒泡事件 -->\n        <button @click.stop=\"say('BUTTON')\">冒泡按钮</button>\n    </div>\n    <hr>\n    <!-- .capture: 给元素添加一个监听器\n                   1. 当元素事件产生冒泡时，先触发的是该修饰符的元素的事件\n                   2. 如果有多个该修饰符，则由外向内依次触发 -->\n    <div class=\"divArea\" @click=\"say('DIV-1')\">\n        <div class=\"divArea\" @click.capture=\"say('DIV-2')\">\n            <div class=\"divArea\" @click=\"say('DIV-3')\">\n                <button>我是一个普通的按钮</button>\n            </div>\n        </div>\n    </div>\n\n    <hr>\n    <!-- .self：只在该元素上触发事件有效 -->\n    <div class=\"divArea\" @click.self=\"say('DIV')\">\n        <button>我是一个普通的按钮</button>\n    </div>\n\n    <hr>\n    <!-- .passive: 先执行默认行为，不考虑执行的代码中是否包含event.preventDefault() -->\n    <a href=\"https://www.baidu.com\" @click.passive=\"passive\">百度</a>\n</template>\n\n<style>\n.divArea {\n    padding: 30px;\n    border: 2px solid blue;\n}\n</style>\n\n```\n\n\n\n#### 4.5.2 按键修饰符\n\n+ 按键别名:`.enter` 、`.tab` 、`.esc` 、`.space` 、`.up` 、`.down` 、`.1eft` 、`.right` 、`.delete` (捕获 `Delete` 和`Backspace` 两个按键)\n+ 系统修饰符: `.ctrl` 、`.alt` 、`.shift` 、`.meta`\n+ 准确的修饰符: `.exact`\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nfunction showMessage(message) {\n    window.alert(message)\n}\n\n</script>\n\n<template>\n    按下了Enter键(包含)：<input type=\"text\" @keydown.enter=\"showMessage('你按下了enter键')\">\n    <hr>\n    按下了Shift+Enter键(包含)：<input type=\"text\" @keydown.enter.shift=\"showMessage('你按下了shift+enter键')\">\n    <hr>\n    按下了Shift+Enter键(唯一)：<input type=\"text\" @keydown.enter.shift.exact=\"showMessage('你准确按下了shift+enter键')\">\n</template>\n\n\n```\n\n#### 4.5.3 鼠标按键修饰符\n\n+ `.left`, `.right`, `.middle`\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nfunction showMessage(message) {\n    window.alert(message)\n}\n\n</script>\n\n<template>\n    按下了鼠标左键(包含)：<button @mousedown.left=\"showMessage('你按下了鼠标左键')\">请点击鼠标按键</button>\n    <hr>\n    按下了鼠标中键(包含)：<button @mousedown.middle=\"showMessage('你按下了鼠标中键')\">请点击鼠标按键</button>\n    <hr>\n    按下了鼠标右键(包含)：<button @mousedown.right=\"showMessage('你按下了鼠标右键')\">请点击鼠标按键</button>\n    <hr>\n</template>\n```\n\n### 4.6 列表渲染指令\n\n#### 4.6.1 `v-for`渲染数组\n\n+ item `in` items\n+ (item, index)`in` items\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet subject = ref([\n    { id: 1, name: 'Vue' },\n    { id: 2, name: 'Java' },\n    { id: 3, name: 'C/C++' },\n    { id: 4, name: 'Python' },\n    { id: 5, name: 'MySQL' }\n])\n\n</script>\n\n<template>\n    <br>\n    <!-- item in items\n                    item: 当前值\n                    items:数组 -->\n    <ul>\n        <li v-for=\"sub in subject\">\n            编号：{{ sub.id }} ------ 名称：{{ sub.name }}\n        </li>\n    </ul>\n\n    <hr>\n    <!-- 解构对象 -->\n    <ul>\n        <li v-for=\"{ id, name } in subject\">\n            编号：{{ id }} ------ 名称：{{ name }}\n        </li>\n    </ul>\n\n    <hr>\n    <ul>\n        <li v-for=\"( sub, index ) in subject\">\n            编号：{{ sub.id }} ------ 名称：{{ sub.name }} ------ 索引：{{ index }}\n        </li>\n    </ul>\n</template>\n\n```\n\n#### 4.6.2 `v-for`渲染对象\n\n1. value `in` object\n2. (value, key) `in` object\n3. (value, key, index) `in` object\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet student = ref({\n    id: 1,\n    name: '张三',\n    sex: '男'\n})\n\n</script>\n\n<template>\n    <br>\n    <ul>\n        <li v-for=\"value in student\">\n            {{ value }}\n        </li>\n    </ul>\n    <hr>\n\n    <ul>\n        <li v-for=\"(value, key) in student\">\n            {{ key }}: {{ value }}\n        </li>\n    </ul>\n    <hr>\n\n    <ul>\n        <li v-for=\"(value, key, index) in student\">\n            {{ index }}. {{ key }}: {{ value }}\n        </li>\n    </ul>\n    <hr>\n</template>\n```\n\n#### 4.6.3 通过key管理状态\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nlet subject = ref([\n    { id: 1, name: 'Vue' },\n    { id: 2, name: 'Java' },\n    { id: 3, name: 'C/C++' }\n])\n\nfunction addSubject() {\n    subject.value.unshift({ id: 4, name: 'Python' })\n}\n\n</script>\n\n<template>\n    <br>\n    <button @click.once=\"addSubject\">添加课程（数组最前面）</button>\n    <h3>不使用key值</h3>\n    <ul>\n        <li v-for=\"sub in subject\">\n            <input type=\"checkbox\">\n            {{ sub }}\n        </li>\n    </ul>\n    <hr>\n\n    <h3>使用索引当key值</h3>\n    <ul>\n        <li v-for=\"(sub, index) in subject\" :key=\"index\">\n            <input type=\"checkbox\">\n            {{ sub }}\n        </li>\n    </ul>\n    <hr>\n\n    <h3>使用列表属性当key值，该属性必须唯一</h3>\n    <ul>\n        <li v-for=\"sub in subject\" :key=\"sub.id\">\n            <input type=\"checkbox\">\n            {{ sub }}\n        </li>\n    </ul>\n    <hr>\n</template>\n```\n\n<!--2023.02.20 17:03-->\n\n## 5 侦听器\n\n### 5.1 选项式API中的侦听器\n\n+ `watch`\n\n#### 5.1.1 函数式侦听器\n\n+ `watch`中声明的函数即为函数式侦听器，其中函数名就是要侦听的数据源。函数中的参数1为新数据值，参数2为旧数据值。\n\n```vue\n<script>\nexport default {\n    data: () => ({\n        age: 30,\n        emp: {\n            name: 'Jack', //名字\n            salary: 7000  //工资\n        }\n    }),\n    // 侦听器\n    watch: {\n        /**\n         * 侦听age数据源是否发生变化\n         * @param {*} newData 新值\n         * @param {*} oldData 旧值\n         */\n        age(newData, oldData) {\n            console.log('newData:' + newData)\n            console.log('oldData:' + oldData)\n        },\n        /**\n         * 侦听emp.name数据源是否发生变化\n         * (通过采用字符串路径的形式来侦听对象中的某个属性)\n         * @param {*} newData \n         * @param {*} oldData \n         */\n        'emp.name'(newData, oldData) {\n            console.log('newData:' + newData)\n            console.log('oldData:' + oldData)\n        }\n    }\n}\n</script>\n\n<template>\n    <br>\n    年龄：<input type=\"number\" v-model=\"age\">\n    <hr>\n    员工的名字：<input type=\"text\" v-model=\"emp.name\">\n</template>\n\n```\n\n#### 5.1.2 对象式侦听器\n\n+ 在`watch`选项中声明的对象即为对象式侦听器，对象名就是要侦听的数据源，其中对象里的`handler `函数为数据源发生变化后需要执行的代码块，其参数1为新数据值，参数2为旧数据值。\n\n```vue\n<script>\nexport default {\n    data: () => ({\n        age: 30,\n    }),\n    // 侦听器\n    watch: {\n        /**\n         * 如果age数据源发生变化，执行handler的代码片段\n         * @param {*} newData 新值\n         * @param {*} oldData 旧值\n         */\n        age: {\n            handler(newData, oldData) {\n                console.log('newData:' + newData)\n                console.log('oldData:' + oldData)\n            }\n        }\n    }\n}\n</script>\n\n<template>\n    <br>\n    年龄：<input type=\"number\" v-model=\"age\">\n    <hr>\n</template>\n```\n\n+ `deep`\n  +  默认的浅层次的侦听器，只有侦听的数据源的值发生变化时，才会触发`handler`片段，而改变侦听的数据源中的嵌套属性值并不会触发该函数。\n  + `deep:true`侦听所有嵌套的变更（开销很大）。\n  + `deep:true`，只改变对象里面的某个属性值，会触发handler函数，但是newData和oldData是相同的（都是新值）\n  + 只有当改变监听对象的值时，newData和OldData才不同 。\n\n```vue\n<script>\nexport default {\n    data: () => ({\n        emp: {\n            name: 'Jack', //名字\n            salary: 7000  //工资\n        },\n        student: {\n            name: 'Tom',\n            age: 18\n        }\n    }),\n    // 侦听器\n    watch: {\n        emp: {\n            // 默认的浅层次的侦听器，只有侦听的数据源的值发生变化时，才会触发handler片段，而改变侦听的数据源中的嵌套属性值并不会触发该函数。\n            handler(newData, oldData) {\n                console.log(newData)\n                console.log(oldData)\n            }\n        },\n        student: {\n            // 深度侦听，只改变对象里面的某个属性值，会触发handler函数,但是newData和oldData是相同的\n            // 只有当改变监听对象的值时，newData和OldData才不同\n            deep: true,\n            handler(newData, oldData) {\n                console.log(newData)\n                console.log(oldData)\n            }\n        }\n    }\n}\n</script>\n\n<template>\n    <br>\n    员工名字：<input type=\"text\" v-model=\"emp.name\">\n    <hr>\n    学生年龄：<input type=\"number\" v-model=\"student.age\">\n</template>\n\n```\n\n+ `immediate`\n  + `watch`默认懒执行\n  + `immediate:true`\n\n```vue\n<script>\nexport default {\n    data: () => ({\n        account: 'Abc',\n        student: {\n            name: 'Tom',\n            age: 18\n        }\n    }),\n    // 侦听器\n    watch: {\n        account: {\n            //默认情况下，侦听器懒执行，仅当数据源发生变化，才执行回调\n            handler(newData, oldData) {\n                console.log(newData)\n                console.log(oldData)\n            }\n        },\n        student: {\n            deep: true,\n            immediate: true,//创建侦听器时立即执行一次该handler函数\n            handler(newData, oldData) {\n                console.log(newData)\n                console.log(oldData)\n            }\n        }\n    }\n}\n</script>\n\n<template>\n    <br>\n    账号：<input type=\"text\" v-model=\"account\">\n    <hr>\n    学生年龄：<input type=\"number\" v-model=\"student.age\">\n</template>\n```\n\n+ `flush`\n  + `flush:'post'`\n\n```vue\n<script>\nexport default {\n    data: () => ({\n        account: 'Abc'\n    }),\n    // 侦听器\n    watch: {\n        account: {\n            flush: 'post',//更改回调的触发机制（Dom更新后）\n            handler(newData, oldData) {\n                console.log(newData)\n                console.log(oldData)\n                //默认情况下，回调函数中访问Dom将是更新之前的状态\n                console.log(document.getElementById('titleAccount').innerHTML);\n            }\n        }\n    }\n}\n</script>\n\n<template>\n    <br>\n    <h3 id=\"titleAccount\">\n        最新账号：<span>{{ account }}</span>\n    </h3>\n    账号：<input type=\"text\" v-model=\"account\">\n</template>\n```\n\n#### 5.1.3 `this.$watch`侦听器\n\n+ 创建侦听器\n\n![image-20230221153437435](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340797.png)\n\n```vue\n<script>\nimport { onMounted } from 'vue';\n\nexport default {\n    data: () => ({\n        account: 'Abc'\n    }),\n    //生命周期函数，页面成功渲染后\n    mounted() {\n        this.$watch('account', (newData, oldData) => {\n            console.log(newData)\n            console.log(oldData)\n        }, { deep: true, immediate: true })\n    }\n}\n</script>\n\n<template>\n    <br>\n    账号：<input type=\"text\" v-model=\"account\">\n</template>\n```\n\n+ 停止侦听器\n  + 需要自行停止侦听器，这时可以调用`$watch()` API 返回的函数。\n\n```vue\n<script>\nimport { onMounted } from 'vue';\n\nexport default {\n    data: () => ({\n        account: 'Abc',\n        stopAccountWatch: null //调用该函数，停止侦听数据源\n    }),\n    //生命周期函数，页面成功渲染后\n    mounted() {\n        this.stopAccountWatch = this.$watch('account', (newData, oldData) => {\n            console.log(newData)\n            console.log(oldData)\n        }, { deep: true, immediate: true })\n    }\n}\n</script>\n\n<template>\n    <br>\n    账号：<input type=\"text\" v-model=\"account\">\n    <button @click=\"stopAccountWatch\">停止侦听数据源</button>\n</template>\n```\n\n### 5.2 组合式API中的侦听器\n\n+ `watch`函数或`watchEffect`函数在每次响应式状态变化时触发对应的回调函数。\n\n#### 5.2.1 `watch()`函数\n\n+ 创建侦听器\n\n![image-20230221154207981](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340798.png)\n\n```vue\n<script setup>\nimport { reactive, ref, watch } from 'vue';\n\nlet account = ref('Abc')\n\nconst emp = reactive({\n    name: 'Jack',\n    salary: 8000\n})\nconst dept = reactive({\n    id: '101',\n    name: '销售部'\n})\n\nconst region = reactive({\n    id: '201',\n    name: '北美洲'\n})\n// 侦听原始类型的数据\nwatch(account, (newData, oldData) => {\n    console.log(\"===账号新旧值===\")\n    console.log(newData)\n    console.log(oldData)\n})\n// 侦听对象中的某个属性（必须提供获取该属性的函数）\nwatch(() => emp.salary, (newData, oldData) => {\n    console.log(\"===员工薪资新旧值===\")\n    console.log(newData)\n    console.log(oldData)\n})\n//侦听一个对象,\nwatch(emp,\n    //如果嵌套属性值发生变化，那么也会触发该回调函数，但是新旧值相等。    \n    (newData, oldData) => {\n        console.log(\"===员工信息新旧值===\")\n        console.log(newData)\n        console.log(oldData)\n    })\n//侦听一个对象(getter)\nwatch(() => dept,\n    //如果嵌套属性值发生变化，默认情况下不会触发该回调函数。    \n    (newData, oldData) => {\n        console.log(\"===部门信息新旧值===\")\n        console.log(newData)\n        console.log(oldData)\n    })\n\n//侦听一个对象(getter)\nwatch(() => region,\n    //如果嵌套属性值发生变化，配置了深度侦听，会触发该回调函数，但值相同。    \n    (newData, oldData) => {\n        console.log(\"===区域信息新旧值===\")\n        console.log(newData)\n        console.log(oldData)\n    },\n    { deep: true })\n</script>\n\n<template>\n    <br>\n    账号：<input type=\"text\" v-model=\"account\">\n    <hr>\n    薪资：<input type=\"number\" v-model=\"emp.salary\">\n    <hr>\n    部门：<input type=\"text\" v-model=\"dept.name\">\n    <hr>\n    区域：<input type=\"text\" v-model=\"region.name\">\n</template>\n```\n\n+ 停止侦听器：调用`watch()`API返回的函数\n\n#### 5.2.2 `watchEffect()`函数\n\n+ `watchPostEffect()`函数：回调函数的触发机制在DOM更新之后\n\n```vue\n<script setup>\nimport { reactive, ref, watch, watchEffect } from 'vue';\n\nlet account = ref('Abc')\n// 创建成功后立即执行一次\nwatchEffect(() => {\n    //如果该数据源的值发生了变化，会重新执行该回调函数\n    console.log(account.value);\n})\n</script>\n\n<template>\n    <br>\n    账号：<input type=\"text\" v-model=\"account\">\n</template>\n```\n\n```vue\n<script setup>\nimport { onMounted, reactive, ref, watch, watchEffect } from 'vue';\n\nlet account = ref('Abc')\n\nlet password = ref('123456')\n\n//当视图渲染成功后\nonMounted(() => {\n    // 侦听账号\n    watchEffect(() => {\n        console.log('--------------');\n        console.log(account.value)\n        //默认情况下，回调触发机制，在Dom更新之前\n        console.log(document.getElementById('titleAccount').innerHTML)\n    }),\n    // 侦听密码\n    watchEffect(() => {\n        console.log('=============');\n        console.log(password.value)\n        //默认情况下，回调触发机制，在Dom更新之前\n        console.log(document.getElementById('titlePassword').innerHTML)\n    },\n    //更改回调函数的触发机制，在Dom更新之后\n    { flush: 'post' })\n})\n\n</script>\n\n<template>\n    <br>\n    <h1 id=\"titleAccount\">账号: <i>{{ account }}</i></h1>\n    账号：<input type=\"text\" v-model=\"account\">\n    <hr>\n    <h1 id=\"titlePassword\">密码: <i>{{ password }}</i></h1>\n    密码<input type=\"text\" v-model=\"password\">\n</template>\n```\n\n+ 停止侦听器：调用`watchEffect()`或者`watchPostEffect()`API返回的函数。\n\n<!--2023.02.21 17:35-->\n\n## 6 计算属性\n\n+ 使用计算属性描述依赖响应式状态的复杂逻辑。\n  + 选项式API中，提供`computed`选项来声明计算属性。\n  + 组合式API中，通过`computed`回调函数返回的值来声明计算属性。\n\n```vue\n<script setup>\nimport { computed, ref } from 'vue';\n\nlet age = ref(20)\n\n// 计算属性\nlet ageState = computed(() => {\n    if (age.value < 18) { return '未成年' }\n    else if (age.value < 35) {\n        return '青年'\n    }\n    else if (age.value < 50) {\n        return '中年'\n    }\n    else {\n        return '老年'\n    }\n})\n\n</script>\n\n<template>\n    <br>\n    年龄：<input type=\"number\" v-model.lazy=\"age\">\n    <!-- 简单的表达式 -->\n    <h3>年龄阶段（简单）：{{ age < 18 ? '未成年' : '成年' }} </h3>\n    <!-- 计算属性 -->\n    <h3>年龄阶段（复杂）：{{ ageState }} </h3>\n</template>\n```\n\n+ 计算属性与方法的区别\n  + 两种方式在结果上确实是完全相同的，不同之处在于计算属性值会基于其响应式依赖被缓存。\n  + 一个计算属性仅会在其响应式依赖更新时才重新计算。 这意味着只要所依赖的数据源不改变，无论多少次访问计算属性都会立即返回先前的计算结果，而不用重复执行`getter`函数。\n  + 方法调用总是会在重新渲染发生时再次执行函数。\n+ 计算属性注意事项：\n  + 不要在计算属性中做异步请求或更改DOM。\n  + 避免直接修改计算属性值。\n\n## 7 组件\n\n### 7.1 注册组件\n\n+ 一个Vue组件在使用前需要先被“注册”，这样Vue才能在染模板时找到其对应的实现；组件注册有两种方式：全局注册、局部注册。\n\n#### 7.1.1 全局注册\n\n+ 在`main.js`中可使用`app.component(namg, Component)`注册组件的方法， 在此应用的任意组件的模板中使用。\n  + `name` ：注册的名字\n  + `Component` ：需要注册的组件\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport LoginVue from './components/Login.vue'\n\n// import './assets/main.css'\n\n//createApp(App).mount('#app')\n\nlet app = createApp(App)\n\n// 全局注册组件\napp.component('MLogin', LoginVue)\n\napp.mount('#app')\n```\n\n\n\n#### 7.1.2 局部注册\n\n+ 局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用\n+ 在选项式API中，我们可以使用`components` 选项来局部注加组件。\n\n```vue\n<script >\nimport LoginVue from './components/Login.vue'\n\nexport default {\n    //注册组件选项\n    components: { LoginVue }\n}\n</script>\n\n<template><!-- 使用注册的组件 -->\n    <LoginVue />\n</template>\n```\n\n+ 在组合式API中的`<script setup>`内，直按导入的组件就可以在模板中直接可用，无需注册。\n\n```vue\n<script setup>\nimport LoginVue from './components/Login.vue'\n</script>\n\n<template>\n    <br>\n    <!-- 使用注册的组件 -->\n    <LoginVue />\n</template>\n```\n\n### 7.2 传递数据（父->子）\n\n+ 如果父组件向子组件进行传递数据，那么我们需要在子组件中声明`props`来接收传递数据的属性，可采用**字符串数组式或对象式**来声明`props`。\n+ 父组件向子组件传递数据，在使用组件的标签上采用属性方式传递的`props` 值，**可使用`v-bind: `或`:`来绑定尾性**。\n+ 组件中`props` 中的数据是**只读**的，不可直接更改，只能通过父组件进行更改。\n\n> **声明与使用**\n>\n> 1. 在选项式API中\n>    + 我们可以提供`props` 选项来声明接收传递的数据\n>    + 在JS中可使用`this.$props` 来访问声明的自定义的属性\n>    + 在视图模板中，可直接访问`props`中声明的自定义属性\n> 2. 在组合式API中\n>    + 我们可以采用`defineProps` 宏来声明接收传递的数据\n>    + 在JS中可使用`defineProps` 返回的对象来访问声明的自定义的属性\n>    + 在视图模板中，可直接访问`defineProps` 中声明的自定义属性\n\n```vue\n<script setup>\n// defineProps声明接收父组件传递的属性值：自定义属性\n    // 数据形式：数组\nlet propsData = defineProps(['title', 'error', 'flat'])\n\n// 在JS中可使用`defineProps` 返回的对象来访问声明的自定义的属性\nfunction showPropsData() {\n    console.log(propsData)\n}\n\n// 错误，props数据只读，不能直接修改\nfunction changeErrorProps() {\n    propsData.error = !propsData.error\n}\n</script>\n\n<template>\n    <br>\n    <!-- 在视图模板上，可直接使用props中的属性 -->\n    <button :class=\"{ error, flat }\" @click=\"showPropsData\">\n        {{ title }}\n    </button>\n</template>\n\n\n<style>\nbutton {\n    border: none;\n    padding: 12px 25px;\n}\n\n.error {\n    background-color: rgb(197, 75, 75);\n    color: white;\n}\n\n.flat {\n    box-shadow: 0 0 10px grey;\n}\n</style>\n```\n\n![image-20230222172801147](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340799.png)\n\n![image-20230222173124465](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340800.png)\n\n![image-20230222173148948](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340801.png)\n\n### 7.3 传递数据（子->父）\n\n有的时候，父组件在使用子组件时，子组件如何给父组件传值呢?\n\n1. 子组件声明自定义的事件\n2. 子组件中触发自定义事件(可传值)\n3. 父组件使用子组件时监听对应的自定义事件，并执行父组件中的函数: (获取子组件传递的值)。\n\n#### 7.3.1 【子组件】声明组件事件\n\n1. 在选项式API中，子组件可通过`emits`选项来声明自定义的事件\n\n   + 字符串数组式声明简单的自定义事件\n\n   ```vue\n   <!--App.vue-->\n   <script>\n   import StudentVue from './components/Student.vue';\n   \n   export default {\n       components: { StudentVue },\n       data: () => ({\n           student: {\n               name: 'Jack',\n               age: 18,\n               sex: '男'\n           }\n       }),\n       methods: {\n           getNewAge(newAge) {\n               console.log('年龄新值：' + newAge)\n               this.student.age = newAge\n           },\n           getNewAgeAndName(newAge, newName) {\n               this.student.age = newAge\n               this.student.name = newName\n           },\n           getNewStudent(stu) {\n               this.student.age = stu.age\n               this.student.name = stu.name\n               this.student.sex = stu.sex\n           }\n       }\n   }\n   \n   </script>\n   \n   <template>\n       <br>\n       {{ student }}\n       <hr>\n       <StudentVue @change-age=\"getNewAge\" @change-age-and-name=\"getNewAgeAndName\" @change-student=\"getNewStudent\" />\n   </template>\n   \n   <!--Button.vue-->\n   <script>\n   export default {\n       emits: ['changeAge', 'changeAgeAndName', 'changeStudent'],\n       methods: {\n           emitsEventAge() {\n               //选项式通过'this.$emit'触发自定义事件\n               this.$emit('changeAge', 30)\n           }\n       }\n   }\n   </script>\n   \n   <template>\n       <button @click=\"emitsEventAge\">更改年龄</button>\n       <br>\n       <button @click=\"$emit('changeAgeAndName', 10, 'Annie')\">更改年龄和名字</button>\n       <br>\n       <button @click=\"$emit('changeStudent', { age: 10, name: 'Annie', sex: '女' })\">更改学生</button>\n   </template>\n   ```\n\n   + 对象式声明自定义事件\n\n   ```vue\n   <script>\n   export default {\n       emits: {\n           changeAge: null,\n           changeAgeAndName: null,\n           changeStudent: stu => {\n               if (stu.age <= 0) {\n                   //验证失败，会有警告语句\n                   return false\n               }\n               return true\n           }\n       },\n       methods: {\n           emitsEventAge() {\n               //选项式通过'this.$emit'触发自定义事件\n               this.$emit('changeAge', 30)\n           }\n       }\n   }\n   </script>\n   \n   <template>\n       <button @click=\"emitsEventAge\">更改年龄</button>\n       <br>\n       <button @click=\"$emit('changeAgeAndName', 10, 'Annie')\">更改年龄和名字</button>\n       <br>\n       <button @click=\"$emit('changeStudent', { age: 10, name: 'Annie', sex: '女' })\">更改学生（验证通过）</button>\n       <br>\n       <br>\n       <button @click=\"$emit('changeStudent', { age: -10, name: 'asdf', sex: '女' })\">更改学生（验证失败）</button>\n   </template>\n   ```\n\n2. 在组合式API中，子组件可通过`defineEmits()`宏来声明自定义的事件\n\n#### 7.3.2 【子组件】触发组件事件\n\n+ 选项式API：通过`this.$emit`触发自定义事件\n+ 组合式API：调用`defineEmit()`返回的`emit(event,...args)`函数来触发自定义事件\n\n#### 7.3.3【父组件】监听子组件自定义事件\n\n### 7.4 透传属性和事件\n\n+ 父组件在使用子组件的时候，如何\"透传属性和事件”给子组件呢?\n  1. 透传属性和事件并没有在子组件中用`props` 和`emits` 声明\n  2. 透传属性和事件最常见的如`@click`和`class` 、`id` 、`style`。\n  3. 当子组件**只有一个根元素**时，透传属性和事件会自动添加到该根元素上：如果根元素已有`class` 或`style`属性，它会自动合并。\n\n```vue\n<script setup>\n\nimport ChipVue from './components/Chip.vue'\n</script>\n\n<template>\n    <br>\n    <!-- 透传的属性（style，class，title),在子组件中并没有在props声明 -->\n    <!-- 透传的事件（@click），没有在emit声明 -->\n    <ChipVue style=\"border: 1px solid blue;\" />\n</template>\n```\n\n+ 禁止“透传属性和事件”\n\n![image-20230223152108697](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340802.png)\n\n+ 多根元素的“透传属性和事件”\n  + 多根节点的组件并没有自动“透传属性和事件”的行为。\n  + 由于Vue不确定要将“透传属性和事件”透传到哪里，所以我们需要`v-bind=\"$attrs \"`来显式绑定，否则将会抛出一个运行时警告。\n+ 访问“透传属性和事件”\n  1. 在选项式API中，我们可通过`this.$attrs`束访问\"透传属性和事件”。\n  2. 在组合式API中的`<script setup>` 中引入`useAttrs()`来访问一个组件的“透传属性和事件”。\n\n### 7.5 插槽\n\n+ `<slot>`\n+ 具名插槽\n\n```vue\n<!--App.vue-->\n<script setup>\n\nimport CardVue from './components/Card.vue'\n\n</script>\n\n<template>\n    <br>\n    <CardVue>\n        <!-- 向具名插槽提供内容 -->\n        <template v-slot:cardTitle>博客</template>\n        <template #cardSubTitle>副标题</template>\n\n        <template #cardContent=\"dataProps\">\n            <ul>\n                <li>标题：{{ dataProps.cardBlog.title }}</li>\n                <li>时间：{{ dataProps.cardBlog.time }}</li>\n                <li>作者：{{ dataProps.cardAuthor }}</li>\n            </ul>\n        </template>\n\n        <!-- 给子组件提供内容 -->\n        <template #default>\n            <button>我是子组件按钮</button>\n        </template>\n\n    </CardVue>\n</template>\n\n<!--Card.vue-->\n<script setup>\nimport { reactive, ref } from 'vue';\n\nlet blog = reactive({\n    title: 'Java上传文件',\n    time: '2021-12-25 15:33:25'\n})\n\nlet author = ref('阿呆')\n</script>\n<template>\n    <div class=\"card\">\n        <h2 class=\"title\">\n            <!-- 带有name属性的插槽：具名插槽 -->\n            <slot name=\"cardTitle\">卡片功能区</slot>\n        </h2>\n        <div class=\"subtitle\">\n            <slot name=\"cardSubTitle\">卡片功能区</slot>\n        </div>\n        <div class=\"content\">\n            <!-- 带有数据的插槽称为：作用域插槽 -->\n            <!-- <slot>插槽上的name,是一个Vue特别保留的属性,不会在作用域插槽中访问到 -->\n            <slot name=\"cardContent\" :cardBlog=\"blog\" :cardAuthor=\"author\"></slot>\n        </div>\n        <div class=\"action\">\n            <!-- 定义一个插槽 -->\n            <!-- 插槽的默认内容，当父组件未提供任何内容时才会显示 -->\n            <!-- 没有name属性的插槽称为默认插槽，隐含名字：default -->\n            <slot>卡片功能区</slot>\n        </div>\n    </div>\n</template>\n\n<style>\n.card {\n    widows: 250px;\n    border: 1px solid black;\n}\n\n.card h2,\n.card div {\n    margin: 10px;\n    padding: 5px;\n}\n\n.title {\n    border: 1px solid red;\n}\n\n.subtitle {\n    border: 1px solid green;\n}\n\n.content {\n    border: 1px solid blue;\n}\n\n.action {\n    border: 1px solid pink;\n}\n</style>\n```\n\n### 7.6 单文件组件`CSS`功能\n\n#### 7.6.1 组件作用域`scoped`\n\n+ `scoped`属性，让下方的选择器的样式**只作用在该组件上，或者子组件的根元素**上。\n+ 该css选择器都会自动添加固定的属性选择器（`data-v-...`）\n\n#### 7.6.2 深度选择器：`:deep()`\n\n```vue\n<!-- scoped属性，让下方的选择器的样式只作用在该组件上，或者子组件的根元素上-->\n<style scoped>\nh3 {\n    border: 1px solid blue;\n}\n.error {\n    border: 1px solid red;\n    padding: 15px;\n}\n/* 如果想让style scoped中让样式作用到子组件上，使用:deep()伪类选择器 */\n.error :deep(button) {\n    border: 2px solid green;\n    padding: 8px 15px;\n}\n</style>\n```\n\n#### 7.6.3 `CSS`中的`v-bind()`\n\n```vue\n<script setup>\nimport { reactive } from 'vue';\n\nlet btnTheme = reactive({\n    backColor: '#000000',\n    textColor: '#FFFFFF'\n})\n\n</script>\n\n<template>\n    <button>普通按钮</button>\n    <hr>\n\n    背景色：<input type=\"color\" v-model=\"btnTheme.backColor\">\n    文本色：<input type=\"color\" v-model=\"btnTheme.textColor\">\n</template>\n\n<style scoped>\nbutton {\n    /* 使用v-bind()可以使用该组件中的数据源，并且响应式更新 */\n    /* 需要单引号包裹起来 */\n    background-color: v-bind('btnTheme.backColor');\n    color: v-bind('btnTheme.textColor');\n}\n</style>\n```\n\n### 7.7 依赖注入\n\n> App.vue -> Footer.vue -> DeepChild.vue\n\n<img src=\"https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340803.png\" />\n\n+ 应用层可以为所有组件提供数据（`main.js`）\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n// import './assets/main.css'\n\n//createApp(App).mount('#app')\n\nlet app = createApp(App)\n\napp.mount('#app')\n\n// 应用层为所有组件提供数据\napp.message('message', 'Hello!')\n```\n\n\n\n+ 组合式API中，祖先组件使用`provide()`函数提供数据，孩子组件使用`inject()`函数的返回值来注入祖先组件提供的数据。\n\n```vue\n<!--App.vue-->\n<script setup>\n\nimport { provide, ref } from 'vue';\nimport FooterVue from './components/Footer.vue'\n\nlet app_message = ref('星期五')\n// 提供响应式的数据，自动和注入方保持响应式链接\nprovide('app_message', app_message)\n\n</script>\n\n<template>\n    <div class=\"area\" style=\"background-color: red;\">\n        <h3>这是 APP组件 </h3>\n        <input type=\"text\" v-model=\"app_message\">\n        <FooterVue />\n    </div>\n</template>\n\n<style>\n.area {\n    padding: 15px;\n}\n</style>\n\n<!--DeepChild.vue-->\n<script setup>\nimport { inject } from 'vue';\n\nconst message = inject('message')//应用层提供的数据\nconst app_message = inject('app_message')//祖先组件提供的数据\nconst content = inject('content', '默认数据')\n</script>\n\n\n<template>\n    <div class=\"area\" style=\"background-color: pink;\">\n        <h3>这是 DeepChild 组件</h3>\n        <ul>\n            <li>应用层提供的数据：{{ message }}</li>\n            <li>APP组件提供的数据：{{ app_message }}</li>\n            <input type=\"text\" v-model=\"app_message\">\n            <li>祖先组件未提供数据：{{ content }}</li>\n        </ul>\n    </div>\n</template>\n```\n\n## 8 生命周期\n\n![在这里插入图片描述](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340804.png)\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340805.png)\n\n### 8.1 选项式API\n\n1. `APP.vue`\n\n```vue\n<script>\n\nimport SonVue from './components/Son.vue'\n\nexport default {\n    components: { SonVue },\n    data: () => ({\n        isShow: false\n    })\n\n}\n</script>\n\n<template>\n    <h3>APP组件</h3>\n    <input type=\"checkbox\" v-model=\"isShow\">是否显示子组件\n    <hr>\n    <SonVue subtitle=\"这是一个副标题\" v-if=\"isShow\" />\n</template>\n```\n\n2. `Son.vue`\n\n```vue\n<script>\n\nexport default {\n    props: ['subtitle'],\n    data: () => ({\n        age: 30\n    }),\n    methods: {\n        showMessage() {\n            console.log('函数Hello');\n        }\n    },\n    // 组件实例化之前\n    // 能访问props的数据\n    // 不能访问组件的实例this中的数据源和函数\n    // 不能访问组件中的视图DOM元素\n\n    beforeCreate() {\n        console.log('beforeCreate 组件实例化之前');\n        console.log(this.$props.subtitle);\n        // console.log(this.age)\n        // this.showMessage()\n        // console.log(document.getElementById('title').innerHTML);\n    },\n    // 组件实例化之后\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 不能访问组件中的视图DOM元素\n    created() {\n        console.log('created 组件实例化之后');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        // console.log(document.getElementById('title').innerHTML);\n    },\n    // 组件视图渲染之前\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 不能访问组件中的视图DOM元素\n    beforeMount() {\n        console.log('beforeMount 组件视图渲染之前');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        // console.log(document.getElementById('title').innerHTML);\n    },\n    // 组件视图渲染之后\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 能访问组件中的视图DOM元素\n    mounted() {\n        console.log('mounted 组件视图渲染之前');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        console.log(document.getElementById('title').innerHTML);\n    },\n    // 数据源发生改变，视图重新渲染之前\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 能访问重新渲染的DOM元素之前的状态\n    beforeUpdate() {\n        console.log('beforeUpdate 数据源发生改变，视图重新渲染之前');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        console.log(document.getElementById('title').innerHTML);\n    },\n    // 数据源发生改变，视图重新渲染之后\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 能访问重新渲染的DOM元素之后的状态\n    updated() {\n        console.log('updated 数据源发生改变，视图重新渲染之后');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        console.log(document.getElementById('title').innerHTML);\n    },\n    // 组件卸载之前\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 能访问组件中的视图DOM元素\n    beforeUnmount() {\n        console.log('beforeUnmount 组件卸载之前');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        console.log(document.getElementById('title').innerHTML);\n    },\n    // 组件已卸载\n    // 能访问自定义属性\n    // 能访问组件的实例this中的数据源和函数\n    // 不能访问组件中的视图DOM元素\n    unmounted() {\n        console.log('unmounted 组件已卸载');\n        console.log(this.$props.subtitle);\n        console.log(this.age)\n        this.showMessage()\n        // console.log(document.getElementById('title').innerHTML);\n    },\n}\n</script>\n\n\n<template>\n    <h3 id=\"title\">\n        <i>年龄：{{ age }}</i>\n    </h3>\n\n    <button @click=\"(age = 70)\">年龄改为70</button>\n    <button @click=\"(age = 30)\">年龄改为30</button>\n    <hr>\n</template>\n```\n\n### 8.2 组合式API\n\n+ 因为 `setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 `setup` 函数中编写。\n\n| 选项式钩子      | 组合式钩子        |\n| --------------- | ----------------- |\n| `beforeCreate`  | 无                |\n| `created`       | 无                |\n| `beforeMount`   | `onBeforeMount`   |\n| `mounted`       | `onMounted`       |\n| `beforeUpdate`  | `onBeforeUpdate`  |\n| `updated`       | `onUpdated`       |\n| `beforeUmmount` | `onBeforeUnmount` |\n| `unmounted`     | `onUnmounted`     |\n\n## 9 模板引用\n\n### 9.1 访问模板引用\n\n+ `ref`\n\n1. 在视图元素中采用`ref`属性来设置需要访问的DOM元素\n\n   a. 该`ref`属性可采用字符值的执行设置\n   b. 该`ref`属性可采用`v-bind: `或`:ref`的形式来绑定函数，其函数的第一个参数则为该元素\n\n2. 如果元素的`ref`属性值采用的是字符串形式\n   a. 在选项式API JS中，可通过`this. $refs`来访问模板引用\n   b. 在组合式API JS中，我们需要声明一个同名的`ref`变量，来获得该模板的引用\n\n### 9.2 `v-for`中的模板引用\n\n> 注意：需要v3.2.25及以上版本\n\n当在v- for中使用模板弓|用时:\n\n1. 如果`ref`值是字符串形式，在元素被渲染后包含对应整个列表的所有元素[数组]。\n2. 如果`ref`值是函数形式，则会每道染一个列表元素则会执行对应的函数[不推荐使用]。\n\n![image-20230227183307056](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340806.png)\n\n### 9.3 组件上的`ref`\n\n模板引用也可以被用在一个子组件 上；这种情况下引用中获得的值是**组件实例**：\n\n1. 如果子组件使用的是选项式API ,默认情况下父组件可以随意访问该子组件的数据和函数，除非在子组件使用`expose` 选项来暴露特定的数据或函数\n2. 如果子组件使用的是组合式API `<script setup> `， 那么该子组件默认是私有的，则父组件无法访问该子组件，除非子组件在其中通过`defineExpose` 宏显式暴露特定的数据或函数。\n\n## 10 路由 `Vue Router`\n\n1. `vue-router`是`vue.js`官方给出的路由解决方案，能够轻松的管理`SPA`项目中组件的切换。\n2. 安装：`npm install vue-router@4`\n\n### 10.1 快速使用\n\n#### 10.1.1 创建路由模块\n\n1. 在项目中的src文件夹中创建一个router 文件夹，在其中创建`index.js` 模块\n\n2. 采用`createRouter()`创建路由，并暴露出去\n\n   ```js\n   import { createRouter } from \"vue-router\";\n   \n   // 创建路由对象\n   const router = createRouter({})\n   \n   // 将路由对象暴露出去\n   export default router\n   ```\n\n3. 在`main.js`文件中初始化路由模块`app. use(router)`。\n\n   ```js\n   import { createApp } from 'vue'\n   import App from './App.vue'\n   // 引入路由模块\n   import router from './router'\n   \n   \n   let app = createApp(App)\n   \n   // 初始化路由模块\n   app.use(router)\n   \n   app.mount('#app')\n   ```\n\n#### 10.1.2 规定路由模式\n\n1. `createWebHashHistory`：Hash模式\n2. `createWebHistory`：html模式\n\n![image-20230227191302919](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340807.png)\n\n#### 10.1.3 使用路由规则\n\n`routes`路由规则：\n\n+ `path`：路由分配的`url`\n+ `name`：当路由指向此页面时显示的名字\n+ `component`：路由调用这个页面时加载的组件\n\n`index.js`\n\n```js\nimport { createRouter, createWebHistory } from \"vue-router\";\nimport BlogHomeView from '@/views/BlogHomeView.vue'\n// 路由规则\nconst routes = [\n    {\n        path: '/home',//路由地址\n        name: 'home', //路由名称\n        component: () => import('@/views/HomeVieW.vue')//切换路由地址展示的组件\n    },\n    {\n        path: '/blog',\n        name: 'blog',\n        component: BlogHomeView\n    }\n]\n\n// 创建路由对象\nconst router = createRouter({\n    history: createWebHistory(), //使用history模式路由\n    routes\n})\n\n// 将路由对象暴露出去\nexport default router\n```\n\n#### 10.1.4 声明路由链接和占位符\n\n+ `<router-link>`：路由链接，`to`属性则为点击此元素，需要切换的路由地址。\n+ `<router-view>`：路由占位符，路由切换的视图展示的位置。\n\n`APP.vue`\n\n```vue\n<template>\n    <router-link to=\"/\">重定向到首页</router-link>\n    <router-link to=\"/home\">首页</router-link>\n    <router-link to=\"/blog\">博客</router-link>\n\n    <hr>\n    <!-- 路由视图占位符（切换路由时，要展示的组件的地方） -->\n    <router-view />\n</template>\n```\n\n\n\n### 10.2 重定向路由\n\n+ `redirect`\n\n![image-20230227193558172](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340808.png)\n\n### 10.3 嵌套路由\n\n嵌套路由规则\n\n1. 在某一个路由规则中采用`children`来声明嵌套路由的规则\n2. 嵌套路由规则中的`path`不能以`/`开头,访问需使用`/father/son` 的形式\n\n![image-20230227195915096](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340809.png)\n\n![image-20230227195934756](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340810.png)\n\n### 10.4 路径参数\n\n+ 语法：`path:'/url/:param'`\n+ 在展示的组件中访问路径参数\n\n![image-20230227201140784](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340811.png)\n\n`BlogContentView.vue`\n\n```vue\n<script setup>\nimport { useRoute } from 'vue-router';\n\nconst propsData = defineProps(['id'])\nconst routeObj = useRoute()\n\n</script>\n\n<template>\n    <div class=\"content\">\n        博客详情界面\n        <ul>\n            <li>{{ routeObj.params }}</li>\n            <li>{{ routeObj.params.id }}</li>\n            <li>{{ propsData.id }}</li>\n        </ul>\n    </div>\n</template>\n```\n\n![image-20230227202236814](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340812.png)\n\n### 10.5 声明式和编程式导航\n\n+ 导航到不同的位置\n\n![image-20230227202351905](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340813.png)\n\n+ 替换当前位置\n\n![image-20230227203231714](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340814.png)\n\n+ 路由历史\n\n![image-20230227203955271](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340815.png)\n\n### 10.6 导航守卫\n\n### 10.6.1 全局前置守卫\n\n![image-20230228140650241](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340816.png)\n\n`index.js`\n\n```js\nimport { createRouter, createWebHistory } from \"vue-router\";\nimport HomeView from '@/views/HomeView.vue'\nimport BlogHomeView from '@/views/BlogHomeView.vue'\nimport LoginView from '@/views/LoginView.vue'\nimport MainHomeView from '@/views/admin/MainHomeView.vue'\nimport UserManagerView from '@/views/admin/UserManagerView.vue'\n\n// 路由规则\nconst routes = [\n    {\n        path: '/home',//路由地址\n        name: 'home', //路由名称\n        component: HomeView\n    },\n    {\n        path: '/blog',\n        name: 'blog',\n        component: BlogHomeView\n    },\n    {\n        path: '/login',\n        name: 'login',\n        component: LoginView\n    },\n    {\n        path: '/admin/main',\n        name: 'admin-main',\n        meta: { isLogin: true },  // 自定义meta属性\n        component: MainHomeView\n    },\n    {\n        path: '/admin/user',\n        name: 'admin-user',\n        meta: { isLogin: true },\n        component: UserManagerView\n    }\n\n]\n\n// 创建路由对象\nconst router = createRouter({\n    history: createWebHistory(), //使用history模式路由\n    routes\n})\n\n// 注册全局前置守卫\n// to: 将要访问的路由信息对象\n// from: 将要离开的路由信息对象\n// next:  \nrouter.beforeEach((to, from, next) => {\n    // 判断将要访问的路由信息对象是否需要登录\n    if (to.meta.isLogin) {\n        let userLogin = localStorage.getItem('loginUser')\n        // 判断用户是否已经登录了\n        if (userLogin == null) {\n            //未登录，跳转至登录页\n            return next({ path: '/login' })\n        }\n    }\n    return next()\n})\n\n// 将路由对象暴露出去\nexport default router\n```\n\n`LoginView.vue`\n\n```vue\n<script setup>\nimport { reactive } from 'vue';\n\nlet user = reactive({\n    account: '',\n    password: ''\n})\n\nfunction toLogin() {\n    localStorage.setItem('loginUser', JSON.stringify(user))\n    alert('登陆成功')\n}\n\nfunction loginSingout() {\n    localStorage.removeItem('loginUser')\n    alert('注销成功')\n}\nfunction isLogined() {\n    let userLogin = localStorage.getItem('loginUser')\n    console.log(userLogin);\n}\n\n</script>\n\n<template>\n    <div class=\"login\">\n        登录界面\n        <hr>\n        账号：<input type=\"text\" v-model=\"user.account\"><br>\n        密码：<input type=\"password\" v-model=\"user.password\"><br>\n        <button @click=\"toLogin\">登录</button>|\n        <button @click=\"loginSingout\">注销</button>|\n        <button @click=\"isLogined\">查看是否已经登录</button>|\n    </div>\n</template>\n\n<style scoped>\n.login {\n    background-color: orange;\n    padding: 50px;\n}\n</style>\n```\n\n### 10.6.2 其他守卫\n\n导航守卫可分为：全局前置守卫、全局解析守卫、全局后置守卫、路由独享的守卫、组件内的守卫。\n\n## 11 状态管理库`Pinia`\n\n> `Pinia`是`Vue`的专属状态管理库，它允许你跨组件或页面共享状态。\n\n### 11.1 安装和使用`Pinia`\n\n1. 安装：`npm install pinia`\n2. 使用 `main.js`\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n// 引入createPinia函数\nimport { createPinia } from 'pinia'\n\nlet app = createApp(App)\n\n// 创建pinia(根存储)，并且应用到整个应用中。\napp.use(createPinia())\n\napp.mount('#app')\n```\n\n### 11.2 `store`\n\n![image-20230228144830288](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340817.png)\n\n### 11.3 `state`\n\n#### 11.3.1 选项式\n\n![image-20230228145009745](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340818.png)\n\n`useUserStore.js`\n\n```js\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n    // 共享的数据\n    state: () => ({\n        age: 27,\n        level: 5,\n        account: 'SD78556',\n        nickname: '阿达'\n    }),\n})\n```\n\n`App.vue`\n\n```vue\n<script>\nimport { mapState, mapStores, mapWritableState } from 'pinia';\nimport { useUserStore } from './store/useUserStore';\n\nexport default {\n    computed: {\n        // mapState 将store的state映射成当前组件的计算属性\n        // 具有响应式，但是是只读\n        // 字符串数组形式：不能自定义计算属性名\n        // 对象形式：可以自定义计算属性名\n        ...mapState(useUserStore, ['age', 'level']),\n        ...mapState(useUserStore, {\n            user_account: 'account',\n            user_nickname: 'nickname'\n        }),\n\n        ...mapWritableState(useUserStore, ['account', 'nickname'])\n    }\n}\n\n</script>\n\n\n<template>\n    <h2>mapState 映射的计算属性</h2>\n    <ul>\n        <li>{{ age }}</li>\n        <li>{{ level }}</li>\n        <li>{{ user_account }}</li>\n        <li>{{ user_nickname }}</li>\n    </ul>\n\n    <h2>mapWritableState 映射的计算属性</h2>\n    <ul>\n        <li>{{ account }}</li>\n        <li>{{ nickname }}</li>\n    </ul>\n\n    <button @click=\"nickname += '='\">更改昵称</button>\n</template>\n\n```\n\n#### 11.3.2 组合式\n\n![image-20230228152216904](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340819.png)\n\n`useUserStore.js`\n\n```js\nimport { defineStore } from 'pinia'\nimport { ref } from 'vue'\n\nexport const useUserStore = defineStore('user', () => {\n    const age = ref(20)\n    const level = ref(5)\n    const account = ref('SD54646')\n    const nickname = ref('阿达')\n\n    return { age, level, account, nickname } //把变量共享出去\n})\n```\n\n`App.vue`\n\n```vue\n<script setup>\nimport { useUserStore } from '@/store/useUserStore';\nimport { storeToRefs } from 'pinia';\nimport { computed } from 'vue';\n\n// 获取 useUserStore实例\nconst user_store = useUserStore()\n\n// 通过 computed() 将 store 中 state 映射成当前组件中的计算属性，但是是只读的\nconst user_age = computed(() => user_store.age)\n\n// storeToRefs 将 store 中 state 解构成组件中的数据，具有响应式，可以响应式修改\nconst { age, level, account, nickname } = storeToRefs(user_store)\n</script>\n\n\n<template>\n    <h2>从store 直接取state</h2>\n    <ul>\n        <li>{{ user_store.age }}</li>\n        <li>{{ user_store.level }}</li>\n        <li>{{ user_store.account }}</li>\n        <li>{{ user_store.nickname }}</li>\n    </ul>\n    <button @click=\"user_store.nickname += '='\">更改昵称</button>\n\n    <hr>\n    <h2>computed 映射为计算属性</h2>\n    <ul>\n        <li>{{ user_age }}</li>\n    </ul>\n\n    <hr>\n    <h2>storeToRefs 解构成自己的数据</h2>\n    <ul>\n        <li>{{ age }}</li>\n        <li>{{ level }}</li>\n        <li>{{ account }}</li>\n        <li>{{ nickname }}</li>\n\n    </ul>\n    <button @click=\"age += 10\">更改年龄</button>\n</template>\n```\n\n### 11.4 `getters`\n\n#### 11.4.1 选项式\n\n`useUserStore.js`\n\n```js\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n    state: () => ({\n        birthday: '1992-12-27',\n        age: 31\n    }),\n    // 通过计算得到的新的共享数据：只读\n    // 如果依赖的数据发生变化，则会重新计算\n    getters: {\n        month() {\n            return this.birthday.split('-')[1]\n        },\n        // 参数1为store实例\n        ageStage: store => {\n            if (store.age < 18) return '未成年'\n            if (store.age < 35) return '青年'\n            if (store.age < 50) return '中年'\n            if (store.age >= 50) return '老年'\n        }\n    }\n})\n```\n\n`App.vue`\n\n```vue\n<script >\nimport { mapState, mapWritableState } from 'pinia';\nimport { useUserStore } from '@/store/useUserStore';\n\nexport default {\n    computed: {\n        //从store 取getters 和取state 用法相同，都可以使用mapState\n        //具有响应式，只读\n        ...mapState(useUserStore, ['month']),\n        ...mapState(useUserStore, {\n            age_stage: 'ageStage'\n        }),\n        //从store 取getters 和取state 用法相同，都可以使用mapWritableState\n        //具有响应式，只读\n        ...mapWritableState(useUserStore, ['ageStage']),\n        ...mapWritableState(useUserStore, {\n            bir_month: 'month'\n        })\n    }\n}\n</script>\n\n\n<template>\n    <h2>mapState 将getters映射为自己的计算属性</h2>\n    <ul>\n        <li>{{ month }}</li>\n        <li>{{ age_stage }}</li>\n    </ul>\n    <button @click=\"month += 10\">更改月份</button>\n\n    <hr>\n    <h2>mapWritableState 将getters映射为自己的计算属性</h2>\n    <ul>\n        <li>{{ bir_month }}</li>\n        <li>{{ ageStage }}</li>\n    </ul>\n    <button @click=\"bir_month += 10\">更改月份</button>\n</template>\n```\n\n#### 11.4.2 组合式\n\n![image-20230228160223968](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340820.png)\n\n`useUserStore.js`\n\n```js\nimport { defineStore } from 'pinia'\nimport { computed, ref } from 'vue'\n\nexport const useUserStore = defineStore('user', () => {\n    const birthday = ref('1992-12-27')\n    const age = ref(31)\n\n    // 通过 computed 函数声明通过计算得到的共享的数据\n    // 如果依赖的数据发生改变，则会重新计算\n    const month = computed(() => {\n        return birthday.value.split('-')[1]\n    })\n    const ageStage = computed(() => {\n        if (age.value < 18) return '未成年'\n        if (age.value < 35) return '青年'\n        if (age.value < 50) return '中年'\n        if (age.value >= 50) return '老年'\n    })\n\n    return { birthday, age, month, ageStage }\n})\n```\n\n`App.vue`\n\n```vue\n<script setup>\nimport { useUserStore } from '@/store/useUserStore';\nimport { storeToRefs } from 'pinia';\nimport { computed } from 'vue';\n\n// 获取 store 实例，可直接访问 getters，只读\nconst user_store = useUserStore()\n\n// 通过 computed 函数将 getters 映射为自己的计算属性\n// 具有响应式，只读\nconst bir_month = computed(() => user_store.month)\nconst age_stage = computed(() => user_store.ageStage)\n\n// 通过 storeToRefs 函数将 getters 解构为自己的计算属性\n// 具有响应式，只读\nconst { month, ageStage: userAgeStage } = storeToRefs(user_store)\n</script>\n\n<template>\n    <h2>通过 store 直接获取 getters</h2>\n    <ul>\n        <li>{{ user_store.month }}</li>\n        <li>{{ user_store.ageStage }}</li>\n    </ul>\n    <button @click=\"user_store.month += 10\">更改月份</button>\n\n    <hr>\n    <h2>通过 computed 函数将 getters 映射为自己的计算属性</h2>\n    <ul>\n        <li>{{ bir_month }}</li>\n        <li>{{ age_stage }}</li>\n    </ul>\n    <button @click=\"bir_month += 10\">更改月份</button>\n\n    <hr>\n    <h2>通过 storeToRefs 函数将 getters 解构为自己的计算属性</h2>\n    <ul>\n        <li>{{ month }}</li>\n        <li>{{ userAgeStage }}</li>\n    </ul>\n    <button @click=\"month += 10\">更改月份</button>\n</template>\n```\n\n### 11.5 `actions`\n\n> `actions`一般是对`state`中的数据进行修改的业务逻辑函数\n\n![image-20230228162609022](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340821.png)\n\n![image-20230228163146992](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340822.png)\n\n组合式示例\n\n`useUserStore.js`\n\n```js\nimport { defineStore } from 'pinia'\nimport { ref } from 'vue'\n\nexport const useUserStore = defineStore('user', () => {\n    const nickname = ref('阿达')\n    const age = ref(20)\n\n    // 声明函数，并且 return 出去即可\n    function setUserInfo(user_nickname, user_age) {\n        nickname.value = user_nickname\n        age.value = user_age\n    }\n\n    function setUserInfoByObject(user) {\n        nickname.value = user.nickname\n        age.value = user.age\n    }\n\n    return { nickname, age, setUserInfo, setUserInfoByObject }\n})\n```\n\n`App.vue`\n\n```vue\n<script setup>\nimport { useUserStore } from '@/store/useUserStore';\nimport { storeToRefs } from 'pinia';\n\n// 获取 store 实例\nconst user_store = useUserStore()\n\nconst { nickname, age } = storeToRefs(user_store)\n\n// 将 store 中的 actions 解构成自己的函数（可自定义函数名），不使用storeToRefs\nconst { setUserInfo, setUserInfoByObject: set_user_info_object } = user_store\n\n</script>\n\n\n<template>\n    <ul>\n        <li>{{ nickname }}</li>\n        <li>{{ age }}</li>\n    </ul>\n    <hr>\n    <span>通过 store 直接调用 actions</span>\n    <br>\n    <button @click=\"user_store.setUserInfo('Jack', 30)\">改变用户信息</button>|\n    <button @click=\"user_store.setUserInfoByObject({ nickname: 'Tom', age: 40 })\">改变用户信息</button>\n\n    <hr>\n    <span>将 store 中的 actions 解构成自己的函数</span>\n    <br>\n    <button @click=\"setUserInfo('Jack', 30)\">改变用户信息</button>|\n    <button @click=\"set_user_info_object({ nickname: 'Tom', age: 40 })\">改变用户信息</button>\n</template>\n\n```\n\n## 12 请求库 `Axios`\n\n> + `Axios`是一个基于`promise`网络请求库，作用于`node. js`和浏览器中。\n> + `Axios`在服务端它使用原生`node.js` `http` 模块，而在客户端(浏览端)则使用`XMLHttpRequests`。\n> + `Axios`可以拦截请求和响应、转换请求和响应数据、取消请求、自动转换 `JSON`数据。\n> + `Axios`安装方式:`npm install axios`。\n\n### 12.1 `Axios`配置项\n\n![image-20230301151022973](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340823.png)\n\n![image-20230301155823626](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340824.png)\n\n![image-20230301155944486](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340825.png)\n\n![image-20230301160022466](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340826.png)\n\n![image-20230301160044523](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303031340827.png)\n\n## 13 购物车案例\n\n1. `App.vue`\n\n```vue\n<script setup>\nimport { computed, isMemoSame, ref } from 'vue';\nimport ProductVue from './components/Product.vue'\nimport Collectvue from './components/Collect.vue'\n\n//购物车\nlet shopCar = ref([\n    {\n        id: 89,\n        title: '妈妈壹选 绿劲餐具净柚子金桔1.28kg*2实惠装 食品用 快速去油',\n        subTitle: '专业消毒99.999%，威露士消毒液5件套，立减10元，买即送价值139元京东洗衣服务（衣鞋三件任选）限时限量抢，(此商品不参加上述活动)查看>',\n        image: 'https://img13.360buyimg.com/n1/jfs/t1/26824/37/18309/308382/62f0b4f4E066881df/d7896be9c2410804.jpg',\n        price: 19,\n        count: 1,\n        selected: false\n    },\n    {\n        id: 90,\n        title: 'beats Beats Studio Buds 真无线降噪耳机 蓝牙耳机 兼容苹果安卓系统 IPX4级防水 – 白色',\n        subTitle: '【亦静亦噪】TWS运动蓝牙降噪耳机,苹果/安卓手机适用.IPX4级防水.更多精彩',\n        image: 'https://img12.360buyimg.com/n1/s450x450_jfs/t1/103497/21/35946/39394/63f2c786F3e725d90/4f009f1b0653bab7.jpg',\n        price: 749,\n        count: 2,\n        selected: false\n    },\n    {\n        id: 91,\n        title: 'SANC 电脑显示器24英寸IPS全高清75Hz 低蓝光 广视角 可壁挂LED液晶屏幕N500 3代 24英寸全高清',\n        subTitle: '升级IPS带鱼屏，办公影音生产力，性价比之选H20e点击了解点击了解',\n        image: 'https://img10.360buyimg.com/n1/s450x450_jfs/t1/42187/38/22010/77054/639c3649E1ef39f46/8e23f6f0c82db07d.jpg',\n        price: 439,\n        count: 3,\n        selected: true\n    }\n])\n\n//产品状态发生改变\nfunction changeShopCarProductChecked(checked, id) {\n    // 循环购物车中的每个产品\n    shopCar.value.some(product => {\n        //判断更改的是哪一个产品的checked状态\n        if (id === product.id) {\n            product.selected = checked\n            return true //结束循环\n        }\n    })\n}\n\n//产品数量发生改变\nfunction changeShopCarProductCount(count, id) {\n    // 循环购物车中的每个产品\n    shopCar.value.some(product => {\n        //判断更改的是哪一个产品的count\n        if (id === product.id) {\n            product.count += count\n            return true //结束循环\n        }\n    })\n}\n\n//是否全选\nlet isFullselectedProduct = computed(() => {\n    return shopCar.value.every(product => product.selected)\n})\n\n//改变购物车所有产品的选中状态\nfunction changeShopCarAllProductChecked(checked) {\n    shopCar.value.forEach(product => { product.selected = checked })\n}\n\n//总金额\nlet total = computed(() => {\n    return shopCar.value\n        .filter(item => item.selected)//过滤掉被选中的产品\n        .reduce((money, item) => (money += item.price * item.count), 0)\n})\n\n//购买数量\nlet countSum = computed(() => {\n    return shopCar.value\n        .filter(item => item.selected)\n        .reduce((count, item) => (count += item.count), 0)\n})\n\n</script>\n\n<template>\n    <br>\n    <ProductVue v-for=\"product in shopCar\" :key=\"product.id\" :id=\"product.id\" :picture=\"product.image\"\n        :title=\"product.title\" :subtitle=\"product.subTitle\" :price=\"product.price\" :count=\"product.count\"\n        :is-checked=\"product.selected\" @change-product-checked=\"changeShopCarProductChecked\"\n        @change-product-count=\"changeShopCarProductCount\" />\n    <hr>\n    <!-- 使用汇总组件 -->\n    <Collectvue :is-all-checked=\"isFullselectedProduct\" @change-all-checked-state=\"changeShopCarAllProductChecked\"\n        :all-money=\"total\" :all-count=\"countSum\" />\n</template>\n\n<style>\n* {\n    margin: 0;\n    padding: 0;\n}\n</style>\n```\n\n2. `Product.vue`\n\n```vue\n<script setup>\n//声明组件的自定义属性\nlet propsData = defineProps({\n    id: { type: Number, required: true },\n    isChecked: Boolean,\n    picture: { type: String, required: true },\n    title: { type: String, required: true },\n    subtitle: { type: String, required: true },\n    price: { type: Number, default: 0 },\n    count: { type: Number, default: 0 }\n})\n\n\n//自定义事件\nlet emits = defineEmits(['changeProductChecked', 'changeProductCount'])\n\n//改变选中状态\nfunction changeCheckedState(e) {\n    let newCheckedState = e.target.checked //复选框最新状态\n    emits('changeProductChecked', newCheckedState, propsData.id)\n}\n\n</script>\n\n<template>\n    <br>\n    <!-- 产品容器 -->\n    <div class=\"box\">\n        <!-- 选项框 -->\n        <input type=\"checkbox\" class=\"p_checkbox\" :checked=\"isChecked\" @change=\"changeCheckedState\">\n        <!-- 产品图 -->\n        <img :src=\"picture\" class=\"p_image\">\n        <!-- 产品内容 -->\n        <div class=\"p_content\">\n            <h3 class=\"p_title\" v-text=\"title\"></h3>\n            <span class=\"p_subtitle\" v-text=\"subtitle\"></span>\n            <h2 class=\"p_price\">￥{{ price }}</h2>\n            <!-- 产品数量区域 -->\n            <div class=\"p_count_area\">\n                <button :disabled=\"count <= 1\" @click=\"emits('changeProductCount', -1, id)\">-</button>\n                <span v-text=\"count\"></span>\n                <button @click=\"emits('changeProductCount', 1, id)\">+</button>\n            </div>\n        </div>\n    </div>\n</template>\n\n<style>\n.box {\n    box-shadow: 0 0 8px gray;\n    padding: 20px;\n    margin: 15px;\n    display: flex;\n    align-items: center;\n}\n\n.p_checkbox {\n    width: 25px;\n    height: 25px;\n}\n\n.p_image {\n    width: 120px;\n    height: 120px;\n    margin: 0 20px;\n}\n\n.p_content {\n    align-self: start;\n    position: relative;\n    width: 100%;\n}\n\n.p_title {\n    margin-bottom: 8px;\n}\n\n.p_subtitle {\n    font-size: 14px;\n    color: gray;\n}\n\n.p_price {\n    margin-top: 20px;\n    color: rgb(225, 58, 58);\n}\n\n.p_count_area {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n}\n\n.p_count_area button {\n    width: 25px;\n    height: 25px;\n}\n\n.p_count_area span {\n    margin: 0 10px;\n}\n</style>\n```\n\n3. `Collect.vue`\n\n```vue\n<script setup>\n\ndefineProps({\n    isAllChecked: Boolean,\n    allMoney: {\n        type: Number,\n        default: 0\n    },\n    allCount: {\n        type: Number,\n        default: 0\n    }\n})\n\n//自定义事件\nlet emits = defineEmits(['changeAllCheckedState'])\n\n</script>\n\n<template>\n    <div class=\"container\">\n        <label>\n            <input type=\"checkbox\" :checked=\"isAllChecked\" @change=\"emits('changeAllCheckedState', $event.target.checked)\">\n            全选\n        </label>\n        <span>\n            合计金额：<strong>￥{{ allMoney }}</strong>\n        </span>\n\n        <button>结算【{{ allCount }}】</button>\n    </div>\n</template>\n\n<style>\n.container {\n    padding: 20px;\n    margin: auto 15px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.container input {\n    width: 25px;\n    height: 25px;\n}\n\n.container label {\n    display: flex;\n    align-items: center;\n    width: 70px;\n    justify-content: space-between;\n}\n\n.container strong {\n    color: red;\n}\n\n.container button {\n    border: none;\n    padding: 15px 25px;\n    background-color: rgb(50, 140, 192);\n    color: white;\n    border-radius: 8px;\n    box-shadow: 0 0 5px gray;\n}\n</style>\n```\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"研究生要明确的50件事","url":"/hexo-blog/2022/12/25/研究生要明确的50件事/","content":"\n# 研究生要明确的50件事\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.12.25 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## **关于学术**\n\n1、阅读文献，始于今日。很多研究人员花一半的时间阅读文献，阅读可以很快地从别人的工作中学到很多东西。\n\n2、学习时间管理的方法，订计划，执行计划。这个习惯会让你终身受益。\n\n3、学习怎么使用Google Scholar和各类数据库，还包括各类搜索方法。\n\n4、能把自己的观点说清楚，口头+书面。\n\n5、读读那些写作高超的书，并思考作者的句法运用。你会发现不知不觉地，你已经吸收了作者的风格。要成为写作高手，需要付出颇多，历经数年，期间还要忍受和认真对待他人的批评。除此之外，并无捷径可走。\n\n6、学好英语，不学二外。如今不论去日本还是欧洲，学术交流早已是英语的天下。你不必为看不懂一篇法语的文章而遗憾，写那篇文章的人正在为没学好英语而犯愁。如果英文尚未精通，暂且不要去学二外。\n\n7、能够顺利地写出专业英语论文，基本不要翻译软件。\n\n8、进入一个领域最简单也是最有效的办法是找一本这个领域最早的论述专著或教材，不可以在网上乱搜论文。否则，你会感到，看了20篇文章，对这个领域的认识还没有形成。\n\n9、建立合理的知识结构：尽量广地涉猎学科基本知识，尽量深地了解研究领域方方面面、过去和现在。\n\n10、掌握独立研究的方法和技能：尽量多的学习各种研究方法，熟练掌握研究过程和步骤。\n\n11、学会写论文：写论文不仅是训练表达能力，更是训练思维的逻辑性。论文体例虽是八股，但却是整理思路、与他人沟通的有效结构，不可不尊重。\n\n12、无论做研究还是做工程，不要期待导师给你太多的指导，这点全世界都一样，不要抱怨，独立解决问题的能力就是这样锻炼出来的。好的导师能够在大方向上给一些意见，但具体的工作是需要自己去做的。\n\n13、尝试与不同研究组、实验室人员、不同学术领域的人交换论文，使自己成为没有联系的两个科研组交流的桥梁，很快的，你的桌子上就会冒出一大摞相关的论文。\n\n14、很多科学家都有做科研笔记的习惯，你也应该这样。\n\n15、写下自己的想法是很好的调整思路的方式。你会经常地发现自以为很完美的想法一旦写下来就显得语无伦次。\n\n## 关于成长\n\n16、争取每一个能让自己能力增强的机会（实习，比赛之类的），要努力争取实习机会，和导师好好商量。三个月的相关领域的实习会对能力的帮助很大，对找好的工作也是一个有利的筹码。\n\n17、不要鄙视成功学是为渴望“名利成功”但没思路的人准备的。《高效能人士的七个习惯》、《要事第一》、《人性的弱点》等书籍也能为你建立起积极的心态和高效的习惯。\n\n18、害怕失败会使一切变得更加困难。如果发现自己无法完成工作，问问自己是否是在逃避。这种情况没有办法避免，但要认识到失败和浪费也是研究过程的一部分。\n\n19、更加理解和疼爱父母，争取更多的时间陪他们。\n\n20、只有一条路不能选择那就是放弃的路；只有一条路不能抗拒那就是成长的路。\n\n## 关于心态\n\n21、不要因为别人而左右自己的内心。有人月薪翻番了，有人升职了，这些都跟你无关。更不能因此后悔自己读研的决定，安心读书、学术，你会收获内心的宁静。\n\n22、不要随随便便拿两个人来比，只看到他所得到的，却看不到他所失去的，这有什么意义？\n\n23、正确面对困境，用辩证的眼光去看问题。\n\n24、如果你学的专业，中国不是最好的，那么请好好学英语，请不要说什么英语教育是毒瘤之类的话。研究生毕业前，准备好一份英文简历，也要达到能够进行英语面试的能力。\n\n25、不管现在的专业是不是热门，或者多么地不堪，一旦不爱自己的专业，自甘平庸，那毕业的时候真的死定了。不管多烂的专业，先爱她，然后学好。\n\n26、扩大知识面，做好踏入社会的准备。\n\n27、对自己的职业有初步的规划和想法，有些事情自己不想，没有人替你想。\n\n28、若倾向就业，要在平衡学术的基础上增加实习经历和实践经验；若倾向继续学术，则也应考虑好是出国还是考博，并做相应的准备。\n\n29、个人心理管理就是经常的自我心态调整。知足长乐、量力而行。\n\n30、凡事都是都有它存在的理由，不要经常有抱怨。\n\n31、不要抱怨课程无聊，老师讲的不好。读到研究生，没有自学能力还不如退学。\n\n32、研究生毕业不见得能找到好工作，好工作是给能力强的人，不是给学历高的人，见到NB的本科生，也要虚心学习。\n\n33、研究生面临着比较大的生存压力，但是要平衡自己的方向，在没有生存威胁的情况下，要专注于学习。\n\n34、在校研究生100万，在我国整个人口结构中占的比例是非常低的。研究生仍然是社会的精英群体，既然是精英群体，就要有责任感和使命感。\n\n35、从来就没有太晚的时候。很多人老是说自己基础如何如何差，担心搞不定。有这种心态是很自然的，但是不要因此而否定自己的能力。\n\n## 关于社交\n\n36、努力做一个善良的人，学着改变自己，控制自己的欲望，善待你周围的人。\n\n37、有一帮不错的朋友，能够互相帮助。\n\n38、和别人讨论的时候，先理解别人的观点，学会聆听。\n\n39、别人没有义务来帮助你，不管是师兄还是同学，最可靠的人永远是自己。别人帮助你，要表示感谢，并努力帮助别人。别人不帮助你，也不要抱怨。\n\n40、学会把握与他人之间的距离。\n\n## 关于身体\n\n41、养成锻炼身体的习惯，30岁以前你找病，30岁以后病找你。\n\n42、培养一项体育爱好，并坚持下去。\n\n43、每天吃早餐。\n\n44、少吃油腻的快餐食品。\n\n45、尽量减少咖啡的饮用，更不要对其养成依赖。\n\n## 关于生活\n\n46、不断的培养自己的良好的习惯，要相信连续坚持一件事情21天你就会拥有这个好习惯。\n\n47、每天看书。除本专业的相关书籍外，看半个小时其它方面的书：经济学，管理学，各类励志书籍。还可以看看一些牛人的博客。\n\n48、养成写东西的习惯。定期写博客是一个好办法，写作是一个锻炼自己逻辑思维能力的好办法。\n\n49、培养游戏之外的一些爱好，如运动、手工等。研究和娱乐要相结合。\n\n50、疯狂做兼职是没有自信的表现。不要为暂时的困难所束缚，尤其是不要被眼前一时的较小的物质利益所蒙蔽。","tags":["鸡汤"],"categories":["杂记"]},{"title":"刷题","url":"/hexo-blog/2022/09/19/刷题/","content":"\n# 算法题\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2022-09-17 -->\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 链表\n\n### BM1 反转链表\n\n> [反转链表_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca)\n\n![反转链表](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202303171343185.gif)\n\n```java\n//迭代\npublic ListNode reverseList(ListNode head)\n{\n    ListNode pre = null;\n    ListNode cur = head;\n    \n    while(cur!=null){\n        ListNode next = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = next;\n    }\n    return pre;\n}\n```\n\n### BM4 合并两个递增排序的链表\n\n> [合并两个排序的链表_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337)\n\n> 一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。\n\n```java\n/*\npublic class ListNode{\n    int val;\n    ListNode next = null;\n    \n    ListNode(int val){\n        this.val = val;\n    }\n}\n*/\n\npublic class Solution{\n    public ListNode Merge(ListNode list1, ListNode list2){\n        ListNode result = new ListNode(-1);\n        ListNode cur = result;\n        \n        while(list1 != null && list2 != null){\n            if(list1.val <= list2.val){\n                cur.next = list1;\n                list1 = list1.next;\n            }else{\n                cur.next = list2;\n                list2 = list2.next;\n            }\n            cur = cur.next;\n        }\n        if(list1 != null){\n            cur.next = list1;\n        }\n        if(list2 != null){\n            cur.next = list2;\n        }\n        \n        return result.next;\n    }\n}\n```\n\n### BM11 链表相加\n\n> [链表相加(二)_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b)\n\n> 反转链表，依次相加（注意进位），再反转链表输出\n\n```java\npublic class Solution{\n    public ListNode addInList(ListNode head1, ListNode head2){\n        // 任意一个链表为空，返回另一个\n        if(head1 == null) return head2;\n        if(head2 == null) return head1;\n        \n        //反转两个链表\n        head1 = reverse(head1);\n        head2 = reverse(head2);\n        \n        //设置哨兵节点\n        ListNode result = new ListNode(-1);\n        ListNode cur = result; // 用来做遍历，而result始终指向头节点\n        \n        //进位标志\n        int flag = 0;\n        while(head1 != null || head2 != null){\n            int value = flag;\n            //value用来保存相加值\n            if(head1 != null){\n                value += head1.val;\n                head1 = head1.next;\n            }\n            if(head2 != null){\n                value += head2.val;\n                head2 = head2.next;\n            }\n            \n            flag = value / 10;\n            \n            //注意分配内存\n            cur.next = new ListNode(value % 10);\n            cur = cur.next;\n        }\n        \n        //注意最后是否有进位\n        if(flag > 0){\n            cur.next = new ListNode(flag);\n        }\n        \n        //忽略哨兵节点，反转链表输出\n        return reverse(result.next);\n    }\n    \n    public ListNode reverse(ListNode head){\n        ListNode pre = null;\n        ListNode cur = head;\n        \n        while(cur != null){\n            ListNode temp = cur.next;//断开链表，保存后续的节点\n            cur.next = pre;//当前的next指向前一个\n            pre = cur;//前一个更新为当前\n            cur = temp;//当前更新为刚刚保存的后续节点\n        }\n        \n        return pre;\n    }\n}\n```\n\n### BM15 删除有序链表中重复的元素-I(去重)\n\n> [删除有序链表中重复的元素-I_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79)\n\n```java\npublic class Solution{\n    public ListNode deleteDuplicates(ListNode head){\n        if(head == null){\n            return head;\n        }\n        \n        ListNode cur = head;\n        \n        while(cur != null && cur.next != null){\n            // 舍去相同的，只留下一个，达到去重效果\n            if(cur.val == cur.next.val)\n            {\n                cur.next = cur.next.next;\n            }else{\n                cur = cur.next;\n            }\n        }\n        \n        return head;\n    }\n}\n```\n\n### BM16 删除有链表中重复的元素-II(删除)\n\n> [删除有序链表中重复的元素-II_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024)\n\n> + 加个表头方便删除头节点重复的情况\n\n```java\npublic class Solution{\n    public ListNode deleteDuplicates(ListNode head){\n        if(head == null){\n            return head;\n        }\n        \n        // 加个表头\n        ListNode result = new ListNode(-1);\n        result.next = head;\n        ListNode cur = result;\n        \n        while(cur.next != null && cur.next.next != null){\n           //遇到两个节点相同\n            if(cur.next.val == cur.next.next.val){\n                int temp = cur.next.val;\n                // 把相同的都跳过\n                while(cur.next != null && cur.next.val == temp){\n                    cur.next = cur.next.next;\n                }\n            }else{\n                cur = cur.next;\n            }\n        }\n        // 返回时去掉表头\n        return result.next;\n    }\n}\n```\n\n## 二分查找\n\n### BM17 二分查找-I\n\n> [二分查找-I_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b)\n\n```java\nimport java.util.*;\n\npublic class Solution{\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param nums int整型一维数组 升序排序\n     * @param target int整型 目标值\n     * @return int整型  下标\n     */\n    public int search(int[] nums, int target){\n        int l = 0;\n        int r = nums.length - 1;\n        //从数组首尾开始，直至相遇\n        while(l <= r){\n            // 每次检查中点的值\n            int k = (l + r) / 2;\n            if(target == nums[k]) return k;\n            if(target > nums[k]) l = k + 1;   //进入右区间\n            else r = k - 1;   // 进入左区间\n        }\n        // 未查找到\n        return -1;\n    }\n}\n```\n\n### BM1 二维数组中的查找\n\n> [二维数组中的查找_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e)\n\n> - 矩阵的行元素和列元素都是有序的，从左到右递增，从上到下递增，完全递增元素不会有重复\n> - 分治\n\n```java\npublic class Solution {\n    public boolean Find(int target, int [][] array) {\n        if(array == null){\n            return false;\n        }\n\n        int row = array.length;\n        int column = array[0].length;\n\n        int i = row - 1, j = 0;\n        while(i >= 0 && j < column){\n            if(target == array[i][j]) return true;\n            if(target > array[i][j]) j++;\n            else i--;\n        }\n\n        return false;\n\n    }\n}\n```\n\n### BM21 旋转数组的最小数字\n\n> [旋转数组的最小数字_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba)\n\n```java\nimport java.util.ArrayList;\npublic class Solution {\n    public int minNumberInRotateArray(int [] array) {\n        if(array.length == 0) return 0;\n\n        int left = 0;\n        int right = array.length - 1;\n\n        while(left < right){\n            // 找到数组中点\n            int m = (left + right) / 2;\n            if(array[m] == array[right]) right--;  //缩小右边界\n            else if(array[m] > array[right]) left = m + 1;  //旋转点在右边界\n            else right = m; //旋转点在左边界\n        }\n\n        return array[left];\n    }\n}\n```\n\n## 二叉树\n\n### BM23 二叉树的前序遍历\n\n> [二叉树的前序遍历_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635)\n\n```java\nimport java.util.*;\n\n/*\npublic class TreeNode{\n   int val = 0;\n   TreeNode left = null;\n   TreeNode right = null;\n   \n   TreeNode(int val){\n       this.val = val;\n   }\n}\n*/\n\npublic class Solution{\n    public int[] preorderTraversal(TreeNode root){\n        List<Integer> list = new ArrayList<>();\n        \n        preorder(list, root);\n        \n        // JDK8 Stream\n        //return list.stream().mapToInt(Integer::valueOf).toArray();\n        int[] res = new int[list.size()];\n        int i = 0;\n        for(int e : list){\n            res[i++] = e;\n        }\n        return res;\n    }\n    \n    public void preorder(List<Integer> list, TreeNode root){\n        if(root == null) return;\n        \n        list.add(root.val);\n        preorder(list, root.left);\n        preorder(list,root.right);\n    }\n}\n```\n\n### BM24 二叉树的中序遍历\n\n> [二叉树的中序遍历_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d)\n\n```java\npublic class Solution{\n    public int[] inorderTraversal(TreeNode root){\n        List<Integer> list = new ArrayList<>();\n        \n        inorder(list, root);\n        \n        int[] res = new int[list.size()];\n        int i = 0;\n        for(int e : list){\n            res[i++] = e;\n        }\n        \n        return res;\n    }\n    \n    public void inorder(List<Integer> list, TreeNode root){\n        if(root == null){\n            return;\n        }\n        \n        inorder(list, root.left);\n        list.add(root.val);\n        inorder(list, root.right);\n    }\n}\n```\n\n### BM25 二叉树的后序遍历\n\n> [二叉树的后序遍历_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541)\n\n```java\npublic class Solution {\n    public int[] postorderTraversal (TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n\n        inorder(list, root);\n\n        int[] res = new int[list.size()];\n        int i = 0;\n        for (int e : list) {\n            res[i++] = e;\n        }\n\n        return res;\n    }\n\n    public void inorder(List<Integer> list, TreeNode root) {\n        if (root == null) {\n            return;\n        }\n\n        inorder(list, root.left);\n        inorder(list, root.right);\n        list.add(root.val);\n    }\n}\n```\n\n### BM26 二叉树的层序遍历\n\n> [求二叉树的层序遍历_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3)\n\n```java\npublic class Solution{\n    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root){\n        ArrayList<ArrayList<Integer>> res = new ArrayList<>();\n        if(root == null){\n            return res;\n        }\n        \n        Queue<TreeNode> queue = new ArrayDeque<>();\n        \n        queue.add(root);\n        while(!queue.isEmpty()){\n            ArrayList<Integer> row = new ArrayList<>();\n            int n = queue.size();\n            for(int i = 0; i < n; i++){\n                TreeNode node = queue.poll();\n                row.add(node.val);\n                \n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }        \n            }\n            res.add(row);        \n        }\n        \n        return res;\n    }\n}\n```\n\n### BM35 判断是不是完全二叉树\n\n> [判断是不是完全二叉树_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae)\n\n> 使用层序遍历，注意空节点也要入队（`ArrayDeque`不支持存储`null`，`LinkedList`支持）\n>\n> + 当按层序遍历的方式，遇到null，但是队列中仍然存在节点，则代表不是完全二叉树；否则，是完全二叉树。\n\n```java\npublic class Solution {\n    public boolean isCompleteTree(TreeNode root){\n        if(root == null) return true;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        boolean flag = false;\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            if(node == null){\n                flag = true;\n            }else{\n                if(flag){\n                    return false;\n                }\n                queue.offer(node.left);\n                queue.offer(node.right);\n            }\n        }\n        return true;\n    }\n}\n```\n\n### BM36 判断是不是平衡二叉树\n\n> [判断是不是平衡二叉树_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222)\n\n```java\npublic class Solution {\n    boolean isBalanced = true;\n    public boolean IsBalanced_Solution(TreeNode root) {\n        TreeDepth(root);\n        return isBalanced;\n    }\n    \n    // 改造计算深度的函数\n    public int TreeDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        int l = TreeDepth(root.left);\n        if(l == -1) return -1;\n        int r = TreeDepth(root.right);\n        if(r == -1) return -1;\n\n        if(Math.abs(l - r) > 1){\n            isBalanced = false;\n            return -1;   //剪枝，当判断了深度之差大于1后，直接返回\n        }\n\n        return Math.max(l, r) + 1;\n    }\n}\n```\n\n### BM38 在二叉树中找到两个节点的最近公共祖先\n\n> [在二叉树中找到两个节点的最近公共祖先_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116)\n\n> **递归情况：**\n> 1.当到达空节点（既叶子节点的子节点）时，直接返回空\n> 2.当root等于 o1 或 o2 时，返回root\n> 3.若不为1， 2中情况，说明需要继续处理：\n> 对左子树进行递归，返回值记为 t1\n> 对右子树进行递归，返回值记位 t2\n> t1 ，t2 存在以下几种情况：\n> ①. 当t1, t2都为空时，说明root的左右子树中都不存在o1, o2， 返回空\n> ②. 当t1为空且t2不为空时，说明左子树找不到 o1, o2,所以返回 t2\n> ③. 当t2为空且t1不为空时，说明右子树找不到 o1, o2,所以返回 t1\n> ④. 当t1, t2都不为空时,说明o1, o2分别位于root的左右子树中，既root为答案，返回root\n\n```java\npublic class Solution{\n        public int lowestCommonAncestor (TreeNode root, int o1, int o2) {\n        return dfs(root, o1, o2).val;\n    }\n\n    public TreeNode dfs(TreeNode root, int o1, int o2) {\n        if(root == null || root.val == o1 || root.val == o2){\n            return root;\n        }\n\n        TreeNode left = dfs(root.left, o1, o2);\n        TreeNode right = dfs(root.right, o1, o2);\n\n        if(left == null){\n            return right;\n        }\n        if(right == null){\n            return left;\n        }\n\n        return root;\n    }\n}\n```\n\n","categories":["Tips"]},{"title":"工作Tips","url":"/hexo-blog/2022/09/17/工作Tips/","content":"\n# 工作Tips\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2023-03-16 -->\n> 第二次提交\n> <!-- endtimeline -->\n>\n> <!-- timeline 2022-09-17 -->\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n## Hexo使用\n\n1. markdown中编写公式时，不要有多余的括号。例如公式\"x+y\"这样写就足够，如果写成这样\"{x+y}\"，Typora可以忽略这种大括号，但是hexo生成时会报错。\n\n## Java调用C/C++\n\n> 大概流程：\n>\n> 1. Java项目中，新建本地方法类并声明本地方法（要在C中实现的方法）；\n> 2. Java项目中，使用`javac -h`生成包含该方法的C头文件；\n> 3. C项目中，将上述生成的头文件以及在JDK安装目录下的`jni.h`、`jni_md.h`头文件放到C项目中，并编写`cpp`文件实现方法。\n> 4. C项目中，将编写的`cpp`文件编译成动态链接库；\n> 5. Java项目中，将动态链接库放到指定的目录，并且设置项目的本地库路径为这个指定目录；\n> 6. Java项目中加载这个动态链接库，并直接使用本地方法。\n","categories":["Tips"]},{"title":"文献阅读--Improved Techniques for Training GANs","url":"/hexo-blog/2022/09/02/文献阅读--Improved Techniques for Training GANs/","content":"\n# 文献阅读：Improved Techniques for Training GANs\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.09.17 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n​\t\t我们介绍了应用于生成对抗网络 （GAN） 框架的各种新架构功能和训练过程。我们聚焦于GANs的两类应用：半监督学习，以及生成人类认为视觉逼真的图像，与大多数生成模型的工作不同，我们的主要目标不是训练一个能为测试数据分配高概率的模型，我们也不要求模型在不使用任何标签的情况下学习得很好。使用我们的新方法，我们在MNIST，CIFAR-10和SVHN上的半监督分类中实现了最先进的结果。通过视觉图灵测试证实，生成的图像具有高质量：我们的模型生成了人类无法与真实数据区分的MNIST样本，而人类对于CIFAR-10样本的误判率为21.3%。我们还展示了具有空前分辨率的ImageNet样本，并表明了我们的方法能够使模型学习到ImageNet类的可识别特征。\n\n### 1 引言\n\n​\t\t生成对抗网络（GAN）是基于博弈论学习生成模型的一类方法。GANs的目标是训练一个可以从数据分布生成样本的生成网络$G(z;\\theta^{(G)})$，$p_{data}(x)$，通过将噪声$z$的向量变换为$x=G(z;\\theta^{(G)})$。$G$的训练信号由一个训练来区分样本是来自生成器分布$p_{model}(x)$还是真实数据的判别器网络$D(x)$提供。然后，生成器网络$G$反过来被训练来愚弄判别器接收其输出是真实的。\n\n​\t\tGANs的近期应用表明，它们可以生成出色的样本。然而，训练GANs要求找到一个具有连续高维参数的非凸博弈的纳什均衡。GANs通常采用梯度下降法进行训练，该方法旨在找到成本函数的一个低值，而不是找到博弈的纳什均衡。当用于寻求纳什均衡时，这些算法可能无法收敛。\n\n​\t\t在本工作中，我们提出了几种激励GANs博弈收敛的方法。这些技术的动机是对非收敛问题的启发式理解。它们可以提高半监督学习性能并改善样本生成。我们希望其中一些可以成为未来工作的基础，为收敛性提供正式的保证。所有的代码和超参数可以在下列网址找到：https://github.com/openai/improved_gan。\n\n### 2 相关工作\n\n​\t\t一些近期的文献聚焦于改善训练的稳定性和GAN样本的感知质量。我们在本文的工作中以其中一些技术为基础。例如，我们使用Radford 等人提出的的某些\"DCGAN\"架构创新。如下所示。\n\n​\t\t我们提出的技术之一，特征匹配，在3.1节中进行讨论，与使用最大均值差异来训练生成器网络的技术在本质上类似。我们提出的另一项技术，小批量特征，部分基于批归一化的想法，而我们提出的虚拟批归一化是批归一化的一个直接扩展。\n\n​\t\t本工作的一个主要目标是提高生成对抗网络在半监督学习（通过学习额外的未标记示例来提高监督任务的性能，在这时是分类）中的有效性。和许多深度生成模型一样，GANs已有被用于半监督学习的先例，我们的工作可以看作是这一尝试的延续和完善。\n\n### 3 趋向收敛的GAN训练\n\n​\t\tGANs的训练包括找到二人对抗博弈的纳什均衡。每个玩家都希望最小化自己的成本函数，判别器的$J^{(D)}(\\theta^{(D)},\\theta^{(G)})$，生成器的$J^{(G)}(\\theta^{(D)},\\theta^{(G)})$。纳什均衡是这样一个$(\\theta^{(D)},\\theta^{(G)})$点，$J^{(D)}$相对于$\\theta^{(D)}$最小，$J^{(G)}$相对于$\\theta^{(G)}$最小。遗憾的是，找到纳什均衡是一个非常困难的事情。针对特殊情况的算法是存在的，但我们不知道有任何可行的方法适用于GAN博弈，因为它的成本函数是非凸的，参数是连续的，参数空间是超高维的。\n\n​\t\t当每个参与者有最小成本时就会出现纳什均衡的想法，这似乎直观地激发了使用传统基于梯度的最小化方法同时最小化每个参与者成本的想法。遗憾的是，改变$\\theta^{(D)}$来减少$J^{(D)}$会增大$J^{(G)}$，而改变$\\theta^{(G)}$来减少$J^{(G)}$会增大$J^{(D)}$。因此，梯度下降在许多博弈中无法收敛。例如，当一个参与者最小化关于$x$的$xy$，另一个参与者最小化关于$y$的$-xy$，梯度下降进入一个稳定范围，而不是收敛到希望的均衡点$x=y=0$。因此，以前的 GAN 训练方法同时对每个参与者的成本使用梯度下降，尽管不能保证这个过程会收敛。我们介绍了以下启发式激励以提高收敛的方法。\n\n#### 3.1 特征匹配\n\n​\t\t特征匹配通过为生成器指定一个新目标避免它在当前判别器上过度训练来解决GANs的不稳定性。新的目标不是直接最大化判别器的输出，而是要求生成器生成与真实数据的统计信息相匹配的数据，我们只使用判别器来指定我们认为值得匹配的统计信息。具体来说，我们训练生成器来匹配判别器中间层上特征的期望值。这是生成器匹配的统计数据的自然选择，因为通过训练鉴别器，我们要求它找到那些最能区分真实数据与当前模型生成的数据的特征。\n\n​\t\t让$f(x)$表示鉴别器中间层上的激活，我们生成器的新目标这样定义：$\\|E_{x\\sim{p_{data}}}f(x)-E_{z\\sim{p_z(z)}}f(G(z))|^2_2$。判别器的$f(x)$以常规的方式进行训练。与常规 GAN 训练一样，目标有一个 $G$ 与训练数据的分布完全匹配的固定点。我们不能保证在实践中达到这个固定点，但我们的经验结果表明，特征匹配在常规 GAN 变得不稳定的情况下确实有效。\n\n#### 3.2 小批量判别\n\n​\t\tGAN的主要故障模式之一是生成器崩溃到始终发出相同点的参数设置。当即将崩溃为单一模式时，判别器的梯度可能指向许多相似点的相似方向。因为判别器独立处理每个示例，它的梯度之间没有协调，因此没有机制来告诉生成器的输出变得更加不同。相反，所有输出都朝着判别器当前认为非常真实的一个点靠近。在崩溃发生后，判别器知道了这个单点来自生成器，但是梯度下降无法区分如此相同的输出。然后判别器的梯度将生成器产生的单点永远推向空间，并且该算法无法收敛到正确熵的分布。避免这类失败的一个明显策略是允许判别器组合查看多个数据示例，并执行我们所说的小批量判别。\n\n​\t\t小批量判别的概念相当笼统：任何将多个示例结合而不是孤立地查看的判别器模型，都可能有助于避免生成器崩溃。实际上，由Radford等人在判别器中批量归一化的成功应用从这个角度可以很好的解释。然而，到目前为止，我们将实验限制在明确旨在识别特别靠近的生成器样本的模型上。对小批量示例中的紧密度进行建模的一个成功规范如下：$f(x_i)\\in{R^A}$表示关于输入$x_i$由鉴别器中的某个中间层产生的特征向量。然后将向量$f(x_i)$和张量$T\\in{R^{A\\times{B}\\times{C}}}$相乘，结果得到矩阵$M_i\\in{R^{B\\times{C}}}$。然后当样本$i\\in\\{1,2,...,n\\}$时，计算结果矩阵$M_i$的行之间的$L_1$距离，并且应用一个负指数（图1）：$c_b(x_i,x_j)=exp(-\\parallel{M_{i,b}-M_{j,b}}\\parallel_{L_1})\\in{R}$。样本$x_i$的小批量层的输出$o(x_i)$，定义为$c_b(x_i,x_j)$与所有其他样本的总和。\n$$\no(x_i)_b=\\sum^n_{j=1}c_b(x_i,x_j)\\in{R} \\\\\no(x_i)=\\big[o(x_i)_1,o(x_i)2,...,o(x_i)_B\\big]\\in{R^B} \\\\\no(X)\\in{R^{n\\times{B}}}\n$$\n​\t<font size=\"2\">图1（图略）：图描绘了小批量判别是如何工作的特征$f(x_i)$是。来自样本$x_i$与张量$T$的相乘，并计算了交叉样本距离。</font>\n\n接下来，将minibatch层的输出$o(x_i)$与作为其输入的中间特征$f(x_i)$连接起来，并将结果输入到判别器的下一层。我们为生成器样本和训练数据样本分开计算小批量特征。和以前一样，鉴别器仍然需要为每个示例输出一个数字，指示它来自训练数据的可能性有多大。因此，鉴别器的任务仍然是有效地将单个示例分类为真实数据或生成数据，但它现在能够使用小批量中的其他示例作为辅助信息。小批量判别是我们能够非常快速地生成具有视觉吸引力的样本，从这个方面来说它优于特征匹配（第6节）。然而，有趣的是，如果目标是使用第5节中描述的半监督学习方法获得强分类器，则发现特征匹配工作得更好。\n\n#### 3.3 历史平均\n\n​\t\t在使用这个方法时，我们修改每层的成本以添加这样一项：$\\parallel{\\theta-\\frac{1}{t}\\sum^t_{t=1}\\theta[i]}\\parallel^2$，其中 $\\theta[i]$ 是过去时间$i$ 的参数值。参数的历史平均值可以在线更新，因此该学习规则可以很好地扩展到长时间序列。这种方法受到虚构游戏算法的粗略启发，该算法可以在其他类型的游戏中找到平衡。我们发现，我们的方法可以在低维的，连续非凸的博弈中找到平衡，例如最小最大博弈：一个参与者控制$x$，另一个参与者控制$y$，值函数为$(f(x)-1)(y-1)$，其中当$x<0$时$f(x)=x$，否则$f(x)=x^2$。对于这类相同的博弈，梯度下降会由于进入无法逼近平衡点的扩展轨道而失败。\n\n#### 3.4 单边标签平滑\n\n​\t\t标签平滑是20世纪80年代由Szegedy等人独立重新发现的一种方法。使用平滑的值（像0.9或者0.1）替代分类器中的目标0和1，近来被证明可以用于减少用于对抗示例的神经网络的脆弱性。\n\n​\t\t使用$\\alpha$代替正分类目标，$\\beta$替代负目标，最佳判别器变成了$D(x)=\\frac{\\alpha{p_{data}(x)+\\beta{p_{model}(x)}}}{p_{data}(x)+p_{model}(x)}$。分子中$p_{model}$的存在是有问题的，因为在$p_{data}$近似为0且$p_{model}$很大的区域，来自$p_{model}$​的错误样本没有动机来逼近数据。因此，我们只将正标签平滑到$\\alpha$，而将负标签置为0。\n\n#### 3.5 虚拟批归一化\n\n​\t\t批量归一化极大地改进了神经网络的优化，并且被证明对DCGANs非常有效。然而，它导致输入示例$x$的神经网络输出高度依赖与同一小批量中的其他几个输入$x^{\\prime}$。为了避免这个问题我们提出虚拟批量归一化（VBN），其中，每个示例$x$进行归一化，基于在训练开始时选择一次并固定的参考批量示例收集的统计数据和基于$x$本身。参考批量的归一化只使用它自身的统计数据。VBN在计算上是昂贵的，因为它要求在两个小批量数据上执行前向传播，因此我们只将它用于生成器网络。\n\n### 4 图像质量评估\n\n​\t\t生成对抗网络缺少目标函数，导致它难以和不同的模型比较性能。一个直观的策略是：可以通过人类注释者判断样本的可视化质量来获得性能。我们在图2中的网页界面（地址在http://infinite-chamber-35121.herokuapp.com/cifar-minibatch/）使用Amazon Mechanical Turk（MTurk）将这一过程自动化，用来让注释者区分生成的数据和真实数据。模型质量评估的结果在第6节中描述。\n\n​\t\t使用人类注释者的一个缺点是这个策略会依赖任务的设置和注释者的动机而变化。我们也发现当给注释者反馈他们的错误时结果会发生极大改变：通过从这些反馈中学习，注释者能够更好地指出生成的图像的缺陷，给出一个更差的质量评估。图2的左半部分展示了注释过程的屏幕，右半部分展示了我们如何告知注释者他们的错误。\n\n<font size=\"2\">图2（图略）：提供给注释者的网页界面。注释者被告知要从真实的图像中区分出计算机生成的图像。</font>\n\n​\t\t作为人类注释者的一个替代选择，我们提出了一个自动化方法来评估样本，我们发现该方法与人工评估有很好的相关性：我们将Inception模型应用到每个生成的图像中以得到条件标签分布$p(y|\\vec{x})$。包含有意义对象的图像应该具有低熵的条件标签分布$p(y|\\vec{x})$。此外，我们希望模型生成不同的图像，所以边缘$\\int{p(y|\\vec{x}=G(z))dz}$应当具有高熵。结合这两点要求，我们提出这样的策略：$exp(E_xKL(p(y|\\vec{x})||p(y)))$，我们对结果取幂，以便更容易比较这些值。我们的*Inception score*与CatGAN中用于训练生成模型的目标密切相关：尽管我们使用这样的目标进行训练的成功率较低，但我们发现它是一个良好的评估策略，与人工判断关系密切。我们发现在足够多的样本（即 $50k$）上评估指标非常重要，因为该指标是衡量多样性的一部分。\n\n### 5 半监督学习\n\n​\t\t考虑一个用于将数据点$x$分类为$K$个可能的类别之一的标准分类器。这样的一个模型将$x$作为输入，然后输出一个$K$维的logits向量$\\{l_1,...,l_K\\}$，这个向量可以通过softmax：$p_{model}(y=j|\\vec{x})=\\frac{exp(l_j)}{\\sum^K_{K=1}exp(l_K)}$转换为类概率。在监督学习中，这样的模型通过最小化观察标签与模型预测分布$p_{model}(y|\\vec{x})$之间的交叉熵来训练得到。\n\n​\t\t我们可以使用任意标准分类器通过简单地将来自GAN生成器$G$的样本添加到我们的数据集来做半监督学习，使用一个新的“生成的”类$y=K+1$对他们进行标注，并且相应地将分类器的输出维度从$K$增加到$K+1$。然后我们可以使用$p_{model}(y=K+1|\\vec{x})$来提供$\\vec{x}$是假的概率，对应于原始GAN框架中的$1-D(\\vec{x})$。现在我们可以从未标注数据中进行学习，只要我们通过最大化$\\log{p_{model}(y\\in\\{1,...,K\\}|\\vec{x})}$知道它对应于真实数据的$K$个类别之一。假定我们的数据集组成一半是真实数据一半是生成数据（这是随机的），那我们训练分类器的损失函数则变成\n$$\n\\begin{aligned}\nL&=-E_{\\vec{x},y\\sim{p_{data}(\\vec{x},y)}}\\big[\\log{p_{model}(y|\\vec{x})}\\big]-E_{\\vec{x}\\sim{G}}\\big[\\log{p_{model}(y=K+1|\\vec{x})}\\big] \\\\\n\n&=L_{supervised}+L_{unsupervised},where  \\\\\n\nL_{supervised}&=-E_{\\vec{x},y\\sim{p_{data}(\\vec{x},y)}}\\log{p_{model}(y|\\vec{x},y<K+1)}  \\\\\n\nL_{unsupervised}&=-\\{E_{\\vec{x}\\sim{p_{data}(\\vec{x})}}\\log\\big[{1-p_{model}(y=K+1|\\vec{x})}\\big]+E_{\\vec{x}\\sim{G}}\\log\\big[{p_{model}(y=K+1|\\vec{x})}\\big]\\}\n\\end{aligned}\n$$\n我们将总的交叉熵损失分解为标准监督损失函数$L_{supervised}$（标签的负log概率，假定数据是真实的）和一个无监督损失$L_{unsupervised}$，它实际上是标准GAN博弈值，当我们将$D(x)=1-p_{model}(y=K+1|\\vec{x})$代入表达式时，这一点很明显：\n$$\nL_{unsupervised}=-\\{E_{\\vec{x}\\sim{p_{data}(\\vec{x})}}\\log{D(\\vec{x})}+E_{z\\sim{noise}}\\log{(1-D(G(z)))}\\}.\n$$\n最小化$L_{supervised}$和$L_{unsupervised}$的最佳方案是找到$exp[l_j(\\vec{x})]=c(\\vec{x})p(y=j,\\vec{x}) \\forall{j<K+1}$和$exp[l_{K+1}](\\vec{x})=c(\\vec{x})p_G(\\vec{x})$，后者用于一些待定的缩放函数$c(\\vec{x})$。因此，无监督损失与 Sutskever 等人所描述的监督损失在意义上一致，我们希望通过联合最小化这两个损失函数来更好地从数据中估计出这个最优解。实践中，$L_{umsupervised}$只有在对分类器进行较为重要的最小化才会有所帮助，因此，我们需要训练$G$来近似数据分布。实现的一种方式是通过使用分类器所定义的判别器$D$来训练$G$，以此最小化GAN博弈值。这种方法在$G$和分类器之间引入了我们尚未完全理解的交互，但实验发现使用特征匹配GAN优化$G$对于半监督学习非常有效，而使用小批量判别的GAN来训练$G$却根本不起作用。在这里，我们使用这种方法展示我们的实证结果；使用这种方法给出对$D$和$G$之间交互的完整理论理解留待未来的工作。\n\n​\t\t最后，请注意，我们的具有$K+1$个输出的分类器是过参数化的：从每个输出logit中减去一个通用函数$f(\\vec{x})$，即设置$l_j(\\vec{x})\\leftarrow{l_j(\\vec{x})-f(\\vec{x})} \\forall{j}$，这并不改变softmax的输出。这意味着我们可以等同地固定$l_{K+1}(\\vec{x})=0 \\forall(\\vec{x})$，在这种情况下，$L_{supervised}$成为了初始具有$K$个类别的分类器的标准监督损失函数，且判别器$D$由$D(\\vec{x})=\\frac{Z(\\vec{x})}{Z(\\vec{x})+1}$给定，其中$Z(\\vec{x})=\\sum^K_{k+1}{exp[l_k(\\vec{x})]}$。\n\n#### 5.1 标签对图像质量的重要性\n\n​\t\t除了在半监督学习中取得最先进的结果外，上述方法还具有提高人类注释者判断的生成图像质量的惊人效果。这种原因似乎是人类视觉系统强烈适应图像统计信息，这些统计信息可以帮助推断图像表示的物体类别，对图像解释不太重要的局部统计信息可能不太敏感。在人类注释者报告的质量和第4节中提出的用于明确构建以测量生成图像的“客观性”的*Inception score*之间存在高关联性，可以支撑这种情况。.通过让判别器$D$对图像中显示的对象进行分类，我们偏向于这是一种内部表示，这种表示着重于突出人类强调的相同特征。这种效果可以被理解为一种迁移学习的方法，并且可能被更广泛地应用。我们将进一步探索这种可能性留给未来的工作。\n\n### 6 实验\n\n​\t\t我们在MNIST，CIFAR-10和SVHN上进行了半监督实验，在 MNIST, CIFAR-10, SVHN和ImageNet上 进行了样本生成实验。我们提供代码来复现我们的大多数实验。\n\n#### 6.1 MNIST\n\nMNIST数据集包含60,000个已标注的数字图像。我们在其中随机选取一小部分来进行半监督训练，考虑具有20，50，100，和200个已标注的示例。结果在超过10个已标注数据的随机子集上平均得到，每个选择都有来自每个类别的均衡数量的示例。剩余的训练图像由未标注的数据提供。我们每个网络都有5个隐藏层。使用权值归一化，添加高斯噪声到判别器的每一层输出。表1总结了我们的结果。\n\n​\t\t在使用特征匹配（3.1节）半监督学习过程中生成器生成的样本在视觉上看起来别不吸引人（左图3）。通过使用小批量判别（3.2节）来替换，我们能够提高视觉质量。在MTurk上，注释者能够在$52.4\\%$的案例中区分样本（总共2000），其中 50% 可能通过随机猜测获得。同样，我们机构的研究人员无法找到任何可以让他们区分样本的人工制品。然而，进行小批量判别的半监督学习无法产生像进行特征匹配的半监督学习那样好的分类器。\n\n<font size=\"2\">图3（图略）：（左）模型在半监督训练过程中生成的样本。样本可以明显地与来自MNIST数据集的图像进行区分。（右）进行小批量判别的训练生成的样本。样本和数据集图像完全无法区分。</font>\n\n<font size=\"2\">表1（表略）：置换不变的 MNIST 的半监督设置的错误分类测试示例的数量。结果是超过 10 个种子的平均。</font>\n\n#### 6.2 CIFAR-10\n\nCIFAR-10是一个小型的，经过充分研究的$32\\times32$维自然图像数据集。我们使用这个数据集来学习半监督学习，也用来检验样本的视觉质量是否能够达到要求。在GAN中判别器我们使用了进行dropout和权值归一化的9层深度卷积网络。生成器是一个进行批归一化的4层深度CNN。表2总结了我们在半监督学习任务上的结果。\n\n<font size=\"2\">表2（表略）：半监督CIFAR-10的测试误差。结果是 10 次数据拆分的平均值。</font>\n\n<font size=\"2\">图4（图略）：在CIFAR-10上使用特征匹配（3.1节，左）和小批量判别（3.2节，右）的半监督训练生成的样本。</font>\n\n​\t\t当呈现出50%真实数据和50%虚假数据（我们最佳的CIFAR-10模型生成的数据）时，MTurk使用者正确分类了78.7%的图像。然而，MTurk使用者可能对CIFAR-10图像不够熟悉或不够积极，我们自己能够以$>95\\%$的准确率来分类图像。我们通过根据 Inception 分数仅使用前 1% 的样本对数据进行过滤，然后观察到MTurk准确率下降到$71.4\\%$，来验证上述的Inception分数。我们进行了一系列切除实验来证明我们提出的方法可以提高Inception分数，如表3所示。我们还展示了这些切除实验的图像——在我们看来，Inception分数与我们对图像质量的主观判断高度关联。数据集中的样本达到最高值。所有甚至部分崩溃的模型的分数都相对较低。我们建议Inception分数应当用来作为对通过某些独立标准训练的模型进行评估的粗略指南。直接优化Inception分数会导致对抗样本的生成。\n\n#### 6.3 SVHN\n\n​\t\t对SVHN数据集，我们使用与CIFAR-10数据集相同的架构和实验设置。\n\n<font size=\"2\">图5（图略）：（左）SVHN的错误率。（右）SVHN的生成器生成的样本。</font>\n\n<font size=\"2\">表3（表略）：50,000 张图像的各种模型生成的样本的 Inception 分数表格。分数与人类判断高度相关，自然图像获得最高分。相对地，模型生成的崩溃样本获得低分。这个策略让我们能够避免依赖人工评估。“我们的方法”包括本文中所有描述的方法，除了特征匹配和历史平均。剩下的实验是消融实验，表明我们的技术是有效的。“-VBN+BN”替换生成器中的VBN为BN，像在DCGANs中一样。这在CIFAR上导致了样本质量的小幅度下降。VBN对ImageNet来说更重要一点。“-L+HA”将标签从训练过程中移除，并添加历史平均来弥补。HA使得仍然可以生成可识别的物体。没有HA，样本质量大大降低（参见\"-L\"）。相对于“我们的方法”，“-LS”消除了标签平滑，导致了性能的明显下降。“-MBF”消除了小批量特征，然后导致了性能的大幅下降，甚至比移除标签导致的下降还要更大。添加HA无法避免这个问题。</font>\n\n#### 6.4 ImageNet\n\n​\t\t我们在一个空前规模的数据集上测试了我们的方法：来自具有1000个类别的ILSVRC2012数据集的$128\\times128$图像。据我们所知，以前没有任何公开发表文章将生成模型应用于具有如此大分辨率和如此大规模目标类的数据集。大规模的目标类对GANs来说尤其具有挑战性，因为它们倾向于低估分布中的熵。我们使用Tensorflow广泛修改了公开可用的DCGAN实现以实现高性能，并使用多GPU训练。未经修改的 DCGAN 学习一些基本的图像统计信息并生成具有自然颜色和纹理的连续形状，但不学习任何对象。使用本文描述的方法，GANs学习生成类似动物但解剖结构不正确的物体。结果如图6所示。\n\n<font size=\"2\">图6（图略）：ImageNet数据集生成的样本。（左）DCGAN生成的样本，（右）使用本文中提出的方法生成的样本。这种新方法能使得GANs学习动物的可识别特征，例如毛发，眼睛和鼻子，但是这些特征没有正确组合成具有逼真解剖结构的动物。</font>\n\n### 7 结论\n\n​\t\t生成对抗网络是一类前途无量的生成模型，到目前为止，它一直受到不稳定训练和缺乏适当评估标准的阻碍。本文工作提出了对这两个问题的部分解决方案。我们提出了几种方法来稳定训练，使我们能够训练以前无法训练的模型。此外，我们提出的评估标准（the Inception score）为我们提供了对比这些模型质量的基础。我们将我们的方法应用到半监督学习的问题中，在计算机视觉中的大量不同数据集上获得了最先进的结果。在这项工作中所作的贡献是具有实际意义的。我们希望在未来的工作中形成更严格的理论认识。\n\n### 参考文献\n\n> 略。\n\n## 其他\n\n> 1. 相关术语\n>    + Nash Equilibrium 纳什均衡\n>    + Inception score（IS）：生成的图像分布与真实图像分布的KL散度。\n>    + Inception model\n>    + logits\n> 2. 代码：https://github.com/openai/improved-gan\n> 3. 句子\n>    + We leave further exploration of this possibility for future work.\n>    + The contributions made in this work are of a practical nature; we hope to develop a more rigorous theoretical understanding in future work.\n> 4. 相关资源\n>    + [Improved Techniques for Training GANs翻译与理解_CSDN博客](https://blog.csdn.net/u013972559/article/details/85545339)\n> 5. 引用：[1] Salimans T ,  Goodfellow I ,  Zaremba W , et al. Improved Techniques for Training GANs[J].  2016.\n\n## 单词\n\n> 1. unprecedented  前所未有的，空前的\n> 1. marginal  小的，边缘的\n> 1. in turn 反过来，转而，轮流\n> 1. intuitive  直觉的，直观的\n> 1. equivalent  等同的；对等事物\n> 1. trivial  琐碎的，易解决的，不重要的\n> 1. substitute 替代品，代替物；用.....代替\n> 1. continuation 连续，持续\n> 1. drastically  猛烈地，极其，非常\n> 1. sketch 素描，简述\n> 1. emphasize 强调，着重；emphasis  重要性，重点强调\n> 1. presumably  probably\n> 1. arbitrary 任意的，随心所欲的\n> 1. assuming  假设，假定\n> 1. pessimistic  悲观的\n> 1. downside 下降趋势，缺点\n> 1. denote 标志，表示\n> 1. vulnerability 易损性，弱点\n> 1. side information 辅助信息\n> 1. erroneous 错误的\n> 1. isolation  隔离，孤立\n> 1. appealing  吸引人的； appeal 呼吁，恳求\n> 1. emit 排放，发出\n> 1. incentive  激励，刺激，动机\n> 1. imminent  即将发生的，将近的\n> 1. refinement 精炼，改进\n> 1. formal  正式的，规范的，形式上的\n> 1. game theory 博弈论   theory 学说，理论","tags":["GAN"],"categories":["文献阅读"]},{"title":"文献阅读--Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks","url":"/hexo-blog/2022/08/24/文献阅读--Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks/","content":"\n# 文献阅读：Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks(DCGAN)\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.08.30 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n​\t\t近年来，使用卷积网络（CNNs）的监督学习在计算机视觉应用中被广泛采用。相比之下，CNNs的无监督学习却很少有人关注。在这项工作中，我们希望帮助弥合CNNs在监督学和和无监督学习上的成功之间的差距。我们介绍了这样一类CNNs：深度卷积生成对抗网络（DCGANs），它具有一定的架构约束，并且证明了它是无监督学习的有力候选者。在各种图像数据集上进行训练，我们展示了令人信服的证据，表明我们的深度卷积对抗对在生成器和判别器上学习了从对象部分到场景的表示层次。此外，我们将学习到的新特征用于新任务——证明了它作为一般图像表示的通用性。\n\n### 1 引言\n\n​\t\t从大型未标记数据集中学习可重用的特征表示一直是一个活跃的研究领域。在计算机视觉的背景下，人们可以充分利用几乎不限数量的未标记图像和视频来学习良好的中间表示，然后可以用于诸如图像分类的各种监督学习任务。我们提出一种通过训练生成对抗网络（GANs）来构建良好图像表示的方法，接着继续重用生成器和判别器网络的部分作为监督任务中的特征抽取器。GANs为最大似然技术提供了一种有吸引力的替代方案。人们还可以争辩说他们的学习过程和无需启发式成本函数（例如逐像素独立均方误差）对表示学习很有吸引力。众所周知，GANs训练不稳定，经常导致生成器产生出荒谬的输出。在试图理解和可视化GANs的学习内容和多层GANs的中间学习方面，目前已发表的研究十分有限。\n\n​\t\t本文中，我们作出如下贡献：\n\n+ 我们提出并评估了一组在卷积GANs的架构拓朴上的约束，这些约束使它们能够在大多数环境中稳定训练。我们将这类架构命名为深度卷积GANs（DCGANs）。\n+ 我们将训练好的判别器用于图像分类任务，展现出了与其他无监督算法有竞争力的性能。\n+ 我们将GANs学习到的过滤器可视化，凭经验表明这种特定的过滤器学会了绘制特定的对象。我们展示了生成器具有有趣的向量算术特性，可以轻松操作生成样本的许多语义特征。\n\n### 2 相关工作\n\n#### 2.1未标注数据的表示学习\n\n​\t\t在一般计算机视觉研究和图像相关研究中，无监督表示学习是一个研究得相当好的问题。无监督表示学习的一个经典方法是对数据进行聚类（如使用K-means），并且使用聚类提高分类分数。在图像研究中，可以对图像块进行层次聚类来学习优秀的图像表示。另一个流行的方法是训练自动编码器（卷积，堆叠），将代码组件的内容和位置分离，使用梯形结构来将图像编码为简洁的代码，然后将代码解码来重建尽可能准确的图像。这些方法都表明了可以从图片像素中学习优秀的特征表示。深度置信网络也被证明在学习层次表示上效果很好。\n\n#### 2.2 生成自然图像\n\n​\t\t生成图像模型得到了很好的研究，主要分成两类：参数的和非参数的。\n\n​\t\t非参数模型通常是从已有图像的数据库中进行匹配，通常是匹配图像块，然后用于纹理合成、超分辨率和图像修复。\n\n​\t\t用于生成图像的参数模型得到了广泛的探索（例如在MNIST数字或者纹理合成上）。然而，直到最近，生成真实世界中的自然图像也没有取得大的成功。一种生成图像的变分采样方法取得了一些成功，但是样本通常会变得模糊。另一种生成图像的方法运用迭代前向扩散过程。生成对抗网络生成的图像嘈杂且难以理解。这种方法的一种拉普拉斯金字塔扩展展示了更高质量的图像，但由于链接多个模型引入的噪声，他们仍然受到对象看起来不稳定的影响。近来一种循环网络方法和一种去卷积网络在生成自然图像上取得了一些成功。然而，他们都没有在监督任务中利用生成器。\n\n#### 2.3 可视化CNNs内核\n\n​\t\t对使用神经网络的一个持续批评是，它们是黑盒方法，很少能知道这网络在以一种简单的人类可消耗算法的形式做什么。在CNNs相关研究中，Zeiler等人表明，通过使用反卷积和过滤最大激活值，可以找到网络中每个卷积过滤器的大致用途。同样，在输入上使用梯度下降可以让我们检查激活某些过滤器子集的理想图像。\n\n### 3 方法和模型架构\n\n​\t\t使用CNNs对图像建模来扩展GANs的历史尝试并不成功。这促使了LAPGAN的作者开发了一种迭代升级低分辨率生成图像的替代方案，这种方案可以更加可靠地建模。我们尝试使用监督文献中常用的CNN架构来扩展GANs也遇到了困难。然而，经过了广泛的模型探索，我们确立了一系列架构，这些架构在一系列数据集上进行了稳定的训练，并可以训练更高分辨率和更深层的生成模型。\n\n​\t\t我们方法的核心是采用和修改最近展示的CNN架构的三个变化。\n\n​\t\t首先，全卷积网络使用跨步卷积（strided convolution）代替确定性的空间池化函数（例如maxpooling），它允许网络学习自己的空间下采样。我们在生成器中采用这种方法，让它能够学习自己的空间上采样和判别器。\n\n​\t\t其次，在卷积特征上消除全连接层的趋向。关于此最好的例子就是全局平均池化被用到最先进的图像分类模型中。我们发现全局平均池化增加了模型稳定性但降低了收敛速度。将最高卷积特征直接连接到生成器和判别器各自的输入输出的中间地带的效果很好。GAN的第一层，使用一个均匀噪声分布$Z$作为输入，因为它只是一个矩阵乘法，所以可以看作为全连接的。但是结果会被重塑为一个4维的张量并用作卷积堆栈的开始。对判别器来说，最后一个卷积层被展平，然后馈入单个sigmoid输出。图1展示了一个示例模型架构的可视化。\t\n\n​\t\t第三，批量归一化，它通过将每个单元的输入归一化为零均值和单元方差来稳定学习。这可以帮助处理由于不好的初始化导致的训练问题，并有助于梯度在更深层的模型中流动。事实证明，让深度生成器开始学习非常重要，避免生成器将所有样本崩溃到一个点，是GAN中观察到的常见故障模式。然而，直接将批归一化应用于所有层会导致样本振荡和模型不稳定。这可以通过不要再生成器输出层和判别器输入层中使用批归一化来避免。\n\n​\t\t除了输出层使用Tanh函数外，生成器的其他层使用ReLU函数。我们观察到使用有界激活可以使模型更快地学习到饱和并覆盖训练分布的颜色空间。在判别器中我们发现带泄露修正激活（Leaky ReLU）表现很不错，特别是针对更高分辨率的建模。这是与原始使用maxout激活的GAN论文相比。\n\n​\t\t稳定深度卷积GANs架构指南\n\n+ 使用跨步卷积代替池化层（判别器），使用小跨步卷积代替池化层（生成器）。\n+ 在生成器和判别器中使用批归一化（batchnorm）。\n+ 移除更深层架构中的全连接隐藏层。\n+ 除了输出层使用Tanh，生成器其他层使用ReLU激活。\n+ 判别器所有层都使用LeakyReLU激活。\n\n### 4 对抗训练细节\n\n​\t\t我们在三个数据集上训练了DCGANs：大规模场景理解（LSUN），Imagenet-1k，一个新组装的Faces数据集。这些数据集每个的详细用法在下面给出。\n\n![image-20220827150147217](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202209021514195.png)\n\n<font size=\"2\">图1：用于LSUN场景建模的DCGAN生成器。将100维的均匀分布$Z$投影到具有许多特征图的小空间范围卷积表示。一系列四个小跨步卷积（在近期某些论文中，它们被错误的叫做反卷积）将这种高级表示转换为$64\\times64$的像素图片。值得注意的是，这里没有使用全连接层或者池化层。</font>\n\n​\t\t除了将训练图像缩放到Tanh激活函数的范围[-1,1]之外，不进行其他的预处理。所有模型使用小批量随机梯度下降（SGD）来训练，小批量大小为128。所有权重初始化为服从以零为中心的正太分布，标准差为0.02。在LeakyReLU中，所有模型的泄露斜率设置为0.2。虽然之前的GAN工作采用动量来加速训练，但我们采用可以调节超参数的Adam优化器。我们发现建议的0.001学习率太高，改用了0.0002。此外，我们发现将动量项$\\beta_1$留在0.9的建议值会导致训练振荡和不稳定，因此我们减少到了0.5来维持稳定训练。\n\n#### 4.1 LSUN\n\n​\t\t随着生成图像模型的样本视觉质量的提高，对训练样本过拟合和记忆的担忧也随之上升。为了展示我们的模型如何随着更多的数据和更高的分辨率生成而扩展，我们在包含超过300万个训练示例的LSUN卧室数据集上训练了一个模型。最近的分析表明，模型的训练速度和它们的泛化性能存在直接关系。我们展示了来自一轮训练的样本（图2），模仿在线学习，以及收敛后的样本（图3），以此证明我们的模型没有通过简单的过拟合/记忆训练示例来生成高质量的样本。图像中没有采用数据增强。\n\n<font size=\"2\">图2（图略）：数据集上经过一次训练生成的卧室。理论上，模型可以学习到记忆训练示例，但这在实验上不太可能，因为我们采用小的学习率和小批量SGD来训练。我们知道没有先前的经验证据表明能够使用SGD和小学习率来进行记忆。</font>\n\n<font size=\"2\">图3（图略）：经过4轮训练后生成的卧室。通过在多个样本（例如一些床的底板）中重复噪声纹理，这成为出现了视觉欠拟合的证据。</font>\n\n##### 4.1.1 去重\n\n​\t\t为了进一步降低生成器记忆输入示例的可能性（图2），我们进行了一个简单的图像去重过程。我们在训练示例的$32\\times32$下采样center-crops上拟合了一个3072-128-3072去噪dropout正则化RELU自动编码器。然后通过对ReLU激活阈值化，来对生成的代码层激活进行二值化，这已经被证明是一种有效的信息保存方法，并且提供了一种方便的寓意散列形式，这种形式允许线性时间去重。对哈希冲突的目视检查显示出高精度，估计误报率不到 100 分之一。此外，这项技术检测和移除了大约275,000个相近的重复项，这表明召回率很高。\n\n#### 4.2 FACEs\n\n​\t\t我们从人名的随机网络图像查询中抓取包含人脸的图像。以生于现代为标准，人名从数据库百科中获取。该数据集有来自10K个人的300万张图像。我们在这些图像上运行OpenCV面部检测器，在保持充分高分辨率的检测下，给了我们大概35,000张面部框。我们将这些面部框用于训练。图像不采用数据增强。\n\n#### 4.3 IMAGENET-1K\n\n​\t\t我们使用 Imagenet-1k作为自然图像来源进行无监督训练。在$32\\times32$的最小调整大小的center-crops上训练。图像不采用数据增强。\n\n### 5 实验验证DCGANs性能\n\n#### 5.1 使用GANs作为特征提取器对CIFAR-10进行分类\n\n​\t\t一个常用的评估无监督表示学习算法质量的方法是将这些算法作为监督数据集的特征提取器，然后评估拟合在这些特征之上的线性模型的性能。\n\n​\t\t在CIFAR-10数据集上，使用K-means作为特征学习算法，一个经过良好调整的单层特征提取管道已经表现出了非常好的基线性能。当使用大量特征图（4800）时，该技术可实现80.6%的精度。一个基于上述算法的无监督多层扩展达到了82.0%的精度。为了评估将DCGANs学习到的表示用于监督任务的质量，我们在Iamgenet=1k上进行训练，然后将判别器的卷积特征用于所有层，最大池化每一层表示来生成一个$4\\times4$的空间网格。然后将这些特征展平并连接组成一个28672维的向量，并在上面训练一个正则化线性L2-SVM分类器。这实现了82.8%的精度，优于所有基于K-means的算法。值得注意的是，相比基于K-means的方法，判别器的特征图要少得多（最高层为512个），但是由于$4\\times4$个空间位置的多层结构，确实会导致更大的总特征向量大小。DCGANs的性能仍然低于Exemplar CNNs，Exemplar CNNs是一种以无监督方式训练常规判别性CNNs的技术，以区分在源数据集中专门选择的和积极增强的示例样本。可以通过微调判别器的表示来进一步改进，但我们将其留作未来的工作。此外，由于我们的DCGAN从未在CIFAR-10上进行过训练，因此，该实验还展示了学习特征的域鲁棒性。\n\n\n\n#### 5.2 使用GANs作为特征提取器对SVHN数字进行分类\n\n​\t\t在街景门牌号数据集（SVHN，StreeView House Numbers）上，当缺少标记数据时，我们将DCGAN判别器的特征用于监督目的。使用与CIFAR-10实现中类似的数据集准备规则，我们从非额外集合中划分出一个由10,000个示例组成的验证集，并将其用于所有的超参数以及模型的选择。随机选择1000个均匀类分布训练示例，用来在用于CIFAR-10的相同特征提取管道上训练一个正则化线性L2-SVM分类器。这在22.48%的测试误差下实现了最好的结果（使用1000个标签进行分类），改进了旨在利用未标记数据的另一种改进CNN。我们在相同的数据上训练一个同样架构的纯监督CNN，并通过对64个超参数实验的随机搜索来优化模型，验证了在DCGAN中使用的CNN架构不是模型性能的关键因素。它实现了显著更高的28.87%的验证误差。\n\n### 6 调查和可视化网络的内部结构\n\n我们以各种方式对训练的生成器和判别器进行探索。我们不再训练集上执行任何类型的最近邻搜索。像素或特征空间中最近邻会被小的图像变换所愚弄。我们也没有使用对数似然指标来定量评估模型，因为他是一个很差的指标。\n\n#### 6.1 隐空间漫游（探索隐空间）\n\n​\t\t我们做的第一个实验是了解隐空间的景象。在所学的流形上漫游通常可以告诉我们记忆的迹象（如果有急剧的转变），以及空间分层坍塌的方式。如果在这个隐空间中漫游会导致图像生成的语义变化（例如添加和删除对象），我们可以推断模型已经学习了相关且有趣的表示。结果如图4所示。\n\n<font size=\"2\">图4（图略）：顶行：$Z$中一系列9个随机点之间的插值表明，所学习的空间具有平滑的过渡，空间中的每个图象看起来都像一间卧室。在第6行，你可以看到一个没有窗户的房间慢慢编程一个有巨大窗户的房间。在第10行中，你可以看到看起来像是电视的对象慢慢变成窗户。  </font>\n\n#### 6.2 可视化判别器特征\n\n先前的工作已经表明，在大型图像数据集上对CNN进行监督训练会产生非常强大的学习特征。此外，还有工作是在场景分类上训练监督CNNs来学习目标检测。我们证明了在大型图像数据集上训练一个无监督DCGAN也可以学习到有趣的特征层次结构。使用文献中提出的指导性反向传播，判别器学习到的特征在卧室的典型部分（如床和窗户）上激活，这在图5中表明。为了进行比较，在同一图中，我们为随机初始化的特征提供了一个基线，这些特征未在语义相关或有趣的任何事物上激活。\n\n<font size=\"2\">图5（图略）：在右边，判别器中最后一个卷积层中前 6 个学习到的卷积特征的最大轴对齐响应的引导反向传播可视化。请注意，有少数的特征对床做出响应——LSUN卧室数据集中的中心对象。左边是一个随机过滤器基线。与之前的响应相比，几乎没有判别和随机结构。</font>\n\n#### 6.3 篡改生成器表示\n\n##### 6.3.1 忘记绘制某些对象\n\n​\t\t除了判别器学习到的表示之外，还有一个问题，即生成器学习了什么表示。示例质量表明，生成器学习主要场景组件（如床，窗户，灯，门和杂项家具）的特定对象表示。为了探索这些表示形式，我们进行了一个实验，试图从生成器中完全删除窗户。\n\n​\t\t在150个样本中，手动绘制了52个窗口边界框。在第二高的卷积层特征上，逻辑回归适合预测特征激活是否在窗户上（或不在窗户上），方法是使用这样的标准：即绘制的边界框内的激活是正向的，来自相同图像的随机样本是负向的。使用这种简单的模型，从所有空间位置删除所有权重大于零（总共200）的特征图。然后，在删除和不删除特征图的情况下随机生成新样本。\n\n​\t\t删除和不删除窗户生成的图像如图6所示，有趣的是，网络大多忘记在卧室里画窗户，并且用其他对象代替它们。\n\n<font size=\"2\">图6（图略）：顶行：模型的未修改示例。底行：删除了窗户的相同生成样本。一些窗户被删除了，剩下的被转换成具有相似视觉外观的物体，如门和镜子。虽然视觉质量有所下降，但整体场景构图仍然相似，这表明生成器在将场景表示与对象表示分开方面做得很好。可以进行扩展实验以从图像中删除其他对象并修改生成器绘制的对象。</font>\n\n##### 6.3.2 面部样本上的向量算术\n\n​\t\t在评估单词的学习表示的文章中表明，简单的算术运算揭示了表示空间中丰富的线性结构。一个典型的例子表明，向量（“King”）-向量（Man）+向量（“Woman”）产生了最近邻是Queen的向量。我们研究了生成器的 $Z$ 表示中是否会出现类似的结构。我们对视觉概念的示例样本集的 $Z$ 向量执行了类似的算术运算。对每个概念只进行单个样本的实验是不稳定的，但对三个样本的$Z$向量求平均表明，在语义上符合算术的生成是一致和稳定的。除了（图7）中所示的对象操作外，我们还演示了在Z空间中对面部姿态进行线性建模（图8）。\n\n<font size=\"2\">图7（图略）：视觉概念的向量计算。对每一列，对样本的$Z$向量求均值。然后在平均向量上执行算术运算来创建一个新向量$Y$。右手边的中心样本是通过将$Y$作为生成器的输入来生成的。为了演示生成器的插值能力，将采样比例为$+-0.25$的均匀噪声添加到$Y$中来生成其他8个样本。在输入空间中采用算术（底部两个示例）会导致由于未对准而导致的噪声重叠。</font>\n\n<font size=\"2\">图8（图略）：\"turn\"向量是根据四张向左看和向右看的面部平均样本创建的。通过沿着这条轴向随机样本中添加插值，我们可以可靠地改变他们的姿态。</font>\n\n​\t\t这些演示表明，可以使用我们的模型所学到的 $Z$ 表示来开发有趣的应用程序。之前（的文献）已经证明，条件生成模型可以学习对令人信服的对象属性（如比例、旋转和位置）进行建模。据我们所知，这是在纯无监督模型下首次演示这种发生情况。进一步探索和开发上述提到的向量算术可以显著减少复杂图像分布的条件生成建模所需要的数据数量。\n\n### 7 结论和未来工作\n\n​\t\t我们提出了一个训练生成对抗网络的更加稳定的架构集合，并且证明了对抗网络在监督学习和生成建模方面可以学习良好的图像表示。但仍然存在某些形式的模型不稳定性——我们注意到，随着模型训练时间越来越长，它们有时候会将过滤器的子集折叠到单个振荡模式。\n\n​\t\t未来的工作需要解决这一不稳定问题。我们认为将这个框架扩展到其他领域，例如视频（用于帧预测）和音频（用于语音合成的预训练特征）应当会非常有趣。对学习到的潜在空间（隐空间）的进一步研究也会是十分有趣的。\n\n### 致谢\n\n略。\n\n### 参看文献\n\n略。\n\n### 8 补充材料\n\n#### 8.1 评估 DCGANs 捕获数据分布的能力\n\n​\t\t我们提出将标准分类指标应用于我们模型的条件版本，来评估学习到的条件分布。我们在MNIST上训练了一个DCGAN（划分了一个10K的验证集），并且排列不变GAN基线，使用最近邻分类器将真实数据与生成的条件样本进行比较来评估模型。我们发现，从batchnorm中删除比例和偏差参数对两个模型都产生了更好的结果。我们推测batchnorm引入的噪声有助于生成模型更好地探索和生成底层数据分布。表3的结果展示了我们的模型与其他方法的对比。DCGAN模型与在训练数据集上拟合的最近邻分类器具有相同的测试误差——表明DCGAN在建模这个数据集的条件分布上表现出色。当每类100万个样本时，DCGAN性能优于InfiMNIST，一个使用平移和弹性形变训练示例的手工开发的数据增强管道。与利用学习到的每类转换的概率性生成数据增强技术相竞争，DCGAN会更加通用，因为它直接对数据建模而不是对数据进行变换。\n\n## 其他\n\n> 1. 相关术语\n>    + Latent Space（隐空间）\n>    + Leaky ReLU\n> 2. 数据集\n>    + MNIST：[MNIST数据集](http://t.csdn.cn/9RJg1)\n>    + LSUN：[LSUN数据集读取和解压-CSDN博客](https://blog.csdn.net/qq_39909808/article/details/124652219)\n>    + ImageNet-1k：[ImageNet数据集 & 下载-CSDN博客](http://t.csdn.cn/4lJn3)\n>    + CIFAR-10：[Dataset之CIFAR-10：CIFAR-10数据集的简介、下载、使用方法之详细攻略](https://aistudio.csdn.net/62e38a6fcd38997446774c71.html?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-2-82793025-blog-125194540.t5_layer_eslanding_D_0&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-2-82793025-blog-125194540.t5_layer_eslanding_D_0&utm_relevant_index=5)\n> 3. 相关资源\n>    + [UNSUPERVISED REPRESENTATION LEARNING WITH DEEP CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORKS - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/482748077)\n> 4. 引用：[1] Radford A ,  Metz L ,  Chintala S . Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks[J]. Computer ence, 2015.\n\n## 单词\n\n> 1. adoption 采用；接纳\n> 1. side-by-side 并排的，并行的\n> 1. critical 批判的，关键的，极其重要的\n> 1. concatenate  连接，连结\n> 1. elastic  有弹性的，灵活的\n> 1. superb 极佳的，非同一般的\n> 1. speculate  猜测，推测\n> 1. underlying 根本的，潜在的，下层的\n> 1. furniture  家具\n> 1. tackle  解决，与...交涉\n> 1. dramatically  剧烈地，明显地，夸张地\n> 1. obey 遵守，服从\n> 1. this is to our knowledge (that)... 据我们所知 \n> 1. consistent 持续的，一致的\n> 1. canonical   标准的，典型的\n> 1. assess  evaluate 评估\n> 1. differentiate 区分，使不同\n> 1. theoretically 理论上\n> 1. attribute 属性，特质\n> 1. trivially  无能地，琐细地\n> 1. scarce 稀有的，缺少的\n> 1. oscillation  振荡，摆动\n> 1. supplementary material 补充材料\n> 1. inspection 视察，检查\n> 1. robustness 鲁棒性\n> 1. visual inspection 目测，目检\n> 1. hash collision 哈希碰撞\n> 1. false positive rate 假阳性率，误报率\n> 1. information preserving technique 信息保存方法 \n> 1. notably 特别，尤其\n> 1. metric 度量，衡量标准\n> 1. contrast  差异 ，对比 \n> 1. augmentation  增大，增强\n> 1. a direct link 直接联系\n> 1. generalization performance 泛化性能\n> 1. multiplication 乘法\n> 1. demonstrate  证明，示范，演示\n> 1. collapse  倒塌，崩溃，瓦解\n> 1. standard deviation 标准差\n> 1. deviation 偏差\n> 1. utilize 利用，使用\n> 1. comparatively 相对地\n> 1. flatten 变平，击败\n> 1. tensor 张量\n> 1. spatial 空间的\n> 1. criticism 批评\n> 1. approximate 大概的，近似的；类似，接近\n> 1. texture 质地，纹理\n> 1. wobbly 不稳定的，摆动的  unstable\n> 1. diffusion 扩散，传播\n> 1. in the form of 以····形式\n> 1. synthesis 综合，合成\n> 1. incomprehensible 费解的\n> 1. suffer from 忍受，遭受\n> 1. applicability 适用性\n> 1. heuristic  启发式的\n> 1. super-resolution 超分辨率\n> 1. in-painting 图像修复\n> 1. property  特性，特质，财产，所有权\n> 1. compact  紧凑的，简洁的\n> 1. manipulation 操纵，处理\n> 1. arithmetic 算术的；算术\n> 1. empirical  经验主义的\n> 1. novel 新颖的\n> 1. nonsensical 无意义的，荒谬的\n> 1. intermediate  中间的\n> 1. context  背景；语境\n> 1. practically  几乎，实际上\n> 1. candidate 候选人，申请者\n> 1. hierarchy 等级制度，层次\n> 1. reusable 可重复使用的\n","tags":["GAN","DCGAN"],"categories":["文献阅读"]},{"title":"文献阅读--Conditional Generative Adversarial Nets","url":"/hexo-blog/2022/08/19/文献阅读--Conditional Generative Adversarial Nets/","content":"\n# 文献阅读：Conditional Generative Adversarial Nets\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.08.24 -->\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n生成对抗网络最近作为一种训练生成模型的新方法被引入。在这项工作中，我们介绍了生成对抗网络的条件版本，它可以通过简单地输入数据$y$来构建，我们希望对生成器和判别器都施加条件。我们展示了该模型可以生成以类标签为条件的MNIST数字。我们还说明了该模型如何用于学习多模态模型，并提供了图像标记应用的初步示例，其中我们演示了如何生成不属于训练标签的描述性标签。\n\n### 1 引言\n\n为了规避估计许多棘手概率计算问题的困难，生成对抗网络作为可用于训练生成模型的框架被引入。\n\n对抗网络的优点是不需要马尔科夫链，只使用反向传播来更新梯度，学习过程中不需要推断，并且可以很容易地将各种因素和相互作用纳入模型中。\n\n另外，正如文献[8]中所介绍的，它可以生成最先进的对数似然和真实的样本。\n\n在一个无条件的生成模型中，无法控制正在生成的数据的模式。然而，通过添加附加信息到模型，它可以指导数据生成过程。这种条件可以基于类标签、某些用于修复的数据，甚至可以基于来自不同模态的数据。\n\n在这项工作中，我们展示了如何构建条件对抗网络。对于实验结果，我们展示了两组实验。一个基于类标签的MNIST数字数据集和一个基于MIRFLickr25,000数据集的多模态学习。\n\n### 2 相关工作\n\n#### 2.1 图像标注的多模态学习\n\n尽管监督神经网络（尤其是卷积网络）最近取得了许多成功，但扩展此类模型以适应大量预测输出类别仍然具有挑战性。第二个问题是迄今为止的大部分工作都集中在学习从输入到输出的一对一映射。然而，许多有趣的问题更自然而然地被认为是一个概率性的一对多映射。例如，在图像标注时，许多不同的标签可以适用于一张给定的图像，而不同的（人类）注释者会使用不同的（但是一般是同义词或者相关的）术语来描述同一张图像。\n\n帮助解决第一个问题的一种方式是利用来自其他模态的附加信息：例如，通过使用自然语言语料库来学习几何关系在语义上有关系的标签的向量表示。在这样的空间中进行预测，我们受益于这样的事实：当预测错误时，我们仍然可以接近事实（例如，预测桌子而不是椅子），并且我们可以自然地对那些我们在训练期间从未遇到的标签做预测性的泛化。文献[3]中的工作表明，即使一个从图像特征空间到单词表示空间的简单线性映射也可以提高分类性能。\n\n解决第二个问题的一种方式是使用条件概率生成模型，将输入视为条件变量，并将一对多映射实例化为一个条件预测分布。\n\n文献[16]对这个问题采取了类似的方法，并像我们在这项工作中所做的那样，在MIR Flickr 25,000数据集上训练一个多模态深度玻尔兹曼机。\n\n此外，文献[12]中作者展示了如何训练一个有监督的多模态神经语言模型，并且他们能够为图像生成描述性语句。\n\n### 3 条件对抗网络\n\n#### 3.1 生成对抗网络\n\n近来，生成对抗网络作为一种训练生成模型的新方法被引入。他有两个对抗模型组成：一个捕获数据分布的生成模型$G$，和一个估计样本来自训练数据而不是$G$的概率的判别模型$D$。$G$和$D$都可以是一个非线性映射函数，例如多层感知器。\n\n从数据$x$上学习一个生成器分布$p_g$，生成器建立一个从预先噪声分布$p_z(z)$到数据空间的映射函数$G(z;\\theta_g)$。判别器$D(x;\\theta_d)$输出一个标量，表示$x$来自训练数据而不是$p_g$的概率。\n\n$G$和$D$同时进行训练：我们调整$G$的参数来最小化$log(1-D(G(z)))$，调整$D$的参数来最小化$logD(x)$，就如同他们在遵守价值函数$V(G,D)$的两人最小最大博弈：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z)))]  \\tag{1}\n$$\n\n#### 3.2 条件对抗网络\n\n如果生成器和判别器都以某些额外信息$y$为条件，可以将生成对抗网络扩展到一个条件模型。$y$可以是任何类型的辅助信息，例如类别标签或来自其他模态的数据。我们可以通过将$y$作为附加输入层添加到判别器和生成器中来执行调节。\n\n在生成器中，将先验噪声输入$p_z(z)$和$y$组合成联合隐藏表示，对抗训练框架在如何组合这些隐藏表示具有相当大的灵活性（1：或者现在我们只是将条件输入和先验噪声作为 MLP 的单个隐藏层的输入，但是可以想象如果使用更高阶的交互来实现复杂的生成机制，在传统的生成框架中是非常难以使用的。）。\n\n在判别器中$x$和$y$作为输入和判别函数（这种情况下再次体现为MLP）。\n\n这个二人最小最大博弈的目标函数如公式2所示：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x|y)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z|y)))]  \\tag{2}\n$$\n图1描述了一个简单的条件对抗网络架构。\n\n![image-20220823180125570](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622790.png)\n\n### 4 实验结果\n\n#### 4.1 单模态\n\n我们在基于类标签、one-hot向量编码的MNIST图像集上训练了一个条件对抗网络。\n\n在生成器网络中，从单位超立方体内提取一个100维度的噪声先验$z$，$z$和$y$都映射到具有线性修正单元（ReLU）激活的隐藏层，层大小分别为200和1000，然后被映射到第二个组合的1200维的隐藏ReLu层。然后我们有一个最终的 sigmoid 单元层作为我们的输出，用于生成 784 维 的MNIST 样本。\n\n![image-20220823183721523](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622792.png)\n\n判别器将$x$映射到一个有240个单元和5个块的maxout层，将$y$映射到一个有50个单元和5个块的maxout层。这两个隐藏层都映射到具有 240 个单元和 4 个块的联合 maxout 层，然后被馈送到 sigmoid 层。（只要有足够的能力，鉴别器的精确架构并不重要；我们发现 maxout 单位通常非常适合该任务）\n\n该模型以随机梯度下降训练，其小批量大小为100，初始学习率为 0.1，它以指数方式下降到 0.000001，衰减因子为 1.00004。动量也被使用，初始值为 0.5，增加到 0.7。概率为0.5的dropout也应用到生成器和判别器中。在验证集上最佳的对数似然估计被用来作停止点。\n\n表1展示了在MNIST数据集测试数据上的高斯Parzen窗口对数似然估计。从每10个类别中抽取1000个样本，使用Gaussian Parzen window拟合这些样本。然后使用Parzen window分布估计测试集的对数似然（如何构建这个估计的详细内容参见文献[8]）。\n\n我们提出的条件对抗网络结果与其他一些基于网络的结果相当，但优于其他几种方法——包括非条件对抗网络。我们将这些结果更多地作为概念验证而不是功效证明，并相信随着对超参数空间和架构的进一步探索，条件模型应该匹配或超过非条件结果。\n\n图2展示了一些生成样本。每一行都以一个标签为条件，每一列都是不同的生成样本。\n\n![image-20220823193835278](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622793.png)\n\n#### 4.2 多模态\n\n像Flickr这样的照片网站是图像及其相关的用户生成元数据（UGM）形式的标记数据的丰富来源——尤其是用户标签。\n\n用户生成的元数据不同于更“规范”的图像标记方案，因为它们通常更具描述性。并且在语义上更接近人类用自然语言描述图像的方式，而不仅仅是识别图像中存在的对象。UGM的另一个方面是有很多同义词，不同的用户可能使用不同的词汇描述同样的概念——因此，有一个有效的方法来规范化这些标签很重要。概念词嵌入在这里非常有用，因为相关的概念最终用相似的向量表示。\n\n在本节中，我们演示了图像的自动标记，具有多标签预测，使用条件对抗网络生成以图像特征为条件的（可能是多模态的）标签向量分布。\n\n对于图像特征，我们在具有21000个标签的完整ImageNet数据集上预训练了一个类似于文献[13]中的卷积模型。我们使用具有4096个单元的最后一个全连接层的输出作为图像表示。\n\n对于世界表示，我们首先从YFCC100M数据集元数据的用户标签、标题和描述的串联中收集文本语料库。在对文本进行预处理和清洗之后，我们训练了一个词向量大小为200的skip-gram模型。我们从词汇表中省略了出现次数少于200次的所有单词，从而得到大小为24765的字典。\n\n我们在对抗网络的过程中保持卷积网络和语言模型不变。我们将要通过这些模型进行反向传播的实验留作未来的工作。\n\n我们的实验中，使用了MIR Flickr 25,000数据集，使用我们上面提到的卷积模型和语言模型来抽取图像和标签特征。实验中会省略没有任何标签的图像，并且将注释视为额外标签。前150,000个样本作为训练集。对每个相关联的标签，多标签的图像在训练集中会被重复一次。\n\n在评估时，我们为每个图像生成 100 个样本，并使用词汇表中单词的向量表示与每个样本的余弦相似度来找到前 20 个最接近的单词。然后我们在所有100个样本中选择前10个最常用的词。表4.2展示了一些用户分配的标签和注释的示例以及生成的标签。\n\n![image-20220824154342673](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622794.png)\n\n最佳工作模型的生成器接收大小为100的高斯噪声作为噪声先验并且映射到维度为500的ReLU层。映射4096维的图像特征向量到2000维的ReLu隐藏层。这两个层都被映射到一个维度为200的组合表示的线性层，用来输出生成的单词向量。\n\n判别器分别由用于词向量和图像特征的500维和1200维ReLu隐藏层，作为连接层的有1000个单元和3个块的maxout层组成，最后发送到单个sigmoid单元。\n\n该模型以随机梯度下降训练，其小批量大小为100，初始学习率为 0.1，它以指数方式下降到 0.000001，衰减因子为 1.00004。动量也被使用，初始值为 0.5，增加到 0.7。概率为0.5的dropout也应用到生成器和判别器中。\n\n通过交叉验证，以及使用随机网格搜索和人工选择的混合（尽管搜索空间有限）来确定超参数和架构选择。\n\n### 5 未来工作\n\n本文展示的结果是非常初步的，但它们表明了条件对抗网络的潜力，展示了有趣并且有用的应用前景。\n\n在从现在到研讨会之间的未来探索中，我们希望展示更复杂的模型，并对他们的性能和特点作更详细和透彻的分析。\n\n此外，在当前的实验中，我们只单独使用每个标签。但是通过同时使用多个标签（有效地将生成问题作为“集合生成”问题之一），我们希望获得更好的结果。\n\n留给未来工作的另一个明显方向是构建联合训练方案来学习语言模型。文献[12] 等工作表明，我们可以学习适合特定任务的语言模型。\n\n### 致谢\n\n略。\n\n### 参看文献\n\n略。\n\n## 其他\n\n> 1. 引用：[1] Mirza M ,  Osindero S . Conditional Generative Adversarial Nets[J]. Computer Science, 2014:2672-2680.\n\n## 单词\n\n> 1. multi-modal 多模态的\n> 2. albeit 虽然，尽管\n> 3. preliminary 初步的；预备的\n> 4. scalar 标量\n> 5. thorough 透彻的，深入的\n> 6. sophisticated 见多识广的，复杂巧妙的，精密的；complicated\n> 7. respectively 分别地\n> 8. hypercube 超立方体\n> 9. state of the art 最先进的; 最新水平的\n> 10. accommodate 容纳，适应，迁就\n> 11. probabilistic 概率性的\n> 12. considerable 相当大的，相当重要的\n> 13. geometric relation 几何关系\n\n","tags":["GAN","CGAN"],"categories":["文献阅读"]},{"title":"文献阅读：《Generative Adversarial Nets》","url":"/hexo-blog/2022/08/19/文献阅读--Generative Adversarial Nets/","content":"\n# 文献阅读：《Generative Adversarial Nets》\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.08.19 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n我们通过对抗过程，提出一个预测生成式模型的新框架。我们同时训练了两个模型：一个捕获数据分布的生成模型G，一个可以预测来自训练数据而不是G的样本概率的判别模型D。G的训练过程是最大化D犯错误的概率。这个框架类似于一个极大极小的二人游戏。在任意函数G和D的空间中，存在唯一解：G恢复训练数据的分布，而D任何地方都等于1/2。在G和D都被定义为一个多层感知器的情况下，整个系统通过反向传播来训练。在训练或生成样本的过程中，不需要任何的马尔科夫链或者展开近似推理网络。通过对生成样本进行定性和定量分析，实验证明了该框架的潜力。\n\n### 1 简介\n\n深度学习的宗旨是发现丰富的分层模型，这些模型可以表示人工智能应用中遇到的各种数据的概率分布，例如自然图像、包含语音的音频波形以及自然语言语料库中的符号。目前，深度学习中涉及到判别模型并取得最显著成功的，通常是那些将高维度的，丰富的感官输入映射到一个类标签的模型。这些成功的模型主要是基于BP算法和dropout算法，使用一个分段线性单元，具有特别良好的梯度。由于难以逼近在极大似然估计及其相关策略中出现的许多棘手的概率计算，也由于在生成上下文中难以利用分段线性单元的优势，深度生成模型受到的影响较小。我们提出了一个新的生成模型估计程序来规避这些困难。\n\n在提出的对抗网络框架中，生成模型与对手对抗：一个判别模型学习确定样本来自模型分布还是数据分布。生成模型可以被认为类似于一个造假者团队，试图制造假币并在不被发现的情况下使用它，而判别模型类似于警察，试图检测假币。这场比赛的竞争促使双方改进他们的方法，直到假货与真品无法区分。\n\n这套框架可以为多种模型和优化算法生成特别的训练算法。本文中，我们探讨了生成模型通过多层感知机传递随机噪声来生成样本的特殊情况，判别模型也同样是一个多层感知机。我们将这种特殊情况称为对抗网络。在这种情况下，我们可以仅仅使用非常成功的反向传播和dropout算法来训练两个模型，并且只使用正向传播来训练生成模型的样本。而无需近似推理或者马尔科夫链。\n\n### 2 相关工作\n\n具有潜在变量的有向图模型的替代方案是具有潜在变量的无向图模型，例如受限玻尔兹曼机 (RBM) [27, 16]、深度玻尔兹曼机 (DBM) [26] 及其众多变体。此类模型中的相互作用表示为未归一化势函数的乘积，通过对随机变量的所有状态的全局求和/积分进行归一化。这个数量(配分函数)和它的梯度是棘手的，但最琐碎的情况下，他们可以由马尔可夫链蒙特卡罗(MCMC)方法估计。对于依赖于MCMC的学习算法来说，混合是一个很重要的问题。\n\n深度置信网络(DBNs)[16]是包含一个无向层和多个有向层的混合模型。虽然存在一种快速的分层近似训练准则，但DBNs存在与无向和有向模型相关的计算困难。\n\n也有人提出了不近似或不限制对数似然的替代标准，如分数匹配和噪声对比估计(NCE)。这两者都需要将学习的概率密度分析指定为一个归一化常数。请注意，在许多具有多层潜在变量（例如 DBNs 和 DBMs）的有趣生成模型中，甚至不可能推导出易于处理的非归一化概率密度。一些模型诸如去噪自动编码器 [30] 和收缩自动编码器，其学习规则与应用于 RBM 的分数匹配非常相似。在NCE中，和本文一样，使用了判别训练标准来拟合生成模型。然而，生成模型本身用于从固定噪声分布的样本中区分生成的数据，而不是拟合一个单独的判别模型。由于NCE使用一个固定的噪声分布，当模型在观察变量的一个小子集上学习到一个近似正确的分布之后，学习速度会显著减慢。\n\n最后，一些技术不涉及明确定义概率分布，而是训练生成机器从期望分布中抽取样本。这种方法的优点是可以通过反向传播来训练这些机器。该领域近期主要的工作包括生成随机网络(GSN)框架：它扩展了广义去噪自动编码器：两者都可以看作是定义一个参数化的马尔科夫链，即学习一台机器的参数，执行生成马尔科夫链的一个步骤。与GSNs相比，对抗网络框架的采样不需要马尔科夫链，由于对抗网络在生成过程中不需要反馈环，所以它们能够更好地利用分段线性单元，这提高了反向传播的性能，但在使用反馈环时存在无限制激活的问题。通过反向传播训练生成机器的最新工作包括自动编码变分贝叶斯和随机反向传播。\n\n### 3 对抗网络\n\n当模型都是多层感知机的时候，对抗网络框架最容易应用。为了学习生成器在数据$x$上的分布$p_g$，我们事先定义了一个输入噪声变量$p_z(z)$，然后用$G(z;\\theta_g)$表示将噪声变量映射到数据空间，$G$是一个可微函数，表示为一个参数为$\\theta_g$的多层感知机。我们还定义了一个多层感知机$D(x,\\theta_d)$输出一个标量。$D(x)$表示$x$来自数据集而不是$p_g$的概率。我们训练$D$来最大化将正确标签分配给训练样本和来自$G$的样本的概率。与此同时，我们训练$G$来最小化$log(1-D(G(z)))$：换句话说，$D$和$G$进行了如下具有值函数$V(G,D)$的二人极大极小博弈：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z)))]. \\tag{1}\n$$\n在下一节中，我们将对对抗网络进行理论分析，主要说明当$G$和$D$分配有足够容量时，也就是在非参数限制时，训练准则允许恢复数据生成分布。如图1所示，对该方法进行了一个不太正式、更具教育性的解释。实践中，我们必须使用一个迭代的数值方法来实现这种操作。在训练的内部循环中优化$D$来完成计算是极其困难的，并且在有限的数据集上会导致过拟合。相反，我们在优化$D$的$k$个步骤和优化$G$的一个步骤之间交替进行。只要$G$变化足够慢，$D$的解就会保持在其最优解附近。这种策略类似于SML/PCD：训练从一个学习步骤到下一个学习步骤保持来自马尔可夫链的样本，以避免作为学习内部循环的一部分在马尔可夫链中消失。该过程在算法1中正式给出。\n\n在实际应用中，公式$1$可能无法为$G$提供足够的梯度来学习。在学习的早期，当$G$较差时，$D$可以很有信心地拒绝样本，因为它们与训练数据明显不同。在这种情况下，$log(1 - D(G(z)))$饱和，与其训练$G$去最小化$log(1 - D(G(z))$不如训练$G$去最大化$logD(G(z))$。这一目标函数的结果与动态的$G$和$D$相同，但在学习的早期提供了更强的梯度。\n\n![图1](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443946.png)\n\n图1：通过同时更新判别分布（$D$，蓝色，虚线）来训练生成对抗网络，以便它区分来自数据生成分布（黑色，虚线）$p_x$ 的样本和生成分布 $p_g(G)$（绿色，实线）的样本。下面的水平线是 $z$ 被采样的域，在这种情况下是均匀的。上面的水平线是 $x$ 域的一部分。向上的箭头显示了映射 $x = G(z)$ 如何将非均匀分布 $p_g$ 施加到变换后的样本上。$G$ 在$p_g$ 的高密度区域收缩并在$p_g$的低密度区域膨胀。（a）考虑一个接近收敛的对抗对：$p_g$与$p_{data}$类似，$D$是部分准确的分类器。（b）算法$D$的内部循环被训练来判别数据集的样本，收敛到$D^{*}(x)=\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)}$。（c）在对 $G$ 进行更新后，$D$ 的梯度引导 $G(z)$ 流向更有可能被分类为数据的区域。（d）在几轮训练后，如果$G$和$D$还有足够的容量，它们将因为$p_g=p_{data}$而达到两者都无法提高的地步。判别器无法区分这两种分布，即$D(x)=\\frac{1}{2}$。\n\n### 4 理论结果\n\n生成器 $G$ 隐含地将概率分布 $p_g$ 定义为当 $z∼p_z$ 时获得的样本 $G(z)$ 的分布。因此，如果给定足够的容量和训练时间，我们希望算法 1 能够收敛到一个好的 $p_{data}$ 估计器。例如，本节的结果是在非参数设置中完成的。我们通过研究概率密度函数空间中的收敛性来表示具有无限容量的模型。\n\n我们将在 4.1 节展示这个极小极大博弈对于 $p_g = p_{data}$ 有一个全局最优解。然后我们将在 4.2 节中展示算法 1 优化 $Eq1$，从而获得期望的结果。\n\n![image-20220816171632123](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191441414.png)\n\n#### 4.1 $p_g=p_{data}$的全局最优\n\n我们首先考虑任何给定生成器 $G$ 的最佳判别器 $D$。\n\n**命题1. **固定$G$，最优判别器$D$为\n$$\nD^{*}_{D}(x)=\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)} \\tag{2}\n$$\n证明：给定任何生成器 $G$，判别器 $D$ 的训练标准是最大化 $V(G, D)$\n$$\n\\begin{aligned}\nV(G,D)&=\\int_{x}p_{data}(x)log(D(x))dx+\\int_{z}p_{z}(z)log(1-D(g(z)))dz \\\\ &=\\int_{x}p_{data}(x)log(D(x))+p_{g}(x)log(1-D(x))dx  \n\\end{aligned}  \\tag{3}\n$$\n\n对任意$(a,b)\\in{R^2}\\setminus\\{0,0\\}$，函数$y\\rightarrow{alog(y)+blog(1-y)}$在$\\frac{a}{a+b}$的$[0,1]$区间内达到最大值。判别器不需要在集合$Supp(p_{data})\\cup{Supp(p_g)}$之外定义，证明结束。\n\n请注意，$D$的训练目标可以解释为：最大化对数似然来估计条件概率$p(Y=y|x)$，这里$Y$表示$x$来自于$p_{data}$（$y=1$）或者$p_g$（$y=0$）。现在，式1中的极大极小博弈可以重述为：\n$$\n\\begin{aligned}\nC(G)&=\\underset{D}{max}V(G,D) \\\\\n&=E_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{z\\sim{p_z}}[log(1-D^*_G(z))] \\\\\n&=E_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{x\\sim{p_g}}[log(1-D^*_G(x))] \\\\\n&=E_{x\\sim{p_{data}}}[log{\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)}}]+E_{x\\sim{p_g}}[log{\\frac{p_g(x)}{p_{data}(x)+p_g(x)}}]\n\\end{aligned} \\tag{4}\n$$\n**定理1.**当且仅当$p_g=p_{data}$时，虚拟训练标准$C(G)$达到全局最小值。此时，$C(G)$的值等于$-log4$。\n\n证明：对$p_g=p_{data}$，$D^*_G(x)=\\frac{1}{2}$，（参见式2）。将$D^*_G(x)=\\frac{1}{2}$代入式4，可以发现$C(G)=log{\\frac{1}{2}}+log{\\frac{1}{2}}=-log4$。仅在$p_g=p_{data}$时，$C(G)$达到最佳可能值，观察到\n$$\nE_{x\\sim{p_{data}}}[-log2]+E_{x\\sim{p_g}}[-log2]=-log4\n$$\n用$C(G)=V(D^*_G,G)$减去该式，可以得到：\n$$\nC(G)=-log(4)+KL\\bigg(p_{data}\\parallel{\\frac{p_{data}+p_g}{2}}\\bigg)+KL\\bigg(p_{g}\\parallel{\\frac{p_{data}+p_g}{2}}\\bigg) \\tag{5}\n$$\n其中$KL$是Kullback-Leibler散度。在先前的表达式中我们认识到模型分布和数据生成过程之间的Jensen–Shannon散度：\n$$\nC(G)=-log(4)+2\\cdot{JSD(p_{data}\\parallel{p_g})}  \\tag{6}\n$$\n由于两个分布之间的Jensen-Shannon散度始终非负且为零，我们已经证明$C^*=-log(4)$是$C(G)$的全局最小值，并且唯一解为$p_g=p_{data}$，也就是说，该生成模型完美复制了数据生成过程。\n\n#### 4.2 算法1的收敛\n\n**命题2. **假定$G$和$D$有足够容量，在算法1中的每一个步骤，在给定$G$的情况下允许判别器达到最优值，并更新$p_g$以改进判断依据\n$$\nE_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{x\\sim{p_g}}[log(1-D^*_G(x))]\n$$\n然后$p_g$收敛到$p_{data}$。\n\n证明：如上所述的判据，考虑将$V(G,D)=U(p_g,D)$作为$p_g$的函数。注意$U(p_g,D)$在$p_g$上是凸的。凸函数在上确界的子导数包括函数在达到最大值点处的导数。换句话说，对$\\forall{\\alpha}$，如果$f(x)=sup_{\\alpha\\in{A}}f_{\\alpha}(x)$和$f_{\\alpha}(x)$在$x$上是凸的，且如果$\\beta=arg\\:sup_{\\alpha\\in{A}}f_{\\alpha}(x)$，那么$\\partial{f_{\\beta}(x)}\\in{\\partial{f}}$。这相当于在给定相应$G$ 的情况下计算最优 $D$ 处 $p_g$的梯度下降更新。如定理1所证明的，$sup_DU(p_g,D)$在$p_g$上是凸的，具有唯一全局最优值，因此，只要$p_g$有足够小的更新，$p_g$可以收敛到$p_x$，证明结束。\n\n在实践中，对抗网络通过函数 $G(z; θg )$ 表示有限的 $p_g$ 分布簇，我们优化 $θ_g$ 而不是 $p_g$ 本身。使用多层感知器来定义 $G$ 在参数空间中引入了多个临界点。无论如何，多层感知器在实践中的出色表现表明，尽管缺乏理论保证，但它们是一个合理的模型。\n\n### 5 实验\n\n我们训练了一系列数据集的对抗网络，包括MNIST，多伦多人脸数据库（TFD）和CIFAR-10。生成器混合使用整流线性激活和sigmoid激活，判别器使用maxout激活。Dropout用于训练判别器。虽然我们的理论框架允许在生成器的中间层使用dropout和其他噪声，但我们只将噪声作为生成网络最底层的输入。\n\n![image-20220818140517291](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443947.png)\n\n表1：基于 Parzen 窗口的对数似然估计。他在 MNIST 上报告的数字是测试集上样本的平均对数似然，其平均误差通过实例计算。.在 TFD 上，我们计算了每折数据集的标准误差，每折验证集选择了不同的$\\sigma$。在TFD上，$\\sigma$对每折进行交叉验证，并计算每折的平均对数似然。我们在MNIST和其他具有实值（而不是二进制）版本的数据集进行对比。\n\n我们通过将Gaussian Parzen 窗口拟合到使用 $G$ 生成的样本并报告此分布下的对数似然来估计 $p_g$ 下的测试集数据的概率。高斯分布的参数$\\sigma$通过在验证集上的交叉验证得到。Breuleux等人介绍了这一过程并用于各种生成模型，这些模型的准确性并不可控。表1展示了这些结果。他估计可能性的方法具有较高的方差，并且在高维空间中表现不佳，但它是我们所知的最佳方法。可以采样但不能估计可能性的生成模型的进步直接推动了对如何评估此类模型的进一步研究。\n\n在图2和图3中我们展示了训练后从生成器中抽取的样本。我们并没有声称这些样本比现有方法生成的样本更好，但我们相信这些样本至少与文献中更好的生成模型可以进行竞争，并突出了对抗框架的潜力。\n\n![image-20220818145150628](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443948.png)\n\n图2：来自模型的样本的可视化。最右列显示相邻样本的最接近训练示例，为了证明模型没有记住训练集。样本是公平的随机抽选，而不是精心挑选的。不像大多数其他深度生成模型，这些图像展示来自模型分布的真实样本，而不是给定隐藏单元样本的平均值。此外，这些样本是不相关的，因为采样过程不依赖于马尔可夫链混合。a) MNIST b) TFD c) CIFAR-10 （全连接模型）d) CIFAR-10 （卷积判别器和“反卷积”判别器）\n\n![image-20220818150235511](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443949.png)\n\n图3：通过在完整模型的 $z$ 空间中的坐标之间进行线性插值获得的数字\n\n|            | 深度有向图模型           | 深度无向图模型                              | 生成式自动编码器                           | 对抗模型                                   |\n| ---------- | ------------------------ | ------------------------------------------- | ------------------------------------------ | ------------------------------------------ |\n| 训练       | 训练时需要推断           | 训练时需要推断。MCMC 需要近似配分函数梯度。 | 在混合和重建生成的权之间进行强制权衡       | 同步判别器和生成器。Helvetica。            |\n| 推断       | 学习近似推断             | 变分推断                                    | 基于MCMC的推断                             | 学习近似推断                               |\n| 采样       | 没有难度                 | 要求马尔科夫链                              | 要求马尔科夫链                             | 没有难度                                   |\n| 评估$p(x)$ | 棘手的，可以用 AIS 近似  | 棘手的，可以用 AIS 近似                     | 没有明确表示，可以用 Parzen 密度估计来近似 | 没有明确表示，可以用 Parzen 密度估计来近似 |\n| 模型设计   | 几乎所有模型都会遇到困难 | 需要精心设计以确保多个属性                  | 理论上允许任何可微函数                     | 理论上允许任何可微函数                     |\n\n表2：生成模型中的挑战：对涉及模型的每个主要操作的深度生成建模的不同方法遇到的困难的总结\n\n### 6 优点和缺点\n\n相对于以前的建模框架，这个新框架具有优点和缺点。缺点是对$p_g(x)$没有明确地表达，并且$D$在训练过程中必须与$G$很好地同步（特别地，在在不更新$D$的情况下，$G$不能训练太多，为了避免\"Helvetica场景\"，$G$ 将过多的 $z$ 值折叠为相同的 $x$ 值，从而有足够的多样性来建模 $p_{data}$），就像玻尔兹曼机器的负链必须在学习步骤之间保持更新一样。优点就是不需要马尔科夫链，而只用反向传播来更新梯度，在学习时不需要推断，并且可以将多种函数集合到模型中。表2总结了生成对抗模型和其他生成模型方法的对比。\n\n上述优势主要是计算上的。对抗模型也可能从生成器网络中获得一些统计优势，而不是直接使用数据样本进行更新，而只是使用流经鉴别器的梯度。这意味着输入元素不会直接复制到生成器的参数中。对抗网络的另一个优点是它们可以表示非常尖锐甚至退化的分布，而基于马尔可夫链的方法要求分布有些模糊，以便链能够在模式之间混合。\n\n### 7 结论和未来工作\n\n这个框架允许许多直接的扩展：\n\n1. 添加$c$作为输入到$G$和$D$中可以得到一个条件生成模型$p(x|c)$。\n2. 通过训练一个辅助网络来预测给定$x$的$z$，其中可以使用学习近似推断。这类似于由wake-sleep算法训练的推断网络，但其优点是可以在生成网络完成训练后为固定生成网络训练推断网络。\n3. 通过训练共享参数的一系列条件模型，可以近似地对所有条件 $p(x_S|x_\\bar{s})$ 建模，其中 $S$ 是 $x$ 的索引的子集。本质上，可以使用对抗网络来实现确定性 MP-DBM 的随机扩展。\n4. 半监督学习：当有限的标记数据可用时，来自判别器或推断网络的特征可以提高分类器的性能。\n5. 效率提升：通过划分更好的方法来协调$G$和$D$或者确立更好的分布来从训练中采样$z$，可以大大加快训练速度。\n\n本文证明了对抗性建模框架的可行性，表明这些研究方向可能是有用的。\n\n### 致谢\n\n> 略。\n\n### 参考文献\n\n> 略。\n\n## 其他\n\n> 1. 代码地址：http://www.github.com/goodfeli/adversarial\n> 2. 引用：[1] Goodfellow I ,  Pouget-Abadie J ,  Mirza M , et al. Generative Adversarial Nets[C]// Neural Information Processing Systems. MIT Press, 2014.\n> 3. [Generative Adversarial Nets 阅读笔记_isinstance的博客-CSDN博客](https://blog.csdn.net/isinstance/article/details/122799469)\n\n## 单词\n\n> 1. simultaneously  at the same time  同时\n> 2. pedagogical 教育的\n> 3. sharp  尖锐的\n> 4. demonstrate  证明；演示\n> 5. blurry  模糊的\n> 6. theorem 定理\n> 7. viability 可行性\n> 8. equivalent  等效的；对等的物\n> 9. replicate 复制，重复\n> 10. conclude 结束，达成\n> 11. momentum 动量\n> 12. convergence 收敛，相交\n> 13. contract 收缩，缩小；契约，合同\n> 14. arrow 箭头\n> 15. horizontal 水平的\n> 16. saturate 浸透，饱和\n> 17. alternate 轮流，交替\n> 18. overfitting 过拟合\n> 19. prohibitive 限制性的\n> 20. finite 有限的\n> 21. discriminative  有区别的，表示差别的\n> 22. arbitrary 随意的\n> 23. perceptron 感知器\n> 24. procedure 程序；过程\n> 25. approximate 近似\n> 26. inference  n.推理\n> 27. potential 潜在的 ；潜力\n> 28. qualitative and quantitative 定性和定量\n> 29. hierarchical 分层的\n> 30. map 映射\n> 31. waveform 波形\n> 32. encounter 遭遇；邂逅\n> 33. corpora 语料库\n> 34. striking 引人注目的\n> 35. involve 涉及\n> 36. piecewise 分段的\n> 37. intractable 棘手的\n> 38. maximum likelihood estimation 最大似然估计\n> 39. sidestep  回避\n> 40. analogous 类似的\n> 41. counterfeit 伪造，假冒的\n> 42. indistinguishable 难以区分的\n> 43. restrict 限制；控制\n> 44. variant 变种，变体\n> 45. trivial 琐碎的\n> 46. criterion 标准\n> 47. incur 带来，招致\n> 48. bound 限制；受约束的；边界\n> 49. contrastive 对比的\n> 50. density  密度\n> 51. tractable 易处理的\n> 52. contractive 收缩的\n> 53. dramatically 剧烈地，戏剧性地\n> 54. explicitly 明确地\n> 55. implicitly 含蓄地，隐含地\n> 56. prominent 重要的，显著的，突出的\n> 57. stochastic 随机的\n> 58. i.e.   即，也就是\n> 59. straightforward 直截了当地；简单的\n> 60. differentiable 可微分的，可区分的\n> 61. theoretical 理论上的\n> 62. formal  正式的，合法的","tags":["GAN"],"categories":["文献阅读"]},{"title":"Python学习笔记(2)--初级编程","url":"/hexo-blog/2022/08/19/Python学习笔记(2)--初级编程/","content":"\n# Python学习笔记(2)——初级编程\n\n<!--start: 2022.04.19-->\n\n## Python输入和输出\n\n### 键盘输入\n\n> +  [input() 函数](https://www.runoob.com/python3/python3-func-input.html)从标准输入读入一行文本，返回为 string 类型。默认的标准输入是键盘。\n\n```python\n>>> a = input(\"请输入你的名字:\")   # 里面可以包含提示信息\n请输入你的名字:Jerry\n>>> a\n'Jerry'\n\n>>> a,b,c = input('请输入三角形三边的长:').split()  # 通过split()分割字符串得到多个输入\n请输入三角形三边的长:3 4 5\n>>> a\n'3'\n>>> b\n'4'\n>>> c\n'5'\n```\n\n### 控制台输出\n\n> + Python两种输出值的方式：表达式语句和print()函数。\n> + 将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。\n> + 用 str.format() 函数来格式化输出值。\n\n```python\n>>> s = 'Hello'\n>>> s                  # 表达式语句输出：输出整个表达式\n'Hello'\n>>> print(s)           # print()函数输出：输出表达式的内容\nHello\n\n>>> x = 10 * 4; y = 200 * 200\n>>> s = 'x的值为: ' + repr(x) + ', y的值为:' + repr(y)  # repr()将值转为字符串\n>>> print(s)\nx的值为: 40, y的值为:40000\n>>> s = repr('hello\\n')   # repr()可以转义字符串中的特殊字符\n>>> print(s)\n'hello\\n'\n>>> repr((10,20,'Hello'))  # repr()的参数可以是任何对象\n\"(10, 20, 'Hello')\"\n>>> str(10)                   # str()将值转为字符串\n'10'\n>>> print(str('Hello\\n'))     # str()不可以转义字符串中的特殊字符\nHello\n>>> str((10,20,'Hello'))      # str()的参数可以是任何对象\n\"(10, 20, 'Hello')\"\n\n# 括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。\n>>> print('{}:{}'.format('2022','明天我想见到你'))\n2022:明天我想见到你\n# 括号中的数字用于指向传入对象在 format() 中的位置\n>>> print('{0}:{1}'.format('2022','明天我想见到你')) \n2022:明天我想见到你\n>>> print('{1}:{0}'.format('2022','明天我想见到你'))\n明天我想见到你:2022\n# 在 format() 中使用关键字参数\n>>> print('{year}:{text}'.format(year = '2022',text = '明天我想见到你'))  \n2022:明天我想见到你\n# 字段名后面使用冒号:跟着格式标识符——{name:.2f}。这就允许对值进行更好的格式化。 \n>>> print('常量PI保留2位小数为{pi:.2f}'.format(pi = 3.141592653))  # 格式化数字,f表示浮点数,可以使用小数点后跟位数表示保留几位小数；d表示整数\n常量PI保留2位小数为3.14\n# 字段名后面使用冒号:跟着一个整数——{name:10}。表示对从name的第一个字符开始，后面至少宽度为10。\n>>> print('我要离你远一点:{我:20}==>{你}'.format(你 = 'GoeGoodyLv', 我 = 'Jerry'))\n我要离你远一点:Jerry               ==>GoeGoodyLv\n```\n\n### 文件读写\n\n> + open() 将会返回一个 file 对象。基本语法格式为：\n>\n>   ```python\n>   open(filename, mode)\n>   ```\n>\n>   + filename：文件名。\n>   + mode：决文件打开模式。默认文件访问模式为只读(r)。建议都显式指明打开方式。\n>   \n> + 文件的相对路径为与代码文件的同级目录。\n\n#### File打开模式\n\n| 模式   | **描述**                                                     |\n| :----- | :----------------------------------------------------------- |\n| **r**  | **以只读方式打开文件。文件的指针将会放在文件的开头。文件必须存在。这是默认模式。** |\n| rb     | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。文件必须存在。 |\n| **r+** | **打开一个文件用于读写。文件指针将会放在文件的开头。文件必须存在。** |\n| rb+    | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。文件必须存在。 |\n| **w**  | **打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。** |\n| wb     | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| **w+** | **打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。** |\n| wb+    | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| **a**  | **打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。** |\n| ab     | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| **a+** | **打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。** |\n| ab+    | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204191028869.png)\n\n#### File方法\n\n1. `open()`\n   + 打开一个文件，并返回文件对象。\n   + 如果该文件无法被打开，会抛出 OSError。\n   + **使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。**\n   + 基本语法：`open(file, mode='r')`\n2. `f.read()`\n   + 读取一个文件的内容，调用 f.read(size), 这将读取大小为size的数据, 然后作为字符串或字节对象返回。\n   + size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。\n3. `f.readline()`\n   + 从文件中读取单独的一行。换行符为 '\\n'。\n   + f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。\n4. `f.readlines()`\n   + 返回该文件中包含的所有行。\n   + 如果设置可选参数 sizeint, 则读取指定长度的字节, 并且将这些字节按行分割。\n5. `f.write()`\n   + f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。\n   + 写入其他类型之前要使用str()转成字符串。\n6. `f.tell()`\n   + 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。\n7. `f.seek()`\n   + 设置文件指针的偏移量。\n   + 改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。\n   + from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。\n8. `f.flush()`\n   + 刷新缓冲区，将缓冲区中的数据立刻写入文件，同时清空缓冲区。不需要是被动的等待输出缓冲区写入。\n   + 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。\n9. `f.close()`\n   + 当处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源。\n   + 如果尝试再调用该文件，则会抛出异常。\n10. **`with`关键字**\n    + 在文件操作结束后, 它会帮我们正确的关闭文件，而不用手动关闭。\n    + `with` 语句用于异常处理，封装了 `try…except…finally` 编码范式，提高了易用性。\n    + 在处理文件对象时使用 `with` 关键字是一种很好的做法。\n    + 参考：[Python with 关键字 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python-with.html)\n\n```python\n# 写入文件\nfilename = 'd:/test.txt'\nf = open(filename,'w')   # 打开文件\nf.write(\"猪猪好棒!\\n猪猪天下第一棒!\\n\")  # 写入内容\nf.close()   #关闭文件\n\n# 读取文件\nf = open(filename,'r')\nstr = f.read()                 # 读取全部内容\nprint(str)\n\nprint(f.tell())                # 返回文件当前所处位置\nf.seek(0,0)                    # 将文件指针指向开头\nprint(f.tell())                # 返回文件当前所处位置\n\nstr = f.readline()             # 读取一行\nprint(str)\n\nf.seek(0,0)\nprint(f.readlines())\n\nf.close()\n\n# with关键字\nwith open(filename,'a+') as f:\n    f.write(\"猪猪好厉害!\\n\")\n    f.seek(0,0)\n    read_data = f.read()\n    print(read_data)\n\n\n```\n\n#### pickle模块\n\n> + Python的pickle模块实现了基本的数据序列和反序列化。\n> + 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。\n> + 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。\n> + 导入pickle模块：`import pickle`\n> + 基本接口：`pickle.dump(obj, file, [,protocol])`\n\n```python\nimport pickle\n\n# 使用pickle模块将数据对象保存到文件\ndata1 = {'a':[1,2,3,4],'b':('hello','world'),'c': None}\ndata2 = 'hello world'\n\nf = open('d:/data.pkl','wb')  # 二进制写入\n\npickle.dump(data1, f)\npickle.dump(data2, f)\nf.close()\n\n# 使用pickle模块从文件中重构python对象\npkl_file = open('d:/data.pkl', 'rb')\n\ndata3 = pickle.load(pkl_file)  # pickle.load(f)读取一行\nprint(data1)\n\ndata4 = pickle.load(pkl_file)\nprint(data2)\n\npkl_file.close()\n```\n\n## Python条件控制&循环语句\n\n### 条件控制\n\n> + <font color=#ff0000>**if, elif, else**</font>\n>\n> + ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202045696.jpeg)\n>\n> + 语句形式\n>\n>   + 每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。\n>   + 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n>\n>   ```python\n>   if condition_1:\n>       statement_block_1\n>   elif condition_2:\n>       statement_block_2\n>   else:\n>       statement_block_3\n>   ```\n>\n> + 不同数值类型的 true 和 false \n>\n> |  类型  |       False       |           True           |\n> | :----: | :---------------: | :----------------------: |\n> |  布尔  |  False(与0等价)   |      True(与1等价)       |\n> |  数值  |      0,  0.0      |        非零的数值        |\n> | 字符串 | '', \"\"(空字符串)  |        非空字符串        |\n> |  容器  | [], (), {}, set() | 至少有一个元素的容器对象 |\n> |  None  |       None        |        非None对象        |\n>\n> + 如果 if 语句中的条件过长，可以用接续符 `\\`来换行。\n\n### 循环语句\n\n> + 循环语句有 **for**和 **while**。\n>\n> + 控制结构图\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202101861.png)\n\n#### while循环\n\n+ 形式\n\n  ```python\n  while 判断条件(condition)：\n      执行语句(statements)……\n  ```\n\n+ 执行流程\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202103123.jpeg)\n\n+ 需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。\n\n+ 可以通过设置条件表达式永远不为 false 来实现无限循环。可以使用 **CTRL+C** 来退出当前的无限循环。无限循环在服务器上客户端的实时请求非常有用。\n\n+ 如果 while 后面的条件语句为 false 时，则执行 else 的语句块。\n\n  ```python\n  while <expr>:\n      <statement(s)>\n  else:\n      <additional_statement(s)>\n  ```\n\n#### for循环\n\n+ for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。\n\n+ 一般形式\n\n  ```python\n  for <variable> in <sequence>:\n      <statements>\n  else:\n      <statements>\n  ```\n\n+ 执行流程\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202107676.jpeg)\n\n+ break 语句用于跳出当前循环体；continue语句跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n+ range()函数，允许用户在给定范围内生成一系列数字。\n\n  + 语法结构\n\n  ```python\n  # start：表示从返回序列的起始编号，默认情况下从0开始\n  # stop：表示生成最多但不包括此数字的数字\n  # step：指的是序列中每个数字之间的差异，默认值为1\n  range(start, stop, step)  # 左闭右开\n  ```\n\n  ```python\n  for i in range(1, 10, 2):\n      print(i,end = ' ')\n  \n  '''输出\n  1 3 5 7 9\n  '''\n  ```\n\n+ 循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。\n\n+ pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。pass只是为了防止语法错误。\n\n\n## Python函数\n\n> + 函数是组织好的，可重复使用的，**用来实现单一，或相关联功能的代码段。**\n> + 函数能**提高应用的模块性，和代码的重复利用率**。\n> + 除了内置函数，还可以自己创建函数——自定义函数。\n> + 函数定义完成后，可以调用执行。\n\n### 自定义函数\n\n> + 函数代码块以 **def** 关键词开头，后接函数标识符名称和圆括号 **()**。\n>\n>   ```python\n>   def 函数名（参数列表）:\n>       函数体\n>   ```\n>\n> + 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n>\n> + 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。可以通过 `函数名.__doc__` 的方式来显示函数的说明文档\n>\n> + 函数内容以冒号 **:** 起始，并且缩进。\n>\n> + **return [表达式]** 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。Python 函数可以返回多个值，多个值以元组的方式返回\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204211408876.png)\n\n### 函数参数\n\n#### 参数传递\n\n> + 在 Python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的。\n> + 在 Python 中，strings, tuples, 和 numbers 是不可更改（**immutable**）的对象，而 list,dict 等则是可以修改（**mutable**）的对象。\n>   + 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。\n>   + 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n> + python 函数的参数传递（Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。）：\n>   + **不可变类型**：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。\n>   + **可变类型**：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。\n\n#### 参数类型\n\n> + 必需参数\n> + 关键字参数\n> + 默认参数\n> + 不定长参数\n\n1. 必需参数\n   + 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n2. 关键字参数\n   + 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n   + 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\n\n3. 默认参数\n   + 调用函数时，如果没有传递参数，则会使用默认参数。\n   + 默认参数必须放在最后面。\n4. 不定长参数\n   + 加了星号 `*` 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。\n   + 加了两个星号 `**` 的参数会以字典的形式导入。\n\n```python\n\ndef func(a, b, isAdd = False):     # 这里的a,b都是必需参数;isAdd为默认参数\n    '定义一个函数,实现加减法,isAdd控制进行加法还是减法,默认为减法'   # 函数体的第一行可以写函数说明\n    if(isAdd == False):\n        return a - b\n    else:\n        return a + b\n\nres1 = func(10, 5)           # 按照函数参数顺序传入必需参数\nres2 = func(b = 10, a = 5)   # 指定参数关键字传入\nres3 = func(a = 10, b = 5, isAdd = True)  # 修改默认参数,实现加法\nprint(res1)\nprint(res2)\nprint(res3)\n\n'''输出\n5\n-5\n15\n'''\n```\n\n```python\nprint('只有一个元组形式的变长参数')\ndef func1(*var_tuples):\n    print(var_tuples)\nfunc1(1,2,3)\n\nprint('一个必需参数和一个元组形式的变长参数')\ndef func2(m, *var_tuples):\n    print(m)\n    print(var_tuples)\nfunc2(1,2,3) \n\n\nprint('只有一个字典形式的变长参数')\ndef func3(**var_dicts):\n    print(var_dicts)\nfunc3(a = 1,b = 2,c = 3)   # 由于是字典形式,不需要传入关键字(也就是key)\n\nprint('一个必需参数和一个字典形式的变长参数')\ndef func4(m, **var_dicts):\n    print(m)\n    print(var_dicts)\nfunc4(1,a = 2,b = 3) \n\n'''输出\n只有一个元组形式的变长参数\n(1, 2, 3)\n一个必需参数和一个元组形式的变长参数\n1\n(2, 3)\n只有一个字典形式的变长参数\n{'a': 1, 'b': 2, 'c': 3}\n一个必需参数和一个字典形式的变长参数\n1\n{'a': 2, 'b': 3}\n'''\n```\n\n### 匿名函数\n\n> + 所谓匿名，意即不再使用 **def** 语句这样标准的形式定义一个函数。\n>\n> + Python 使用 **lambda表达式** 来创建匿名函数。\n>\n> + lambda语法\n>\n>   ```python\n>   lambda [arg1 [,arg2,.....argn]]:expression\n>   ```\n\n```python\nsum = lambda a, b: a + b\n\nsum(3, 5)  // # 8\n```\n\n## Python模块\n\n> + 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。\n>\n> + **import语句**\n>\n>   + 语法\n>\n>   ```python\n>   import module1[, module2[,... moduleN]\n>   ```\n>\n>   + 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n>   + 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。\n>   + 调用的时候：`模块名.函数名`\n>\n> + **from … import 语句**\n>\n>   + 语法\n>\n>   ```python\n>   from modname import name1[, name2[, ... nameN]]\n>   ```\n>\n>   + 从模块中导入一个指定的部分到当前命名空间中。\n>   + 调用的时候直接使用函数名\n>\n> + **from … import * 语句**\n>\n>   + 语法\n>\n>     ```python\n>     from modname import *\n>     ```\n>\n>   + 把一个模块的所有内容全都导入到当前的命名空间。\n>\n>   + 这种声明不推荐。\n\n### __name__属性\n\n> + <font color=#ff0000>`if __name__ == '__main__'`</font>\n> + 一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用`__name__`属性来使该程序块仅在该模块自身运行时执行。\n> + 每个模块都有一个`__name__`属性，当其值是`'__main__'`时，表明该模块自身在运行，否则是被引入。`__name__` 与 `__main__` 底下是双下划线。\n\n### dir() 函数\n\n> + 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:\n>\n>   ```python\n>   >>> import math\n>   >>> dir(math)\n>   ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp']\n>   ```\n>\n> + 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称。\n\n### 包\n\n> + 包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。\n>\n> + 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。\n>\n>   目录只有包含一个叫做 `__init__.py` 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。\n>\n>   最简单的情况，放一个空的 `:file:__init__.py`就可以了。\n\n## Python错误和异常\n\n> + Python 有两种错误很容易辨认：<font color=#ff0000>**语法错误和异常**</font>。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204231549773.webp)\n\n### 语法错误\n\n> + Python 的语法错误或者称之为解析错。\n\n### 异常\n\n> + 即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。\n\n  ```python\n  >>> 10 * (1/0)             # 0 不能作为除数，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in ?\n  ZeroDivisionError: division by zero\n  >>> 4 + spam*3             # spam 未定义，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in ?\n  NameError: name 'spam' is not defined\n  >>> '2' + 2               # int 不能与 str 相加，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n  TypeError: can only concatenate str (not \"int\") to str\n  ```\n\n#### assert（断言）\n\n+ **assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。**\n\n+ **断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况**，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。\n\n+ 语法格式：\n\n  ```python\n  assert expression[,args]   # args为可选参数\n  # 等价于\n  if not expression:\n      raise AssertionError[(args)]\n  ```\n\n```python\n>>> assert True     # 条件为 true 正常执行\n>>> assert False    # 条件为 false 触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError\n>>> assert 1==1    # 条件为 true 正常执行\n>>> assert 1==2    # 条件为 false 触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError\n\n>>> assert 1==2, '1 不等于 2'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError: 1 不等于 2\n```\n\n### 异常处理\n\n#### try/except\n\n+ 异常捕捉可以使用 `try/except` 语句。\n+ try 语句按照如下方式工作；\n  - 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。\n  - 如果没有异常发生，忽略 except 子句，try 子句执行后结束。\n  - 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。\n  - 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。\n+ 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。\n+ 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。\n+ 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。\n\n```python\n# 定义函数\ndef temp_convert(var):\n    try:\n        return int(var)\n    except (ValueError) as Argument:\n        print (\"参数没有包含数字\\n\", Argument)\n\n# 调用函数\ntemp_convert(\"xyz\");\n```\n\n#### try/except...else\n\n+ try/except语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。\n\n+ else 子句将在 try 子句没有发生任何异常的时候执行。\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204231626296.png)\n  \n+ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。\n\n+ 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。\n\n#### try-finally语句\n\n+ try-finally 语句无论是否发生异常都将执行最后的代码。\n+ ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204240928646.png)\n\n#### 抛出异常\n\n+ Python 使用 raise 语句抛出一个指定的异常。\n\n+ 语法格式：\n\n  ```python\n  raise [Exception[,args[,traceback]]]\n  ```\n\n#### 用户自定义异常\n\n+ 可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。\n\n## Python面向对象\n\n### 简介\n\n+ **类（Class）**：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n+ **方法**：类中定义的函数。\n+ **类变量**：类变量在整个实例化得到对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n+ **数据成员**：类变量或者实例变量用于处理类以及实例对象的相关的数据。\n+ **方法重写**：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法覆盖，也称方法重写。\n+ **局部变量**：定义在方法中的变量，只作用于当前所在函数。\n+ **实例变量**：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用self修饰的变量。实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。\n+ **继承**：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。\n+ **实例化**：创建一个类的实例，类的具体对象。\n+ **对象**：通过类定义的数据结构实例，对象包括两个数据成员（类变量和实例变量）和方法。\n\n### 类\n\n+ **类对象**支持两种操作：属性引用和实例化。\n+ 类属性与方法\n  + 私有属性：`__private_attrs`：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。\n  + 私有方法：`_private_method`：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。\n+ 访问类的属性和方法：`obj.name`。\n+ 类有一个名为 `__init__()` 的特殊方法（**构造方法**），该方法在类实例化时会自动调用。\n+ 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**, 按照惯例它的名称是 self（也可以是其他，但是注意要在第一个）。\n+ **在类的内部，使用 `def` 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 `self`, 且为第一个参数，self 代表的是类的实例。**\n+ 类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。\n+ 除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量。\n+ **Python3 中类的静态方法、普通方法、类方法**\n  + **静态方法**: 用 @staticmethod 装饰的不带 self 参数的方法叫做静态方法，类的静态方法可以没有参数，可以直接使用类名调用。\n  + **普通方法**: 默认有个self参数，且只能被对象调用。\n  + **类方法**: 默认有个 cls 参数，可以被类和对象调用，需要加上 @classmethod 装饰器。\n\n```python\n# 类定义\nclass people:\n    # 以下4个是类变量，一般通过类名调用\n    planet = '地球'          # 定义公有属性\n    __ancestors = '猿'         # 定义私有属性,私有属性在类外部无法直接进行访问\n\n    # 定义构造方法\n    def __init__(self,n,a):\n        # 以下4个是实例变量\n        self.name = n      # 公有实例属性\n        self.__age = a     # 私有实例属性\n    # 定义普通方法，对象调用\n    def speak(self):\n        type = '人类' # 这是一个局部变量\n        print(f\"{self.name}说: 我是{type}，来自{people.planet}；祖先是{people.__ancestors}。我今年{self.__age}岁。\")\n\n    # 静态方法，对象和类调用，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的\n    @staticmethod\n    def introduce_static():\n        print(\"这只是一段静态方法的示例\")\n\n    # 类方法，对象和类调用，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的\n    @classmethod\n    def introduce_class(cls):\n        print(\"这只是一段类方法的示例\", cls)\n        \nperson = people('张三', 20)  # 实例化类\nprint(f\"你可以从获取我的姓名：{person.name}\") # 公有属性可以从外部访问，私有属性不能从外部访问\nperson.speak()              # 调用普通公有方法\npeople.introduce_static()   # 调用静态方法\nperson.introduce_static()   # 调用静态方法\npeople.introduce_class()    # 调用类方法\nperson.introduce_class()    # 调用类方法\n```\n\n### 继承\n\n+ 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。\n+ 继承包括单继承和多继承。\n\n```python\n# 类定义\nclass people:\n    # 以下4个是类变量，一般通过类名调用\n    planet = '地球'          # 定义公有属性\n    __ancestors = '猿'         # 定义私有属性,私有属性在类外部无法直接进行访问\n\n    # 定义构造方法\n    def __init__(self,n,a):\n        # 以下4个是实例变量\n        self.name = n      # 公有实例属性\n        self.__age = a     # 私有实例属性\n    # 定义普通方法\n    def speak(self):\n        type = '人类' # 这是一个局部变量\n        print(f\"{self.name}说: 我是{type}，来自{people.planet}；祖先是{people.__ancestors}。我今年{self.__age}岁。\")\n\n# 单继承\nclass student(people):\n    university = 'SWJTU'\n\n    def __init__(self,n,a,g):\n        # 调用父类的构造方法\n        people.__init__(self,n,a)\n        self.grade = g\n    \n    # 方法重写\n    def speak(self):\n        people.speak(self) # 可以调用父类的方法\n        print(f\"{self.name}说：我就读于{student.university}，今年{self.grade}年级。\")\n\ns = student(\"张三\",20,\"大四\")\ns.speak()\n```\n\n### 运算符重载\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204282112187.png)\n\n## 练习\n\n### 2022.04.19\n\n1. 华氏温度转换为摄氏温度。提示：华氏温度到摄氏温度的转换公式为：$C=(F - 32) \\div 1.8$。\n\n2. 输入圆的半径计算计算周长和面积。\n\n3. 输入年份判断是不是闰年。\n\n   ```python\n   year = input('请输入年份:')\n   \n   year = int(year)\n   \n   if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n       print(f'{year}是闰年')\n   else:\n       print(f'{year}不是闰年')\n   ```\n\n### 2022.04.20\n\n1. [Python3 循环语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-loop.html)最后的练习题。\n\n2. 输入成绩，判断成绩等级。注：成绩范围0-100；[85,100]为优秀，[75,85)为良好，[60,75)为合格，(0,60)为不合格。\n\n   ```python\n   score = input(\"请输入成绩:\")\n   \n   score = int(score)\n   \n   if score < 0 or score > 100:\n       print(\"成绩不符合要求\")\n   elif score >= 85 and score <= 100:\n       print(\"成绩为优秀\")\n   elif score >= 75 and score < 85:\n       print(\"成绩为良好\")\n   elif score >= 60 and score < 75:\n       print(\"成绩为合格\")\n   else:\n       print(\"成绩不合格\")\n   ```\n\n   \n\n3. 实现九九乘法表。\n\n   ```python\n   for j in range(1,10):     \n       for i in range(1,10): \n           if(i <= j):       \n               s = i * j      \n               print(f'{i} * {j} = {s}',end = '\\t')\n       print()\n   ```\n\n4. 将一个整数倒序，如234变为432，不能使用库函数。\n\n### 2022.04.21\n\n1. 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\n\n   ```python\n   str = input(\"请输入字符串:\")\n   \n   print(str)\n   \n   i = 0\n   letter = 0  # 保存中英文字母的个数\n   space = 0\n   digit = 0\n   others = 0\n   \n   for temp in str:\n       if(temp.isalpha()):\n           letter += 1\n       elif(temp.isspace()):\n           space += 1\n       elif(temp.isdigit()):\n           digit += 1\n       else:\n           others += 1\n   else:\n       print(f\"中英文字母的个数:{letter}\\n空格个数:{space}\\n数字个数:{digit}\\n其它字符个数:{others}\")\n   ```\n\n   ```python\n   str = input(\"请输入字符串:\")\n   \n   print(str)\n   i = 0\n   letter = 0  # 保存中英文字母的个数\n   space = 0\n   digit = 0\n   others = 0\n   while(i < len(str)):\n       temp = str[i]\n       if(temp.isalpha()):\n           letter += 1\n       elif(temp.isspace()):\n           space += 1\n       elif(temp.isdigit()):\n           digit += 1\n       else:\n           others += 1\n       i += 1\n   else:\n       print(f\"中英文字母的个数:{letter}\\n空格个数:{space}\\n数字个数:{digit}\\n其它字符个数:{others}\")\n   ```\n\n   \n\n2. 给定一个数字列表，对其进行升序排序（冒泡排序）。\n\n### 2022.04.22\n\n1. 1到4能组成多少个互不相同且不重复数字的三位数？分别是？\n\n   ```python\n   for i in range(1,5):  #1\n       for j in range(1,5):   \n           for n in range(1,5):\n               if i != j and i != n and j != n:\n                   num = i*100 + j * 10 + n\n                   print(num)\n   ```\n\n2. 整数的阶乘（英语：factorial）是所有小于及等于该数的正整数的积，0的阶乘为1。即：n!=1×2×3×...×n。\n\n   ```python\n   n = input(\"请输入一个整数:\")\n   n = int(n)\n   num = 1\n   if n < 0:\n       print(\"n不能为负数\")\n   elif n == 0:\n       print(f'{n}的阶乘为{num}')\n   else:\n       for i in range(1,n+1): \n           num = i * num\n       print(f'{n}的阶乘为{num}')\n   ```\n\n## Reference\n\n1. [Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n","tags":["Python","Jupter NoteBook","Anaconda"],"categories":["学习笔记"]},{"title":"Python学习笔记(1)--基础语法","url":"/hexo-blog/2022/08/19/Python学习笔记(1)--基础语法/","content":"\n# Python学习笔记(1)——基础语法\n\n<!--start: 2022.04.17-->\n\n> 这里为Python3。笔记基于：[Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n## Python简介\n\n> + Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\n> + 目前为Python 的 3.0 版本，常被称为 Python 3000，或简称 Py3k。\n> + 跨平台。\n> + 解释性语言——无需编译。\n> + 交互式语言——直接在提示符>>>后执行代码。交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。\n> + 面向对象语言——一切皆可对象。\n\n## Python特点\n\n> + 简单易学。\n> + 免费开源。\n> + 一个广泛的标准库。\n> + 可移植。\n> + 可扩展。\n> + 可嵌入。\n> + GUI编程。\n\n## Python环境搭建\n\n> + 基于Windows系统\n\n### Anaconda安装\n\n> + Anaconda，中文大蟒蛇，是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。\n> + 官网：[Installing on Windows — Anaconda documentation](https://docs.anaconda.com/anaconda/install/windows/)。\n> + 参考\n>   + [Anaconda介绍、安装及使用教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32925500)\n>   + [基于Anaconda配置Python开发环境详解（1）anaconda配置python环境](https://blog.csdn.net/u013598963/article/details/120191604)\n>   + [基于Anaconda配置Python开发环境详解（2）conda基本命令](https://blog.csdn.net/u013598963/article/details/120240628)\n\n1. 下载安装包，图形化安装。\n\n2. 打开“Anaconda Prompt”。\n\n3. 切换conda源为国内镜像。\n\n   ```shell\n   conda config --get channels #查看conda当前源\n   ```\n\n   ```shell\n   # 切换为清华镜像，依次输入以下命令\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n   conda config --set show_channel_urls yes\n   ```\n\n4. 虚拟环境命令\n\n   > 安装/卸载包要切换到对应的虚拟环境下进行。\n\n   ```shell\n   # 创建虚拟环境python3，并安装python（不指定版本则安装最新版本）\n   conda create -n python3 python\n   # 激活名为python3的虚拟环境\n   conda activate python3\n   \n   # 其他命令\n   conda env list                    # 查看虚拟环境列表\n   \n   conda deactivate                  # 退出当前虚拟环境\n   conda remove -n python3 --all     # 删除虚拟环境python3\n   conda create -n python3_1 --clone python3 # 克隆虚拟环境python3到虚拟环境python3_1\n   conda list                        # 列举当前虚拟环境下安装的包\n   conda -h                          # 获取帮助\n   \n   conda install package_name        # 安装指定包\n   pip install package_name          # 当使用 conda install 无法进行安装时，可以使用pip进行安装。\n   \n   conda update package_name         # 更新指定包\n   conda update --all                # 更新全部包\n   \n   conda uninstall package_name      # 卸载指定包\n   conda remove package_name         # 也可以使用这个命令卸载\n   \n   conda search --full-name python   # 查找全名为“python”的包有哪些版本可供安装\n   ```\n\n### VS Code安装\n\n> + VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器，VSCode 开发环境非常简单易用。\n> + 官网：[Visual Studio Code - Code Editing. Redefined](https://code.visualstudio.com/)\n> + 下载软件包，一步步安装即可，安装过程注意安装路径设置、环境变量默认自动添加到系统中。参考：[VScode 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/vscode-tutorial.html)\n\n### VS Code使用\n\n1. 建立工作目录\n\n   > 1. 新建一个空文件夹VSCode_workspace，作为专门存放vscode代码文件的文件夹。\n   > 2. 在该文件夹下继续新建空文件夹Python，作为python编程的专用工作文件夹。\n   > 3. 打开VS Code，打开该文件夹。\n\n2. 安装插件“Python”（会自动安装Jupter、Pylance）。\n2. 安装ipykernel，使用**jupyter notebook**。jupyter notebook是一款开源的、在canvas上运行的python代码和展示markdown的项目。参考：[vscode写jupyter notebook - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/378378346)\n2. 在ipynb文件中编写代码。\n\n## Python基础语法\n\n+ **编码**\n\n  默认情况下，Python 3 源码文件以 **UTF-8** 编码，所有字符串都是 unicode 字符串。 \n\n+ **标识符**\n\n  + 首字母必须为**字母**或**下划线`_`**。\n  + 组成：字母、下划线、数字。\n  + 大小写敏感。\n  + Python3中，可以使用**中文**作为变量名，非 ASCII 标识符也是允许的了。\n\n+ **Python保留字**\n\n  + 保留字即关键字，我们不能把它们用作任何标识符名称。\n\n  + Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字。\n\n    ```python\n    import keyword\n    keyword.kwlist\n    ```\n\n+ **注释**\n\n  + 单行注释以`#`开头。\n\n  + 多行注释使用`'''`或`\"\"\"`。\n\n    ```python\n    # 单行注释\n    \n    '''\n    多行注释\n    '''\n    \n    \"\"\"\n    多行注释\n    \"\"\"\n    print (\"Hello, Python!\")\n    ```\n\n+ **行与缩进**\n\n  + Python使用缩进来表示代码块，而不需要像C/C++/Java那样使用大括号 **{}** 。\n\n  + 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。\n\n    ```python\n    if True:\n        print (\"Answer\")\n        print (\"True\")\n    else:\n        print (\"Answer\")\n      print (\"False\")    # 缩进不一致，会导致运行错误\n    ```\n\n+ **数字类型**\n\n  + **int**：整数。只有一种整数类型 int，表示为长整型\n  + **bool**：布尔型\n  + **float**：浮点数\n  + **complex**：复数\n\n+ **字符串**\n\n  + Python 中单引号 `'` 和双引号 `\"` 使用完全相同。\n  + 使用三引号(`'''` 或 `\"\"\"`)可以指定一个多行字符串。\n  + 转义符`\\`。\n  + 反斜杠可以用来转义，使用 `r` 可以让反斜杠不发生转义。 如 `r\"this is a line with \\n\"` 则 `\\n` 会显示，并不是换行。这里的 r 指 raw，即 raw string，会自动将反斜杠转义。\n  + 按字面意义级联字符串，如 `\"this \" \"is \" \"string\"`会被自动转换为 `this is string`。\n  + 字符串可以用 `+` 运算符连接在一起，用 `*` 运算符重复。\n  + Python 中的字符串有两种索引方式，从左往右以 `0` 开始，从右往左以 `-1` 开始。\n  + Python 中的字符串不能改变。\n  + Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n  + 字符串的截取的语法格式如下：**变量[头下标:尾下标:步长]**。\n\n  ```python\n  msg1=\"this \" \"is \" \"string\"\n  print(msg1)\n  \n  msg2=\"你\"+\"真\"+\"漂亮!\"\n  print(msg2)\n  print(msg2 * 3)\n  \n  msg3='123456789'\n  print(msg3)\n  print(msg3[0])\n  print(msg3[8:])\n  print(msg3[-1])\n  print(msg3[0:-1])\n  print(msg3[1:5:2])\n  \n  print('hello\\nPython')      # 使用反斜杠(\\)+n转义特殊字符\n  print(r'hello\\nPython')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n  \n  '''输出\n  this is string\n  你真漂亮!\n  你真漂亮!你真漂亮!你真漂亮!\n  123456789\n  1\n  9\n  9\n  12345678\n  24\n  hello\n  Python\n  hello\\nPython\n  '''\n  ```\n\n+ **空行**\n\n  + 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。\n  + 类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n  + 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n+ **同一行显示多条语句**\n\n  + Python 可以在同一行中使用多条语句，语句之间使用分号 `;` 分割。\n\n+ **多个语句构成代码组**\n\n  + 缩进相同的一组语句构成一个代码块，我们称之代码组。\n  + 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。\n  + 将首行及后面的代码组称为一个子句(clause)。\n\n+ **print输出**\n\n  + `print` 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=\"\"`\n\n    ```python\n    print(\"hello\",end=\"\")\n    print(\" world\")\n    print('hello Python')\n    ```\n\n+ **import 与 from...import**\n\n  + 在 Python 用 `import` 或者 `from...import` 来导入相应的模块。\n  + 将整个模块(somemodule)导入，格式为： `import somemodule`。\n  + 从某个模块中导入某个函数,格式为： `from somemodule import somefunction`。\n  + 从某个模块中导入多个函数,格式为： `from somemodule import firstfunc, secondfunc, thirdfunc`。\n  + 将某个模块中的全部函数导入，格式为： `from somemodule import *`。\n\n+ **变量与对象**\n\n  + 赋值操作，本质是创建引用。\n  + 变量是变量，对象是对象，当将某个对象赋值给某个变量时，可以认为是创建了变量对该对象的引用。\n  + 变量没有数据类型之说，只有对象有，即变量不是直接代表对象或对象占用的内存空间。\n  + Python中，变量无需提前声明，无需指定其数据类型，其表现完全是动态的，其所为的数据类型决定于当前该变量所引用的对象的数据类型。\n  + 所谓变量对对象的引用，本质是创建了变量指向对象内存空间的指针。\n  + 对象内存空间，一般最起码有类型和当前被引用次数这两个信息，类型记录了该对象的数据类型，被引用次数记录了该对象内存空间被变量引用的次数。\n  + 当某对象的被引用次数为0时，Python便会自动回收该对象内存空间。\n\n+ **命令行参数**\n\n  参考：[Python3 命令行参数 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-command-line-arguments.html)\n\n## Python数据类型\n\n> + Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n>\n> + 等号（=）用来给变量赋值。\n>\n> + 等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。\n>\n> + 多个变量赋值。\n>\n>   ```python\n>   a = b = c = 1\n>   \n>   a,b,c = 1,2,\"hello\"\n>   ```\n>\n> + Python3 的六个标准数据类型中：\n>\n>   - **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；\n>   - **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。\n\n### 标准数据类型\n\n#### Number（数字）\n\n> + Python3 支持 **int、float、bool、complex（复数）**。\n>\n> + 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n>\n> + 内置的 type() 函数可以用来查询变量所指的对象类型。\n>\n> + Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False\\==0会返回 True，但可以通过`is`来判断类型。\n>\n> + Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。\n>\n> + 可以通过`del`语句删除单个或多个对象。\n>\n>   ```python\n>   a,b = 10,20\n>   del a,b\n>   ```\n>\n> + 数值运算\n>\n>   ```python\n>   >>> 5 + 4  # 加法\n>   9\n>   >>> 4.3 - 2 # 减法\n>   2.3\n>   >>> 3 * 7  # 乘法\n>   21\n>   >>> 2 / 4  # 除法，得到一个浮点数\n>   0.5\n>   >>> 2 // 4 # 除法，得到一个整数\n>   0\n>   >>> 17 % 3 # 取余\n>   2\n>   >>> 2 ** 5 # 乘方\n>   32\n>   ```\n>\n> + Python可以同时为多个变量赋值，如a, b = 1, 2。\n>\n> + 一个变量可以通过赋值指向不同类型的对象。\n>\n> + **数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。**\n>\n> + 在混合计算时，Python会把整型转换成为浮点数。\n>\n> + Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\n#### String（字符串）\n\n> + Python中的字符串用单引号 **'** 或双引号 **\"** 括起来，同时使用反斜杠 `\\`转义特殊字符。\n>\n> + 索引值以 0 为开始值，-1 为从末尾的开始位置。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204171912742.png)\n>\n> + 加号 **+** 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。\n>\n> + 使用反斜杠` \\` 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 `r`，表示原始字符串。\n>\n> + 另外，反斜杠(\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 **\"\"\"...\"\"\"** 或者 **'''...'''** 跨越多行。\n>\n> + 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。\n>\n> + **与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。**\n\n#### List（列表）\n\n> + List（列表） 是 Python 中使用最频繁的数据类型。\n>\n> + 列表中元素的类型可以不相同，它支持**数字，字符串甚至可以包含列表**（所谓嵌套）。\n>\n> + 和字符串一样，列表同样可以被索引和截取（切片），列表被截取后返回一个包含所需元素的新列表。\n>\n> + **列表是写在方括号 [] 之间、用逗号分隔开的元素列表**。\n>\n> + 加号 **+** 是列表连接运算符，星号 ***** 是重复操作。\n>\n> + **与Python字符串不一样的是，列表中的元素是可以改变的。**\n>\n> + 切片。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204171931206.png)\n\n```python\nlist = ['Hello', 520, 3.14, 'Python']\nprint(list)\nprint(list[0])\nprint(list[0:4])\nprint(list * 2)\n\nlist[1:3] = [521,3.14159]\nprint(list[1:3])\n```\n\n#### Tuple（元组）\n\n> + 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。\n>\n> + 元组写在小括号 **()** 里，元素之间用逗号隔开。\n>\n> + 元组也可以被索引和切片，方法一样。\n>\n> + 注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n>\n>   ```python\n>   tup1 = ()    # 空元组\n>   tup2 = (20,) # 一个元素，需要在元素后添加逗号\n>   ```\n\n```python\ntup = (1,2,3,'Jerry')\nprint(tup)\n\ntup1 = ()    # 空元组\ntup2 = (20,) # 一个元素，需要在元素后添加逗号\nprint(tup2[0])\n```\n\n#### Set（集合）\n\n> + 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n> + 基本功能是进行成员关系测试和删除重复元素。\n> + 可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。\n\n```python\nsites = {'Google', 'Taobao', 'Google', 'Facebook', 'Zhihu', 'Baidu'}\n\nprint(sites)   # 输出集合，重复的元素被自动去掉\n\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)\nprint(b)\n\nprint(a - b)     # a 和 b 的差集\n\nprint(a | b)     # a 和 b 的并集\n\nprint(a & b)     # a 和 b 的交集\n\nprint(a ^ b)     # a 和 b 中不同时存在的元素\n\n'''输出\n{'Google', 'Facebook', 'Taobao', 'Baidu', 'Zhihu'}\n{'b', 'r', 'c', 'a', 'd'}\n{'l', 'c', 'm', 'z', 'a'}\n{'b', 'r', 'd'}\n{'l', 'b', 'r', 'c', 'm', 'z', 'a', 'd'}\n{'c', 'a'}\n{'m', 'l', 'b', 'r', 'z', 'd'}\n'''\n```\n\n\n\n#### Dictionary（字典）\n\n> + 列表是有序的对象集合，字典是无序的对象集合。\n> + 字典当中的元素是通过键来存取的，而不是通过偏移存取。\n> + **字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。**\n> + **在同一个字典中，键(key)必须是唯一的。**\n> + 键(key)必须使用不可变类型。\n\n```python\ndict1 = {\"name\":\"Jerry\",\"sex\":\"girl\",\"age\":18}            # 方式1\nprint(dict1)           # 输出完整的字典\nprint (dict1.keys())   # 输出所有键\nprint (dict1.values()) # 输出所有值\n\ndict1[\"班级\"] = \"广告一班\"                                 # 方式2\nprint(dict1[\"班级\"])\n\nprint(dict())\n\ndict2 = dict(first = 1, second = 2, third = 3)             # 方式3: 使用关键字参数创建字典\nprint(dict2)\n\ndict3 = dict([('first',1), ('second', 2), ('third', 3)])   # 方式4: 使用可迭代对象创建字典\nprint(dict3)\n\ndict4 = dict({'first':1, 'second':2, 'third':3})           # 方式5: 使用映射来创建字典\nprint(dict4)\n\n\ndict5 = dict(zip(['first','second','third'],[1,2,3]))      # 方式6: zip() 创建可迭代对象\nprint(dict5)\n\n'''输出\n{'name': 'Jerry', 'sex': 'girl', 'age': 18}\ndict_keys(['name', 'sex', 'age'])\ndict_values(['Jerry', 'girl', 18])\n广告一班\n{}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n'''\n```\n\n\n\n### 数据类型转换\n\n> + 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下只需要将数据类型作为函数名即可。\n> + Python 数据类型转换可以分为两种：\n>   + 隐式类型转换——自动完成。\n>   + 显示类型转换——需要使用类型函数类转换。\n\n#### 隐式类型转换\n\n较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。\n\n#### 显示类型转换\n\n| 函数       | 描述                                                      |\n| ---------- | --------------------------------------------------------- |\n| `int(x)`   | x转为int型                                                |\n| `float(x)` | x转为float型                                              |\n| `str(x)`   | x转为字符串                                               |\n| `list(s)`  | 将序列 s 转换为一个列表，s为字符串、元组                  |\n| `tuple(s)` | 将序列 s 转换为一个元组，s 可以为字符串、列表、字典、集合 |\n| `set(s)`   | 将序列 s 转换为一个可变集合                               |\n| `dict(d)`  | 创建一个字典。d 必须是一个 (key, value)元组序列。         |\n| `hex(x)`   | 将一个整数转换为一个十六进制字符串                        |\n| `oct(x)`   | 将一个整数转换为一个八进制字符串                          |\n\n## Python推导式\n\n> + Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。\n> + Python 支持各种数据结构的推导式：列表(list)推导式，字典(dict)推导式，集合(set)推导式，元组(tuple)推导式。\n\n### 列表推导式\n\n```python\n[表达式 for 变量 in 列表] \n[out_exp_res for out_exp in input_list]\n\n或者 \n\n[表达式 for 变量 in 列表 if 条件]\n[out_exp_res for out_exp in input_list if condition]\n```\n\n- out_exp_res：列表生成元素表达式，可以是有返回值的函数。\n- for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。\n- if condition：条件语句，可以过滤列表中不符合条件的值。\n\n```python\n# 计算 50 以内可以被 4 整除的整数：\nmultiples = [i for i in range(50) if i % 4 == 0]\nprint(multiples)\n\n'''输出\n[0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48]\n'''\n```\n\n### 元组推导式\n\n```python\n(expression for item in Sequence )\n或\n(expression for item in Sequence if conditional )\n```\n\n+ 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n+ 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 **()** 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**。\n+ 元组推导式返回的结果是一个生成器对象。\n\n```python\na = (x for x in range(50) if x % 4 == 0)\nprint(tuple(a))\n\n'''输出\n(0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48)\n'''\n```\n\n### 集合推导式\n\n```python\n{ expression for item in Sequence }\n或\n{ expression for item in Sequence if conditional }\n```\n\n```python\nset1 = {i for i in (1,2,3,4,4,5,11,12,13,14) if i < 10}\nprint(set1)\n\n'''输出\n{1, 2, 3, 4, 5}\n'''\n```\n\n### 字典推导式\n\n```python\n{ key_expr: value_expr for value in collection }\n\n或\n\n{ key_expr: value_expr for value in collection if condition }\n```\n\n```python\nlistdemo = ['Google','Baidu', 'Taobao']\n# 将列表中各字符串值为键，各字符串的长度为值，组成键值对\nnewdict = {key:len(key) for key in listdemo}\nprint(newdict)\n\n'''输出\n{'Google': 6, 'Baidu': 5, 'Taobao': 6}\n'''\n```\n\n<!--end: 2022.04.17-->\n\n<!--start: 2022.04.18-->\n\n## Python解释器\n\n> + 暂不讨论。参考：[Python3 解释器 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-interpreter.html)\n\n## Python运算符\n\n+ Python中没有自增/自减运算符。\n\n### 算术运算符\n\n| 运算符 | 描述             |\n| ------ | ---------------- |\n| `+`    | 加法             |\n| `-`    | 减法             |\n| `*`    | 乘法             |\n| `/`    | 除法             |\n| `%`    | 取模             |\n| `**`   | 幂               |\n| `//`   | 取整除，向下取整 |\n\n+ **//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n\n  ```python\n  >>> 7//2\n  3\n  >>> 7.0//2\n  3.0\n  >>> 7//2.0\n  3.0\n  ```\n\n### 比较运算符\n\n+ Pyhton3 已不支持 <> 运算符，可以使用 != 代替。\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `==`   | 等于     |\n| `!=`   | 不等于   |\n| `<`    | 小于     |\n| `>`    | 大于     |\n| `<=`   | 小于等于 |\n| `>=`   | 大于等于 |\n\n### 赋值运算符\n\n| 运算符 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| `=`    | 普通赋值运算符                                               |\n| `+=`   | 加法赋值                                                     |\n| `-=`   | 减法赋值                                                     |\n| `*=`   | 乘法赋值                                                     |\n| `/=`   | 除法赋值                                                     |\n| `%=`   | 取模赋值                                                     |\n| `**=`  | 幂赋值                                                       |\n| `//=`  | 取整除赋值                                                   |\n| `:=`   | 海象运算符，可在表达式内部为变量赋值。**Python3.8 版本新增运算符**。 |\n\n### 位运算符\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `&`    | 按位与   |\n| \\|     | 按位或   |\n| `^`    | 按位异或 |\n| `~`    | 按位取反 |\n| `<<`   | 左移     |\n| `>>`   | 右移     |\n\n### 逻辑运算符\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `and`  | 布尔“与” |\n| `or`   | 布尔“或” |\n| `not`  | 布尔“非” |\n\n+ Python 中的 and 从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值；\n+ or 也是从左到有计算表达式，返回第一个为真的值；\n+ **其中数字 0 是假，其他都是真；字符 \"\" 是假，其他都是真。**\n\n### 成员运算符\n\n| 运算符   | 描述                                                    |\n| -------- | ------------------------------------------------------- |\n| `in`     | 如果在指定的序列中找到值返回 True，否则返回 False。     |\n| `not in` | 如果在指定的序列中没有找到值返回 True，否则返回 False。 |\n\n### 身份运算符\n\n+ 身份运算符用于比较两个对象的存储单元。\n\n+ `is` 与 `==` 区别：`is` 用于判断两个变量引用对象是否为同一个， `==` 用于判断引用变量的值是否相等。\n\n+ **设`a=5;b=5`。在交互式环境中，解释器会有一个<font color=#ff0000>小整数池</font>的概念，会把[-5，256]间的数预先创建好，而当a和b超过这个范围的时候，两个变量就会指向不同的对象了。**\n\n  ```python\n  >>> a=5\n  >>> b=5\n  >>> id(a);id(b)\n  2890240977328\n  2890240977328\n  >>> a=1000\n  >>> b=1000\n  >>> id(a);id(b)\n  2890278823312\n  2890278824144\n  ```\n\n+ 在一些发行版的Python IDE中，例如Pycharm、Anaconda等，会维护一个<font color=#ff0000>大整数池</font>，它的范围比原生的解释器会大很多，这是一种优化机制。\n\n| 运算符   | 描述                                        |\n| -------- | ------------------------------------------- |\n| `is`     | is 是判断两个标识符是不是引用自一个对象     |\n| `is not` | is not 是判断两个标识符是不是引用自不同对象 |\n\n### 运算符优先级\n\n| 运算符                   | 描述                                                   |\n| :----------------------- | :----------------------------------------------------- |\n| **                       | 指数 (最高优先级)                                      |\n| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |\n| * / % //                 | 乘，除，求余数和取整除                                 |\n| + -                      | 加法减法                                               |\n| >> <<                    | 右移，左移运算符                                       |\n| &                        | 位 'AND'                                               |\n| ^ \\|                     | 位运算符                                               |\n| <= < > >=                | 比较运算符                                             |\n| == !=                    | 等于运算符                                             |\n| = %= /= //= -= += *= **= | 赋值运算符                                             |\n| is is not                | 身份运算符                                             |\n| in not in                | 成员运算符                                             |\n| not and or               | 逻辑运算符                                             |\n\n## Python数字类型\n\n> + Python 数字数据类型用于存储数值。\n>\n> + 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。\n>\n> + 可以使用del语句删除一些数字对象的引用。\n>\n> + Python 支持三种不同的数值类型：\n>\n>   + **整型(int)** - 通常被称为是整型或整数，是正或负整数，不带小数点。布尔(bool)是整型的子类型。\n>\n>   + **浮点型(float)** - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）\n>\n>   + **复数( (complex))** - 复数由实数部分和虚数部分构成，可以用a + bj，或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n>\n>   + 可以使用二进制，八进制，十六进制来代表整数。\n>\n>     ```python\n>     >>> 0b1111\n>     15\n>     >>> 0o17\n>     15\n>     >>> oxf   # 使用十六进制表示时，字母要大些\n>     Traceback (most recent call last):\n>       File \"<stdin>\", line 1, in <module>\n>     NameError: name 'oxf' is not defined\n>     >>> 0xF\n>     15\n>     ```\n>\n> + 类型转换\n>\n>   - **int(x)** 将x转换为一个整数。\n>   - **float(x)** 将x转换到一个浮点数。\n>   - **complex(x)** 将x转换到一个复数，实数部分为 x，虚数部分为 0。\n>   - **complex(x, y)** 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n>\n> + 数值运算\n>\n>   + 在交互模式中，最后被输出的表达式结果被赋值给变量` _` ，该变量为只读变量（这里是”应当“，也就是没有必要最好不要改，际情况是你也可以对**_** 赋值，**_=10** 是没有毛病的，但这样的结果会导致你在之后调用 **_** 的时候全部变成了10，除非你 **del _**。）。\n>\n>     ```python\n>     >>> a=100.5\n>     >>> a\n>     100.5\n>     >>> a+_   # 变量 _ 的值为上次输出的100.5\n>     201.0\n>     >>> _ * 2 # 变量 _ 的值为上次输出的201.0\n>     402.0\n>     ```\n\n### 数学常量\n\n| 常量 | 描述                                  |\n| :--- | :------------------------------------ |\n| pi   | 数学常量 pi（圆周率，一般以π来表示）  |\n| e    | 数学常量 e，e即自然常数（自然常数）。 |\n\n+ 需要导入math模块。\n\n```python\n>>> import math\n>>> math.pi\n3.141592653589793\n>>> math.e\n2.718281828459045\n```\n\n### 数学函数\n\n+ <font color=#ff0000>**除非对精确度没什么要求，否则尽量避开用round()函数。**</font>\n+ round()函数使用的事实上不是简单的四舍五入。而是**“4舍6入5看齐,奇进偶不进”**。\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [abs(x)](https://www.runoob.com/python3/python3-func-number-abs.html) | 内置函数，返回x的绝对值，对数字类型都有效                    |\n| [math.ceil(x)](https://www.runoob.com/python3/python3-func-number-ceil.html) | math模块中的函数，向上取整                                   |\n| [math.exp(x)](https://www.runoob.com/python3/python3-func-number-exp.html) | 返回e的x次幂($e^x$)                                          |\n| [math.fabs(x)](https://www.runoob.com/python3/python3-func-number-fabs.html) | 返回x的绝对值，在math模块中定义，只对浮点型跟整型数值有效    |\n| [math.floor(x)](https://www.runoob.com/python3/python3-func-number-floor.html) | 向下取整，如math.floor(4.9)返回 4                            |\n| [math.log(x)](https://www.runoob.com/python3/python3-func-number-log.html) | 返回以e为底的x的对数，如math.log(math.e)返回1.0              |\n| [math.log10(x)](https://www.runoob.com/python3/python3-func-number-log10.html) | 返回以10为基数的x的对数，如math.log10(100)返回 2.0           |\n| [max(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-max.html) | 返回给定参数的最大值，参数可以为序列。                       |\n| [min(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-min.html) | 返回给定参数的最小值，参数可以为序列。                       |\n| [math.modf(x)](https://www.runoob.com/python3/python3-func-number-modf.html) | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |\n| [math.pow(x, y)](https://www.runoob.com/python3/python3-func-number-pow.html) | x**y 运算后的值。                                            |\n| [round(x [,n])](https://www.runoob.com/python3/python3-func-number-round.html) | 返回浮点数 x 的“4舍6入5看齐,奇进偶不进”值，如给出 n 值，则代表舍入到小数点后的位数。**其实准确的说是保留值将保留到离上一位更近的一端。** |\n| [math.sqrt(x)](https://www.runoob.com/python3/python3-func-number-sqrt.html) | 返回数字x的平方根。                                          |\n\n```python\n# math.modf(x)返回的是一个小数部分和整数部分组成的元组\n>>> import math\n>>> math.modf(100.12)\n(0.12000000000000455, 100.0)\n\n# 按我们的想法返回结果应该是 2.68，可结果却是 2.67\n# 这跟浮点数的精度有关。在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。\n# 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。\n# 那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。\n# 因此除非对精确度没什么要求，否则尽量避开用round()函数。\n>>> round(2.675,2)   \n2.67\n```\n\n### 随机数函数\n\n+ 需要导入random模块`import random`\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [random.choice(seq)](https://www.runoob.com/python3/python3-func-number-choice.html) | 从序列的元素中随机挑选一个元素，seq可以是一个列表，元组或字符串 |\n| [random.randrange ([start,\\] stop [,step])](https://www.runoob.com/python3/python3-func-number-randrange.html) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |\n| [random.random()](https://www.runoob.com/python3/python3-func-number-random.html) | 随机生成一个实数，它在[0,1)范围内。                          |\n| [random.seed([x])](https://www.runoob.com/python3/python3-func-number-seed.html) | 改变随机数生成器的种子seed。                                 |\n| [random.shuffle(lst)](https://www.runoob.com/python3/python3-func-number-shuffle.html) | 将序列的所有元素随机排序(打乱)                               |\n| [random.uniform(x, y)](https://www.runoob.com/python3/python3-func-number-uniform.html) | 随机生成一个实数，它在[x,y]范围内。                          |\n\n```python\n>>> import random\n>>> random.random()*10\n3.8944816055307485\n>>> random.choice(range(100))\n9\n>>> random.choice(range(100))\n67\n>>> random.uniform(1,50)\n31.493576711508624\n```\n\n### 三角函数\n\n+ 需要导入math模块`import math`。\n\n| 函数                                                         | 描述                                                       |\n| :----------------------------------------------------------- | :--------------------------------------------------------- |\n| [acos(x)](https://www.runoob.com/python3/python3-func-number-acos.html) | 返回x的反余弦弧度值。x是[-1,1]之间的数值，超出范围会出错。 |\n| [asin(x)](https://www.runoob.com/python3/python3-func-number-asin.html) | 返回x的反正弦弧度值。x是[-1,1]之间的数值，超出范围会出错。 |\n| [atan(x)](https://www.runoob.com/python3/python3-func-number-atan.html) | 返回x的反正切弧度值。                                      |\n| [atan2(y, x)](https://www.runoob.com/python3/python3-func-number-atan2.html) | 返回给定的 X 及 Y 坐标值的反正切值。                       |\n| **[cos(x)](https://www.runoob.com/python3/python3-func-number-cos.html)** | **返回x的弧度的余弦值。**                                  |\n| [hypot(x, y)](https://www.runoob.com/python3/python3-func-number-hypot.html) | 返回欧几里德范数 sqrt(x*x + y*y)。                         |\n| **[sin(x)](https://www.runoob.com/python3/python3-func-number-sin.html)** | **返回的x弧度的正弦值。**                                  |\n| **[tan(x)](https://www.runoob.com/python3/python3-func-number-tan.html)** | **返回x弧度的正切值。**                                    |\n| **[degrees(x)](https://www.runoob.com/python3/python3-func-number-degrees.html)** | **将弧度转换为角度，如degrees(math.pi/2) ， 返回90.0**     |\n| **[radians(x)](https://www.runoob.com/python3/python3-func-number-radians.html)** | **将角度转换为弧度**                                       |\n\n## Python字符串\n\n+ 在Python3中，所有的字符串都是Unicode字符串。\n\n### 转义字符\n\n+ 在需要在字符中使用特殊字符时，python 用反斜杠 `\\` 转义字符。\n\n| 转义字符      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| `\\`(在行尾时) | 续行符                                                       |\n| `\\\\`          | 反斜杠符号                                                   |\n| `\\'`          | 单引号                                                       |\n| `\\\"`          | 双引号                                                       |\n| `\\a`          | 响铃                                                         |\n| `\\b`          | 退格(Backspace)                                              |\n| `\\000`        | 空                                                           |\n| **`\\n`**      | **换行**                                                     |\n| `\\v`          | 纵向制表符                                                   |\n| `\\t`          | 横向制表符                                                   |\n| `\\r`          | 回车，将 **\\r** 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 **\\r** 后面的内容完全替换完成。 |\n| `\\f`          | 换页                                                         |\n| `\\yyy`        | 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。           |\n| `\\xyy`        | 十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行    |\n| `\\other`      | 其它的字符以普通格式输出                                     |\n\n```python\n>>> print('\\a')\n\n>>> print('\\'')\n'\n>>> print('hello \\n world')\nhello\n world\n>>> print('hello \\t world')\nhello    world\n>>> print('hello world\\r world')\n worldworld\n```\n\n### 字符串运算符\n\n| 操作符 | 描述                                                         |\n| :----- | :----------------------------------------------------------- |\n| +      | 字符串连接                                                   |\n| *      | 重复输出字符串                                               |\n| []     | 通过索引获取字符串中字符                                     |\n| [ : ]  | 截取字符串中的一部分，遵循**左闭右开**原则，str[0:2] 是不包含第 3 个字符的。 |\n| in     | 成员运算符 - 如果字符串中包含给定的字符返回 True             |\n| not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True           |\n| r/R    | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 **r**（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 |\n| %      | 格式字符串，同C 语言一样的语法                               |\n\n### 字符串格式化\n\n| 符  号 | 描述                                 |\n| :----- | :----------------------------------- |\n| %c     | 格式化字符及其ASCII码                |\n| %s     | 格式化字符串                         |\n| %d     | 格式化整数                           |\n| %u     | 格式化无符号整型                     |\n| %o     | 格式化无符号八进制数                 |\n| %x     | 格式化无符号十六进制数               |\n| %X     | 格式化无符号十六进制数（大写）       |\n| %f     | 格式化浮点数字，可指定小数点后的精度 |\n| %e     | 用科学计数法格式化浮点数             |\n| %E     | 作用同%e，用科学计数法格式化浮点数   |\n| %g     | %f和%e的简写                         |\n| %G     | %f 和 %E 的简写                      |\n| %p     | 用十六进制数格式化变量的地址         |\n\n+ Python3.6之后新增了<font color=#ff0000>**f-string**</font>，称为**字面量格式化字符串**，是新的格式化字符串的语法。\n\n  + **f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。**\n  + 用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。\n\n  ```python\n  >>> name = 'jerry'\n  >>> print('hello %s'%name)  # %格式化\n  hello jerry\n  >>> print(f'hello {name}')  # f格式化\n  hello jerry\n  >>> print(f'{1+5}')\n  6\n  ```\n\n### 三引号\n\n+ 允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。\n\n### 字符串内建函数\n\n1. `capitalize()`：将字符串的第一个字母变成大写，其他字母变小写。\n   + 首字符会转换成大写，其余字符会转换成小写。\n   + 首字符如果是非字母，首字母不会转换成大写，会转换成小写。\n\n```python\n>>> str = 'hello World'\n>>> print(str)\nhello World\n>>> print(str.capitalize())\nHello world\n```\n\n2. `center(width,fillchar)`：返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。\n   + **如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充。**\n   + **fillchar 只能是单个字符**。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.center(4))   # width 小于字符串宽度,直接返回\nsouthwest jiaotong university\n>>> print(str.center(40))  # fillchar 默认是空格\n     southwest jiaotong university\n>>> print(str.center(40,'*'))\n*****southwest jiaotong university******\n```\n\n3. `count(sub,start=0,end=len(str))`：返回 sub在 str 里面出现的次数，如果 start 或者 end 指定则返回指定范围内 sub 出现的次数。\n   + sub -- 搜索的子字符串。\n   + start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。\n   + end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.count('o'))\n3\n>>> print(str.count('o',0,10))\n1\n>>> print(str.count('ou'))\n1\n```\n\n2. `endswith(suffix,beg=0,end=len(str))`：检查字符串是否以 suffix结束，如果beg 或者 end 指定则检查指定的范围内是否以 suffix结束，如果是，返回 True,否则返回 False。\n   + suffix -- 该参数可以是一个字符串或者是一个元素。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.endswith('!'))\nFalse\n>>> print(str.endswith('y'))\nTrue\n```\n\n3. `find(sub,beg=0,end=len(str))`：检测 sub是否包含在字符串str中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.find('sou'))\n0\n>>> print(str.find('un'))\n19\n>>> print(str.find('uo'))\n-1\n>>> print(str.find('u'))\n2\n>>> print(str.rfind('u'))  # rfind() 从右边开始查找\n19\n```\n\n4. `index(sub,beg=0,end=len(str))`：跟find()方法一样，只不过如果str不在字符串中会报一个异常。这里同样有`rindex()`。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.index('sou'))\n0\n>>> print(str.index('un'))\n19\n>>> print(str.index('uo'))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: substring not found\n```\n\n5. 判断字符串包含的具体内容\n\n   + `isalnum()`：检测字符串是否由**字母或汉字或数字**组成。如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。\n\n   ```python\n   >>> str1 = 'whoamI'\n   >>> str2 = 'who am I 2022'\n   >>> print(str1.isalnum())\n   True\n   >>> print(str2.isalnum())\n   False\n   >>> str3 = 'whoam我2022'\n   >>> print(str3.isalnum())\n   True\n   ```\n\n   + `isalpha()`：检测字符串是否只由**字母或汉字**组成。如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。\n\n   ```python\n   >>> str1 = '我是谁'\n   >>> str2 = '我是2022'\n   >>> print(str1.isalpha());print(str2.isalpha())\n   True\n   False\n   ```\n\n   + `isdigit()`：检测字符串是否**由数字[0-9]**组成。如果字符串只包含数字则返回 True 否则返回 False。\n\n   + `isdecimal()`：检查字符串是否**只包含十进制字符**。\n\n   + `isnumeric()`：检测字符串是否只由数字字符组成。如果字符串中只包含数字字符，则返回 True，否则返回 False。\n\n     + 数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。\n     + s.isdigit、isdecimal 和 s.isnumeric 区别\n\n     > **isdigit()**\n     >\n     > **True**: Unicode数字，byte数字（单字节），全角数字（双字节）\n     >\n     > **False**: 汉字数字，罗马数字，小数\n     >\n     > **Error**: 无\n     >\n     > **isdecimal()**\n     >\n     > **True**: Unicode数字，，全角数字（双字节）\n     >\n     > **False**: 罗马数字，汉字数字，小数\n     >\n     > **Error**: byte数字（单字节）\n     >\n     > **isnumeric()**\n     >\n     > **True**: Unicode 数字，全角数字（双字节），汉字数字\n     >\n     > **False**: 小数，罗马数字\n     >\n     > **Error**: byte数字（单字节）\n\n   ```python\n   >>> num = '1'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   True\n   True\n   True\n   >>> num = 'IV'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   False\n   False\n   False\n   >>> num = '拾四'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   False\n   False\n   True\n   ```\n\n   + `islower()`：检测字符串**不包含大写字母（至少包含一个小写字母）**。如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。\n\n   ```python\n   >>> str1 = '2022';str2 = '我是dvvf';str3 = 'Hello'\n   >>> print(str1.islower());print(str2.islower());print(str3.islower())\n   False  # 纯数字，返回False\n   True   # 含有字母且不包含大写字母\n   False\n   >>> str4 = '我是';print(str4.islower()) # 不包含字母，返回False\n   False\n   >>> str5 = '2022dc';print(str5.islower())\n   True\n   ```\n\n   + `isupper()`：检测字符串**不包含小写字母（至少包含一个大写字母）**。如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。\n\n   ```python\n   >>> str1 = '2022';str2 = '我是dvvf';str3 = 'Hello'\n   >>> print(str1.isupper());print(str2.isupper());print(str3.isupper())\n   False\n   False\n   False\n   >>> print('HELLO'.isupper())\n   True\n   ```\n\n   + `isspace()`：检测字符串是否只由空白字符组成。如果字符串中只包含空白，则返回 True，否则返回 False。\n     + 空白符包含：空格、制表符(\\t)、换行(\\n)、回车(\\r）等。\n     + 空串不算空白符。\n\n   ```python\n   >>> print('\\t\\r\\n '.isspace())\n   True\n   >>> print(''.isspace())\n   False\n   ```\n\n   + `istitle()`：检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。如果字符串是标题化的(见 title())则返回 True，否则返回 False。\n\n   ```python\n   >>> print('Hello World!'.istitle());print('Hello world!'.istitle())\n   True\n   False\n   ```\n\n6. `join(seq)`：以指定字符串作为分隔符，将 seq 中所有的元素(**字符串表示**)合并为一个新的字符串。\n\n```python\n>>> seq = ['h','e','l','l','o']\n>>> s = ''\n>>> print(s.join(seq))\nhello\n>>> print('-'.join(seq))\nh-e-l-l-o\n```\n\n7. `len(str)`：返回对象（字符、列表、元组等）长度或项目个数。\n\n```python\n>>> len('hello')\n5\n>>> len([1,2,3,4,'hello'])\n5\n>>> len((1,2,3,4,'hello'))\n5\n```\n\n8. `lower()`和`upper()`：转换字符串中大写字符为小写；小写为大写。\n\n```python\n>>> str = 'Hello'\n>>> str.lower();str.upper()\n'hello'\n'HELLO'\n```\n\n9. `swapcase()`：将字符串中大写转换为小写，小写转换为大写\n\n```python\n>>> str = 'Southwest Jiaotong University'\n>>> str.swapcase()\n'sOUTHWEST jIAOTONG uNIVERSITY'\n```\n\n10. `max(str)`和`min(str)`：返回字符串 str 中最大的字符；最小的字符。max(str)、min(str) 方法不只判断字母，会判断字符串中的所有字符，按照字符在 unicode 中的编码值来决定大小。\n\n```python\n>>> str = 'Hello'\n>>> max(str);min(str)\n'o'\n'H'\n```\n\n11. `replace(old,new[,max])`：把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。\n\n```python\n>>> old = 'hello'*3;new = 'HELLO'\n>>> old.replace('hello',new)\n'HELLOHELLOHELLO'\n>>> old.replace('hello',new,2)\n'HELLOHELLOhello'\n```\n\n12. `split(splitStr,num=str.count(str))`：指定分隔符splitStr对字符串str进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。\n\n+ str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。\n+ num -- 分割次数。默认为 -1, 即分隔所有。\n+ 返回分割后的字符串列表。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> str.split()\n['southwest', 'jiaotong', 'university']\n>>> str.split('i',1)\n['southwest j', 'aotong university']\n```\n\n13. `title()`：所有单词都是以大写开始，其余字母均为小写（标题化字符串）。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> str.title()\n'Southwest Jiaotong University'\n```\n\n## Python列表\n\n> + 序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。\n>\n> + 列表都可以进行的操作包括索引，切片，加，乘，检查成员。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323062.png)\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323482.png)\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323075.png)\n>\n> + 通过`append()`添加元素，通过`del`语句删除元素。\n>\n> + 可以拼接`+`和重复`*`。\n>\n> + 可以嵌套。\n\n### 列表函数\n\n| 函数                                                         | 描述               |\n| :----------------------------------------------------------- | :----------------- |\n| [len(list)](https://www.runoob.com/python3/python3-att-list-len.html) | 列表元素个数       |\n| [max(list)](https://www.runoob.com/python3/python3-att-list-max.html) | 返回列表元素最大值 |\n| [min(list)](https://www.runoob.com/python3/python3-att-list-min.html) | 返回列表元素最小值 |\n| [list(seq)](https://www.runoob.com/python3/python3-att-list-list.html) | 将元组转换为列表   |\n\n### 列表方法\n\n| 序号                                                         | 方法                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [list.append(obj)](https://www.runoob.com/python3/python3-att-list-append.html) | 在列表末尾添加新的对象                                       |\n| [list.count(obj)](https://www.runoob.com/python3/python3-att-list-count.html) | 统计某个元素在列表中出现的次数                               |\n| [list.extend(seq)](https://www.runoob.com/python3/python3-att-list-extend.html) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |\n| [list.index(obj)](https://www.runoob.com/python3/python3-att-list-index.html) | 从列表中找出某个值第一个匹配项的索引位置                     |\n| [list.insert(index, obj)](https://www.runoob.com/python3/python3-att-list-insert.html) | 将对象插入列表                                               |\n| [list.pop([index=-1])](https://www.runoob.com/python3/python3-att-list-pop.html) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |\n| [list.remove(obj)](https://www.runoob.com/python3/python3-att-list-remove.html) | 移除列表中某个值的第一个匹配项                               |\n| [list.reverse()](https://www.runoob.com/python3/python3-att-list-reverse.html) | 反向列表中元素                                               |\n| [list.sort( key=None, reverse=False)](https://www.runoob.com/python3/python3-att-list-sort.html) | 对原列表进行排序                                             |\n| [list.clear()](https://www.runoob.com/python3/python3-att-list-clear.html) | 清空列表                                                     |\n| [list.copy()](https://www.runoob.com/python3/python3-att-list-copy.html) | 复制列表                                                     |\n\n## Python元组\n\n> + Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n> + 元组使用小括号 **( )**，列表使用方括号 **[ ]**。\n\n## Python字典\n\n> + 字典是另一种可变容器模型，且可存储任意类型对象。\n> + **注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict。**\n> + ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182351656.png)\n> + 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字。\n\n### 字典函数\n\n| 函数             | 描述                                               |\n| :--------------- | :------------------------------------------------- |\n| `len(dict) `     | 计算字典元素个数，即键的总数。                     |\n| `str(dict)`      | 输出字典，可以打印的字符串表示。                   |\n| `type(variable)` | 返回输入的变量类型，如果变量是字典就返回字典类型。 |\n\n### 字典方法\n\n| 序号 | 函数及描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [dict.clear()](https://www.runoob.com/python3/python3-att-dictionary-clear.html) 删除字典内所有元素 |\n| 2    | [dict.copy()](https://www.runoob.com/python3/python3-att-dictionary-copy.html) 返回一个字典的浅复制 |\n| 3    | [dict.fromkeys()](https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html) 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |\n| 4    | [dict.get(key, default=None)](https://www.runoob.com/python3/python3-att-dictionary-get.html) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 |\n| 5    | [key in dict](https://www.runoob.com/python3/python3-att-dictionary-in.html) 如果键在字典dict里返回true，否则返回false |\n| 6    | [dict.items()](https://www.runoob.com/python3/python3-att-dictionary-items.html) 以列表返回一个视图对象 |\n| 7    | [dict.keys()](https://www.runoob.com/python3/python3-att-dictionary-keys.html) 返回一个视图对象 |\n| 8    | [dict.setdefault(key, default=None)](https://www.runoob.com/python3/python3-att-dictionary-setdefault.html) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |\n| 9    | [dict.update(dict2)](https://www.runoob.com/python3/python3-att-dictionary-update.html) 把字典dict2的键/值对更新到dict里 |\n| 10   | [dict.values()](https://www.runoob.com/python3/python3-att-dictionary-values.html) 返回一个视图对象 |\n| 11   | [pop(key[,default])](https://www.runoob.com/python3/python3-att-dictionary-pop.html) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |\n| 12   | [popitem()](https://www.runoob.com/python3/python3-att-dictionary-popitem.html) 返回并删除字典中的最后一对键和值。 |\n\n## Python集合\n\n> + 集合（set）是一个无序的不重复元素序列。\n> + 可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。\n\n### 集合内置方法\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [add()](https://www.runoob.com/python3/ref-set-add.html)     | 为集合添加元素                                               |\n| [clear()](https://www.runoob.com/python3/ref-set-clear.html) | 移除集合中的所有元素                                         |\n| [copy()](https://www.runoob.com/python3/ref-set-copy.html)   | 拷贝一个集合                                                 |\n| [difference()](https://www.runoob.com/python3/ref-set-difference.html) | 返回多个集合的差集                                           |\n| [difference_update()](https://www.runoob.com/python3/ref-set-difference_update.html) | 移除集合中的元素，该元素在指定的集合也存在。                 |\n| [discard()](https://www.runoob.com/python3/ref-set-discard.html) | 删除集合中指定的元素                                         |\n| [intersection()](https://www.runoob.com/python3/ref-set-intersection.html) | 返回集合的交集                                               |\n| [intersection_update()](https://www.runoob.com/python3/ref-set-intersection_update.html) | 返回集合的交集。                                             |\n| [isdisjoint()](https://www.runoob.com/python3/ref-set-isdisjoint.html) | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 |\n| [issubset()](https://www.runoob.com/python3/ref-set-issubset.html) | 判断指定集合是否为该方法参数集合的子集。                     |\n| [issuperset()](https://www.runoob.com/python3/ref-set-issuperset.html) | 判断该方法的参数集合是否为指定集合的子集                     |\n| [pop()](https://www.runoob.com/python3/ref-set-pop.html)     | 随机移除元素                                                 |\n| [remove()](https://www.runoob.com/python3/ref-set-remove.html) | 移除指定元素                                                 |\n| [symmetric_difference()](https://www.runoob.com/python3/ref-set-symmetric_difference.html) | 返回两个集合中不重复的元素集合。                             |\n| [symmetric_difference_update()](https://www.runoob.com/python3/ref-set-symmetric_difference_update.html) | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |\n| [union()](https://www.runoob.com/python3/ref-set-union.html) | 返回两个集合的并集                                           |\n| [update()](https://www.runoob.com/python3/ref-set-update.html) | 给集合添加元素                                               |\n\n<!--start: 2022.04.18-->\n\n## Reference\n\n1. [Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n","tags":["Python","Jupter NoteBook","Anaconda"],"categories":["学习笔记"]},{"title":"PicGo+Gitee搭建图床","url":"/hexo-blog/2022/08/19/PicGo+Gitee搭建图床/","content":"\n\n\n# ~~PicGo+Gitee搭建图床~~\n\n> 这里主要用于Typora上传图片。**2022.5.23：Gitee已经废了，现在用阿里云OSS，还是自己控制的图床安心！**\n\n## 1. 在Gitee创建图床仓库\n\n> 仓库需要设置成公开，否则无法查看图片。\n\n## 2. 生成私人令牌\n\n> 设置->私人令牌->生成心令牌\n\n![image-20220312190756949](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312190756949.png)\n\n> 输入密码后保存生成的令牌。\n\n## 3. 下载PicGo并安装\n\n[PicGo](https://picgo.github.io/PicGo-Doc/zh/)\n\n## 4. 安装插件`github-plus`\n\n> 支持设置图床到gitee。\n\n![image-20220312185418404](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312185418404.png)\n\n## 5. 配置PicGo\n\n![image-20220312191408653](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312191408653.png)\n\n> 可设置为默认图床。\n\n## 7. 配置Typora\n\n> 打开Typora，文件->偏好设置->图像\n\n![image-20220312194344043](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203121943121.png)\n\n","tags":["Gitee","PicGo"],"categories":["教程"]},{"title":"C语言踩坑记录","url":"/hexo-blog/2022/08/19/C语言踩坑记录/","content":"\n# C语言踩坑记录\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2022-04-14 -->\n> 第一次提交：指针使用错误；内存泄漏\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 不同类型的指针不能进行强转\n\n> 错误实例：`int*`转成`double*`。\n\n```c\n#include <stdio.h>\n\nvoid display(double *array, int length)\n{\n    for (int i = 0; i < length; i++)\n    {\n        printf(\"%f \", array[i]);\n    }\n    printf(\"\\n\");\n}\nint main()\n{\n    int array[] = {1, 2, 3, 4, 5, 6, 7};\n    //error: expected 'double *' but argument is of type 'int *'\n    display(array, 7);\n\n    return 0;\n}\n```\n\n## 内存分配与释放\n\n### 错误实例\n\n> + **只管申请分配内存，没有释放，造成内存泄漏！**\n> + **只管申请分配内存（就默认申请分配成功），没有考虑对内存分配失败的异常进行处理！**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5;\n    int col = 10;\n    \n    //只申请分配了内存，没有释放\n    arrays = (int **)malloc(sizeof(int *) * row);\n    for (int i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        for (int j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\n### 正确实例\n\n> + **分配了就要释放。**\n> + **既然是申请，就要处理申请失败的异常情况。**\n\n```c\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-14\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-14\n * @Description: C语言内存分配与释放\n */\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5, col = 10;\n    int i, j;\n\n    //分配内存\n    arrays = (int **)malloc(sizeof(int *) * row);\n    if (arrays == NULL) //内存分配失败直接返回\n    {\n        printf(\"memory allocation failure!\\n\");\n        return -1;\n    }\n    for (i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        if (arrays[i] == NULL) //内存分配失败直接返回\n        {\n            printf(\"memory allocation failure!\\n\");\n            return -1;\n        }\n        for (j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //释放内存\n    for (i = 0; i < row; i++)\n    {\n        free(arrays[i]);\n    }\n    free(arrays);\n\n    return 0;\n}\n\n```\n\n> + 一定确保所有的内存都进行了释放。\n\n```c\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-14\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-14\n * @Description: C语言内存分配与释放\n */\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5, col = 10;\n    int i, j;\n\n    //分配内存\n    arrays = (int **)malloc(sizeof(int *) * row);\n    if (arrays == NULL) //内存分配失败直接返回\n    {\n        printf(\"memory allocation failure!\\n\");\n        return -1;\n    }\n    for (i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        if (arrays[i] == NULL) //内存分配失败直接返回\n        {\n            printf(\"memory allocation failure!\\n\");\n            return -1;\n        }\n        for (j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //假设需要将二维数组的第一行删除\n    free(arrays[0]);              //重要:先将第一行的内存释放\n    for (i = 0; i < row - 1; i++) //将每行依次往前移\n    {\n        arrays[i] = arrays[i + 1]; //这里是将arrays[i]指向 arrays[i + 1]所指向的地址\n    }\n    row--;\n\n    printf(\"row 1 is deleted,arrays:\\n\");\n    for (i = 0; i < row; i++)\n    {\n        for (j = 0; j < col; j++)\n        {\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //释放内存\n    for (i = 0; i < row; i++)\n    {\n        free(arrays[i]);\n    }\n    free(arrays);\n\n    return 0;\n}\n\n```\n\n","tags":["C","踩坑记录"],"categories":["bug日常"]},{"title":"Hexo+Gitee搭建个人博客","url":"/hexo-blog/2022/08/19/Hexo+Gitee搭建个人博客/","content":"\n# Hexo+Gitee搭建个人博客\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.03.29 -->\n>\n> 更新：侧边栏添加一言API\n> <!-- endtimeline -->\n>\n> <!-- timeline 2022.03.14 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n<!--start: 2022.03.12-->\n\n## 工具准备\n\n### Gitee：国内的github\n\n> 1. 拥有gitee账号。\n> 2. 在本地已配置过用户名和密码。\n> 3. 进行实名认证（开通Pages服务要求）。\n\n### git：开源的分布式版本控制系统。\n\n> 略。\n\n### Typora：markdown文本编辑器\n\n> 略。\n\n### node.js：运行在服务端的 JavaScript\n\n#### node.js更新\n\n1. 已安装`node.js`，进行更新到最新稳定版。\n\n2. window下下载最新版本覆盖安装。[Node.js (nodejs.org)](https://nodejs.org/zh-cn/)\n\n3. 查看版本。\n\n   ```shell\n   #检查 node.js\n   node -v\n   #检查 npm\n   npm -v\n   ```\n\n#### cnpm安装\n\n1. cnpm为cnpm在国内的镜像。\n\n2. 安装命令。\n\n   ```shell\n   npm install -g cnpm --registry=https://registry.npm.taobao.org\n   ```\n\n3. 检查 cnpm 是否安装成功：`cnpm -v`。\n\n### hexo：快速、简洁且高效的博客框架\n\n1. [Hexo](https://hexo.io/zh-cn/)\n2. 打开命令行，输入以下命令。\n\n```shell\ncnpm install -g hexo-cli\n```\n\nwindow下可能出现：\n\n```shell\nError: EPERM: operation not permitted, mkdir 'C:\\Program Files\\nodejs\\node_modules\\hexo-cli_tmp'\n```\n\n原因是**node目录权限不够**。这是需要授予node目录**完全控制**权限。\n\n1. 查看是否安装成功。\n\n   ```shell\n   hexo -v\n   ```\n\n## 博客安装\n\n### hexo安装\n\n[建站 | Hexo](https://hexo.io/zh-cn/docs/setup)\n\n1. 本地建立文件夹。\n\n![image-20220312124109724](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124109724.png)\n\n2. 进入这个文件夹，右键打开 Git Bash Here。\n\n3. 输入以下命令**初始化博客**，等待下载完成。**这里也需要注意，需要拥有对文件夹的完全控制权限。**\n\n   ```shell\n   hexo init\n   ```\n\n   ![image-20220312124405530](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124405530.png)\n\n   > 然后输入命令: npm install\n\n4. 运行博客。\n\n   ```shell\n   hexo s\n   ```\n\n   ![image-20220312124956438](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124956438.png)\n\n5. 在浏览器输入localhost:4000查看。\n\n6. hexo常用命令，在建立的博客根目录git Bash下运行。\n\n   ```shell\n   # 本地启动博客\n   hexo s\n   #ctrl+c 停止\n   \n   # 新建博客文章\n   hexo new \"标题\"\n   \n   # 清除博客缓存\n   #一般在切换博客主题，或者博客效果与预期不一致时执行该命令\n   hexo clean\n   \n   # md 文件生成静态页面\n   #一般在使用 hexo clean 命令后使用\n   hexo g\n   \n   ```\n\n### 主题配置\n\n> 这里极力推荐[Butterfly - A Simple and Card UI Design theme for Hexo](https://butterfly.js.org/)。安装和配置过程都有详细教程！\n\n### 博客配置\n\n> .config.yml下配置。\n\n1. 网站参数配置\n\n> 参考 [配置 | Hexo](https://hexo.io/zh-cn/docs/configuration)\n\n![image-20220314143021617](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203141430702.png)\n\n2. 网址参数配置\n\n> 参见《博客部署》设置远程仓库。\n\n## 博客部署\n\n### 登录码云，新建仓库\n\n> 仓库名与本地博客文件夹名保持一致。\n\n### 安装git插件\n\n> 在博客根目录下右键 GitBash 打开，输入以下内容，等待下载完成。\n\n```shell\ncnpm install --save hexo-deployer-git\n```\n\n![image-20220312130217832](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312130217832.png)\n\n### 设置远程仓库\n\n1. **打开 `_config.yml`。**\n\n   ![image-20220312130849683](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312130849683.png)\n\n   2. **设置`URL`**\n\n      ![image-20220312131855803](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312131855803.png)\n\n   3. **设置仓库地址**\n\n      > 这里使用的是https方式，每次上传需要输入用户名和密码。因此也推荐SSH方式。\n      \n      ![image-20220312132339987](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312132339987.png)\n\n### 部署到远端\n\n> 在博客根目录下右键 GitBash 打开，输入命令。\n>\n> 过程中需要输入码云的用户名和密码。\n\n```shell\nhexo d\n```\n\n![image-20220312133603132](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312133603132.png)\n\n### 开启码云的静态页面服务\n\n> 进入码云新建的仓库，开启 `Gitee Pages`服务。\n\n> 注：开启该服务需要实名认证。因此可以提前一天提交实名认证申请。\n\n![image-20220314092949975](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140929168.png)\n\n> 等待部署\n\n![image-20220314095042212](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140950279.png)\n\n## 博客流程\n\n### 写博客\n\n> 1. 博客根目录下，打开git Bash。\n> 2. 执行 `hexo new \"title\"`，title为md文件名。这种创建方式会使用</scaffolds/post.md>下的模板来创建，可以设置一些默认的Front-matter。\n> 3. 使用 typora 编辑并保存。\n>    + 关于**Front-matter**。参见[Butterfly 安裝文檔(二) 主題頁面 | Butterfly](https://butterfly.js.org/posts/dc584b87/)。\n>    + 关于上传图片.参见博客-[PicGo+Gitee搭建图床 | JoeGoodyLv](https://guojin_lv.gitee.io/hexo-blogs/2022/03/12/PicGo+Gitee搭建图床/)。\n\n### 清除缓存&更新渲染\n\n> 1. 执行 `hexo clean`清除缓存。\n> 2. 执行`hexo g`重新渲染静态界面\n> 2. `hexo s` 打开本地界面\n\n### 推送到码云\n\n> 执行`hexo d`。\n\n### 更新码云的静态界面\n\n![image-20220314095654318](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140956387.png)\n\n","tags":["Gitee","Hexo"],"categories":["教程"]},{"url":"/hexo-blog/2022/08/19/C++学习笔记(1)/","content":"title: C++学习笔记(1)\ndescription: 学习笔记之《21天学通C++(第8版)》Siddhartha Rao著。\ncategories: 学习笔记\ncover: https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg\ntags: \n\n- C-plus-plus\n- STL\n\n# C++学习笔记(1)\n\n> 《21天学通C++(第8版)》Siddhartha Rao著\n\n<!--start: 2022.03.06-->\n\n## auto\n\n1. **auto**自动推断类型（C++11新增）\n\n   ```cpp\n   //使用auto必须进行初始化\n   auto largeNumber = 25000000000000; //编译器根据初始值来确定合适的值，这里应该为long long\n   ```\n\n2. auto迭代\n\n   ```cpp\n   int a[] = {1,2,3,4,5};\n   for(auto temp : a)\n   {\n      cout<<temp<<endl;\n   }\n   \n   //auto& 可以修改数组a的值\n   for(auto& temp : a)\n   {\n       temp++;\n       cout<<temp<<endl;\n   }\n   ```\n\n   \n\n## const; constexpr\n\n1. 如果变量的值不应该被改变，就应该将其声明为常量。\n\n   ```cpp\n   const double PI = 3.1415926;\n   \n   constexpr double GetPi(){ return 22.0/7;} //使用constexpr声明常量表达式\n   \n   enum CardinalDirections\n   {\n       North,\n       South,\n       East,\n       West\n   };\n   \n   //不要使用#define定义常量，该方法已被摒弃\n   ```\n\n**不要使用#define定义常量，该方法已被摒弃。**\n\n## 动态数组\n\nstd::vector\n\n## C++字符串\n\n1. 避免C风格字符串：以'\\0'作为终止空字符。\n2. 使用std:string，包含`#include<string>`\n\n## 内联函数\n\n1. 当**函数非常简单，且需要降低开销**的时候，可以声明为内联函数。\n\n## 指针\n\n1. 指针是存储内存地址的变量。\n\n   ```cpp\n   int *p = NULL;//初始化，未初始化的指针包含的值是垃圾值（随机的），可能导致问题（非法访问）。\n   ```\n\n2. 使用引用运算符`&`获取变量的地址。\n\n3. 解除引用运算符`*`访问指向地址所存储的值。\n\n4. const修饰指针\n\n   + 修饰 **指针包含的地址为常量**，无法修改，但可修改指针指向的数据。\n\n     ```cpp\n     int daysInMonth = 30;\n     int* const pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//OK!\n     int daysInLUnarMonth = 28;\n     \n     pDaysMonth = &daysInLUnarMonth;//Not OK!\n     ```\n\n     \n\n   + 修饰 **指针指向的数据为常量**，不能修改，但可以修改指针包含的地址。\n\n     ```cpp\n     int daysInMonth = 30;\n     const int* pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//Not OK!\n     int daysInLUnarMonth = 28;\n     \n     pDaysMonth = &daysInLUnarMonth;//OK!\n     \n     int* newMonth = pDaysMonth;//Not OK!\n     ```\n\n   + 修饰 **指针包含的地址以及它指向的值都是常量**，不能修改。\n\n     ```cpp\n     int daysInMonth = 30;\n     const int* const pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//Not OK!\n     int daysInLUnarMonth = 28;\n     pDaysMonth = &daysInLUnarMonth;//Not OK!\n     ```\n\n5. 数组可赋给指针。\n\n6. 使用指针常见错误：\n\n   + 内存泄漏\n   + 指针指向无用的内存单元：未初始化\n\n## new(std::nothrow)\n\n1. **new**(std::**nothrow**) 顾名思义，即不抛出异常，**当**new**一个对象失败时，默认设置该对象为NULL**，这样可以方便的通过if(p ** NULL) 来判断**new**操作是否成功。\n2. 普通的**new**操作，如果分配内存失败则会抛出异常，虽然后面一般也会写上if(p ** NULL) 但是实际上是自欺欺人，因为如果分配成功，p肯定不为NULL；而如果分配失败，则程序会抛出异常，if语句根本执行不到。\n3. 因此，建议在c++代码中，凡是涉及到**new**操作，都采用**new**(std::**nothrow**)，然后if(p**NULL)的方式进行判断\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint* points = new(nothrow) int[10];\n\tif(points)\n\t{\n\t\tcout<<\"Memory allocation successed. Ending program\"<<endl;\n\t\tdelete[] points;\n\t}\t\n\telse{\n\t\tcout<<\"Memory allocation failed. Ending program\"<<endl;\n\t}\n   return 0;\n}\n```\n\n## 引用\n\n1. 引用是相应变量的别名。\n\n   ```cpp\n   int flag = 30;\n   int& temp = flag;\n   ```\n\n2. const修饰引用：禁止通过引用修改它所指向变量的值。\n\n3. **引用**向函数传递参数**的优点之一：可避免将形参赋值给形参，从而极大提高性能。\n\n   ```cpp\n   #include <iostream>\n   using namespace std;\n   \n   //如果函数接收非常大的对象，则按值传递的开销将非常大，通过使用引用，可极大地提高函数调用的效率。别忘了将const用于引用参数，除非函数需要将结果储存于参数中。\n   void GetSquare(const int& number, int& result)\n   {\n   \tresult = number*number;\n   }\n   \n   int main()\n   {\n   \tint number = 0;\n   \tcin >> number;\n   \t\n   \tint square = 0;\n   \t\n   \tGetSquare(number,square);\n   \t\n   \tcout<<number<<\"^2 = \"<<square<<endl;\n   \t\n      return 0;\n   }\n   ```\n\n\n<!--end: 2022.03.06-->\n\n<!--start: 2022.03.07-->\n\n## 类和对象\n\n### 拷贝构造函数\n\n```markdown\n什么是浅拷贝？只有普通变量初始化的拷贝构造函数就浅拷贝。咋算普通变量？如int,char, string…不涉及指针变量。可以直接使用默认拷贝构造函数。\n\n什么是深拷贝？不用默认拷贝构造函数，自己显式定义一个拷贝构造函数，并且在其内部再次分配动态内存，这就是深拷贝。总的来说，就是类中涉及到指针变量，需要在拷贝构造函数内部申请一遍。\n\n使用浅拷贝还是深拷贝，最直接判断方式是看一下类中有没有指针变量。\n\n```\n\n1. **浅拷贝**：如果类中含有指针变量，导致多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 深浅拷贝操作\n\nclass Person\n{\npublic:\n    // 无参构造函数\n    Person()\n    {\n        cout << \"Person的构造函数调用\" << endl;\n    }\n    // 有参构造函数\n    Person(int a, int h)\n    {\n        m_Age = a;\n        m_Height = new int(h);\n        cout << \"Person的有参构造函数调用\" << endl;\n    }\n    // 析构造函数\n    ~Person()\n    {\n        // 将堆区开辟的空间释放掉\n        if(m_Height != NULL)\n        {\n            delete m_Height;\n            m_Height = NULL;    // 防止野指针出现\n        }\n        cout << \"Person的析构造函数调用\" << endl;\n    }\n\n    // 自己实现拷贝构造函数，解决浅拷贝带来的问题\n    //务必将接受源对象的参数声明为const引用\n    Person(const Person &p)\n    {\n        cout << \"Person拷贝造函数调用\" << endl;\n        m_Age = p.m_Age;\n        // m_Height = p.m_Height;   // 编译器默认实现就是这行代码(浅拷贝)\n        // 深拷贝操作\n        m_Height = new int(*p.m_Height);\n    }\n\n    int m_Age;  // 年龄\n    int *m_Height; // 身高\n};\n\nvoid test01()\n{\n    Person p1(18, 160);\n    cout << \"Person的年龄：\" << p1.m_Age << \"身高为：\" << *p1.m_Height << endl;\n\n    Person p2(p1);  // 执行来浅拷贝操作（调用默认的拷贝函数）\n    cout << \"P2的年龄：\" << p1.m_Age << \"身高为：\" << *p2.m_Height << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    /* code */\n    test01();\n\n    return 0;\n}\n```\n\n![](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202205231058265.jpg)\n\n### 单例类\n\n[28.C++- 单例类模板(详解) - 诺谦 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lifexy/p/8810877.html)\n\n### explicit\n\n1. explicit关键字的作用就是防止类构造函数的隐式自动转换.\n2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.\n3. explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。\n4. **google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。**所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。\n5. effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。\n\n## 继承（inheritance）\n\n1. is-a：公有继承\n\n   子类、子类的对象可以访问基类的public成员。\n\n2. has-a：\n\n   + 保护继承\n\n     子类可以访问基类的public和protect方法，但子类的对象不能访问基类的public成员。\n\n   + 私有继承\n\n     子类、子类的对象不能访问基类的public成员。\n\n3. 使用final禁止继承（C++11）\n\n## 多态（polymorphism）\n\n### 使用虚函数实现多态\n\n1. 对于将被派生类覆盖的基类方法，务必将其声明为虚函数。\n\n2. **对基类析构函数，务必提供一个虚析构函数。**\n\n### 纯虚函数\n\n+ 纯虚函数导致类变成抽象基类，且在派生类中必须提供虚函数的实现。\n+ 抽象基类无法被实例化。\n\n```cpp\n//抽象基类（ABC）\nclass AbstractBase\n{\npublic:\n    virtual void DoSomeThing() = 0; //纯虚函数\n};\n//上述声明告诉编译器，AbstractBase的派生类必须实现方法DoSomeThing()；\nclass Derived: public AbstractBase\n{\npublic:\n    void DoSomeThing()\n    {\n        cout<<\"Implemented virtual function\"<<endl;\n    }\n};\n```\n\n### 虚继承\n\n1. 如果派生类可能被用作基类，派生它 最好使用关键字virtual：\n\n   ```cpp\n   class Derived1 : public virtual Base\n   {\n       \n   };\n   class Derived2 : public virtual Base\n   {\n       \n   };\n   //并且使用关键字final禁止将SubDerived作为基类\n   class SubDerived final: public Derived1, public Derived2\n   {\n       \n   };\n   ```\n\n   在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性。这种二义性被称为**菱形问题**（Diamond Problem）。\n\n### override(C++11)\n\n在派生类中声明要覆盖基类函数的函数时，务必使用override。\n\noverride提供了一种强大的途径，让程序员明确地表达对基类的虚函数进行覆盖的意图，进而让编译器做如下检查：\n\n+ 基类函数是否是虚函数？\n+ 基类中相应虚函数的特征标识是否与派生类中被声明为override的函数完全相同？\n\n```cpp\nclass Base ｛\nvirtual void f();\n};\n\nclass Derived : public Base {\nvoid f() override; // 表示派生类重写基类虚函数f\nvoid F() override;//错误：函数F没有重写基类任何虚函数\n};\n```\n\n+ overide作用：在派生类中提醒自己要重写这个同参数函数，不写则报错。\n\n## 运算符\n\n1. 理论上来说，前缀运算符优于后缀运算符。`++value优于value++`。\n2. 对于有原始指针的类，务必实现拷贝构造函数和重载赋值运算符。 \n\n### 运算符重载\n\n```cpp\nreturn_type operator operator_symbol(...parameter list...)\n```\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass Box\n{\n    double length;  //长度\n    double width;   //宽度\n    double height;  //高度\npublic:\n    Box(){}\n    Box(double length,double width, double height):length(length),width(width),height(height){}\n    ~Box(){}\n    void print(void)\n    {\n        cout<<length<<\",\"<<width<<\",\"<<height<<endl;\n    }\n    \n    //重载 + 运算符，  实现Box相加\n    Box operator + (const Box& b)\n    {\n        Box box;\n        box.length = this->length + b.length;\n        box.width = this->width + b.width;\n        box.height = this->height + b.height;\n        return box;\n    }\n    \n    //重载前缀运算符 ++\n    Box operator ++ ()\n    {\n        ++this->length;\n        ++this->width;\n        ++this->height;\n        return *this;\n    }\n    \n    //重载后缀运算符 --\n    //注意，int 在 括号内是为了向编译器说明这是一个后缀形式，而不是表示整数。只是为了区分前置后置\n    Box operator -- (int)  //加上int \n    {\n        //保存原始值\n        Box temp = *this; //隐式调用转换函数\n        //Box temp(*this); //调用默认拷贝构造函数\n        //Box temp(length,width,height);\n        --this->length;\n        --this->width;\n        --this->height;\n        return temp; //返回原始值\n    }\n    \n    /*在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。习惯上人们是使用 cin>> 和 cout<< 的，得使用友元函数来重载运算符，如果使用成员函数来重载会出现 d1<<cout; 这种不自然的代码。\n    */\n    //相当于在整个全局声明了一个重载运算符。当重载的运算符函数是全局函数时，需要在类中将该函数声明为友元\n    //重载 >>\n    friend istream& operator >> (istream& input, Box& b)\n    {\n        input >> b.length >> b.width >> b.height;\n        return input;\n    }\n    \n    //重载 <<\n    friend ostream& operator << (ostream& output,const Box& b)\n    {\n        output<<b.length<<\",\"<<b.width<<\",\"<<b.height;\n        return output;\n    }\n};\n\nint main()\n{\n    Box box1(5.0,6.0,7.0);\n    Box box2(8.0,9.0,10.0);\n    Box box3 = box1 + box2;\n    box3.print();  //13,15,17\n    \n    Box ox4 = ++box3;\n    box4.print(); //14,16,18\n    \n    Box box5 = box3--;\n    box5.print(); //14,16,18\n    \n    box3.print(); //13,15,17\n    \n    Box box6;\n    cin >> box6;\n    cout <<box6<<endl;\n    return 0;\n}\n```\n\n## C++类型转换运算符\n\n`destination_type result = cast_operator<destination_type> (object_to_cast)`\n\n### static_cast\n\n+ 用于在相关类型的指针之间转换。\n\n```cpp\nDerived objDerived1 = new Derived();\nBase* objBase = &objDerived1;  //OK！向上转换，无需显式转换\n\nDerived* objDerived2 = objBase;//Error! 向下转换，需要显式转换\n\n//OK!\nDerived* objDerived2 = static_cast<Derived*>objBase; \n```\n\n```cpp\n//static_cast只验证指针类型是否相关，而不执行任何运行阶段的检查。\nBase* objBase = new Base();\nDerived* objDer = static_cast<Derived*>objBase;//Not Error！但有可能导致意外结果。\n```\n\n+ 将原本隐式的标准数据类型的类型转换 转换为  显式。\n\n### dynamic_cast\n\n+ 与static_cast相反，dynamic_cast在运行阶段执行转换，可检查dynamic_cast操作的结果，以判断类型转换是否成功。\n\n  ```cpp\n  Base* objBase = new Derived();\n  \n  Derived* objDer = dynamic_cast<Derived*>(objBase);\n  \n  //务必检查dynamic_cast的返回值，看它是否有效。如果返回值为NULL，说明转换失败。\n  if(objDer)\n  {\n      objDer->CallDerivedFunction();\n  }\n  ```\n\n  \n\n+ 这种在运行阶段识别对象类型的机制称为 **运行阶段类型识别**（runtime type identification, **RTTI**）\n\n### reinterpret_cast\n\n+ 强制转换。\n+ 应尽量避免使用reinterpret_cast。\n\n### const_cast\n\n+ 让程序员能够关闭对象的访问限制符const。\n\n  ```cpp\n  \n  //DisplayMembers（）本应该为const的，但没有这样定义。并且类SomeClass属于第三方库，无法对其进行修改。\n  void DisplayAllData(const SomClass& object)  //显然 这里使用const是应该的\n  {\n      object.DisplayMembers();//编译错误\n      //原因：使用const引用调用non-const的成员。\n  }\n  \n  void DisplayAllData(const SomClass& object)\n  {\n      SomeClass& refData = const_cast<SomeClass&>(object);\n      object.DisplayMembers();//OK!\n  }\n  ```\n\n+ 非必要不使用const_cast来调用非const函数。这样导致的结果不可预料！\n\n### 除dynamic_cast外的类型转换都是可以避免的；应尽量避免使用类型转换。\n\n<!--end: 2022.03.07-->\n\n<!--start: 2022.03.09-->\n\n## 宏\n\n### 使用#define定义常量\n\n+ 预处理只是进行死板的文本替换，而不检查替换是否正确。\n\n```cpp\n#define PI 3.1415926 //再预处理器看来，无法确定其数据类型\n\n//定义常量时，更好的方法是使用const\nconst double PI = 3.1415926;\ntypedef double MY_DOUBLE; //#define MY_DOUBLE double\n```\n\n### 使用宏避免多次包含\n\n+ 预处理器编译指令： `#ifndef`  `#endif`\n\n  ```cpp\n  #ifndef _HEAD_H_\n  #define _HRAD_H_\n  \n  //head.h的内容\n  \n  #endif   //end of head.h\n  ```\n\n### 使用#define编写宏函数\n\n+ 注意使用括号保证优先级\n\n### 使用assert宏验证表达式\n\n+ 需包含`#include<assert.h>`。\n+ assert用来调试，对输入的参数进行验证。\n+ assert()在发布模式下不可用。\n+ **推荐在代码中大量使用assert()，虽然在发行版本被禁用，但对提高代码质量很有帮助。**\n\n### 尽量不要自己编写宏函数；使用const常量而不是宏常量。宏不是类型安全的。\n\n## 模板\n\n+ 模板无疑是C++语言中最强大的特性之一。模板是类型安全的。\n+ 在编译器看来，仅当模板被使用时，其代码才存在。\n+ 对模板来说，实例化是指使用一个或多个模板参数来创建特定的类型。\n\n### 模板声明 template  \n\n```cpp\ntemplate<typename objType>\n```\n\n### 模板函数\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n//模板函数\ntemplate<typename objType>\nconst objType& GetMax(const objType& value1, const objType& value2)\n{\n    return value1 > value2 ? value1 : value2;\n}\n\nint main()\n{\n    int num1 = 25, num2 = 40;\n    //int maxVal = GetMax<int>(num1,num2); //模板函数可以不显式指定类型，但模板类必须显式指定。\n    int maxVal = GetMax(num1,num2);\n    cout<<maxVal<<endl;\n    \n    return 0;\n}\n```\n\n### 模板类\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n//模板类\ntemplate<typename T1, typename T2 = T1> //T2的类型默认为T1\n//template<typename T1 = int, typename T2 = string> //声明默认参数的模板\nclass MyTemplate\n{\n    T1 member1;\n    T2 member2;\npublic:\n    MyTemplate(const T1& t1, const T2& t2):member1(t1),member2(t2){}\n    const T1 getObj1() const{return member1;}  //返回值为const ; this指针为const\n    T2 getObj2(){return member2;}\n    //...\n};\n\n//使用\nint main()\n{\n    MyTemplate<int ,double> temp1(10,19.5);\n    MyTemplate<int ,string> temp2(10,\"hello world!\");\n    cout<<temp1.getObj1()<<endl;\n    cout<<temp2.getObj2()<<endl;\n    return 0;\n}\n\n```\n\n### 参数数量可变的模板(C++11)\n\n[泛化之美--C++11可变模版参数的妙用 - qicosmos(江南) - 博客园 (cnblogs.com)](https://www.cnblogs.com/qicosmos/p/4325949.html)\n\n```cpp\n//这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入了typename这个关键字，它的作用同class一样表明后面的符号为一个类型\n//template <class... T>   \ntemplate<typename... T>\nvoid f(T... args);\n\nsizeof...(args)  //sizeof...()打印可变参的个数\n```\n\n上面的可变模版参数的定义当中，**省略号的作用**有两个：\n\n1. 声明一个**参数包**T... args，这个参数包中可以包含0到任意个模板参数；\n2. 在模板定义的右边，可以将参数包展开成一个一个独立的参数。\n\n**我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数。**\n\n展开可变模版参数函数的方法一般有两种：一种是**通过递归函数来展开参数包**，另外一种是**通过逗号表达式来展开参数包**。\n\n1. **递归函数方式展开参数包**\n\n   ```cpp\n   \n   #include <iostream>\n   using namespace std;\n   \n   //通过递归函数展开参数包，需要提供一个参数包展开的函数和一个重载的递归终止函数，递归终止函数正是用来终止递归的。\n   //递归终止函数\n   template <typename T>\n   void print(T head)\n   {\n      cout << \"parameter \" << head << endl;\n   }\n   //展开函数\n   template <typename T, typename ...Args>\n   void print(T head, Args... rest)\n   {\n      cout << \"parameter \" << head << endl;\n      print(rest...);\n   }\n   \n   int main(void)\n   {\n      print(1,2,3,4);\n      return 0;\n   }\n   \n   ```\n\n2. **逗号表达式展开参数包**\n\n   ```cpp\n   #include <iostream>\n   using namespace std;\n   \n   //这种方式需要借助逗号表达式和初始化列表\n   template <typename T>\n   void printarg(T t)\n   {\n      cout << t << endl;\n   }\n   \n   template <typename ...Args>\n   void expand(Args... args)\n   {\n      int arr[] = {(printarg(args), 0)...};\n   }\n   \n   int main(void)\n   {\n      expand(1,2,3,4);\n      return 0;\n   }\n   ```\n\n\n### static_assert(C++11)\n\n1. 执行编译阶段断言：禁止不希望的模板实例化。\n\n   ```cpp\n   //禁止针对int实例化模板\n   static_assert(sizeof(T) != sizeof(int),\"No in please!\");  //不满足条件禁止编译\n   ```\n\n## 标准模板库\n\n### STL容器\n\n容器是用于存储数据的STL类。\n\n#### 顺序容器\n\n顾名思义，顺序容器按顺序存储数据，如数组和列表。插入速度快，查找满。\n\n+ `std::vector`：常规动态数组。\n+ `std::deque`：动态数组，但允许在开头插入或删除。\n+ `std::list`：双向链表。\n+ `std::forward_list`：单向链表。\n\n#### 关联容器\n\n按指定的顺序存储数据。插入慢，查找快。\n\n+ `std::set`：集合\n+ `std::unordered_set`：\n+ `std::map`：键-值对。\n+ `std::unordered_map`：\n+ `std::multiset`：类似set，不要求值唯一的，可存储多个值相同的项。\n+ `std::unordered_multiset`：\n+ `std::multimap`：类似map，不要求键是唯一的。\n+ `std::unordered_multimap`：\n\n#### 容器适配器（Container Adapter）\n\n+ `std::stack`：栈\n+ `std::queue`：队列\n+ `std::priority_queue`：\n\n### STL迭代器\n\n### STL算法\n\n### STL字符串类\n\n+ `std::string`：简单字符串\n+ `std::wstring`：宽字符串\n\n<!--end: 2022.03.09-->\n\n<!--start: 2022.03.10-->\n\n## STL string类\n\n+ #include<string>\n+ std::string 具体化的是std::basic_string模板类\n\n### 实例化string\n\n```cpp\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvoid print(const string& str,const string& s)\n{\n    cout<<s<<\": \"<<str<<endl;\n}\n\nint main()\n{\n    string str0;        //生成空字符串str\n    string str1 = \"Hello String!\";\n    const char* Cstr = \"Hello Char*\";\n    string str2(str1,6);  //从\"索引为5\"的位置开始拷贝\n    string str3(Cstr,5);  //将C字符串前5个字符作为字符串s的初值。\n\tstring str4(\"Hello String!\",5);\n    string str5(10,'a');  //生成一个字符串，包含n个c字符\n    string str6(str1,0,5);//将字符串str内“始于index且长度顶多n”的部分作为字符串的初值\n    string str7(str5.begin(),str5.begin()+5);\n\t\n\tprint(str0,\"str0\");\n    print(str1,\"str1\");\n    print(str2,\"str2\");\n    print(str3,\"str3\");\n    print(str4,\"str4\");\n    print(str5,\"str5\");\n\tprint(str6,\"str6\");\n    print(str7,\"str7\");\n    \n\t/*输出\n\tstr0: \n\tstr1: Hello String!\n\tstr2: String!\n\tstr3: Hello\n\tstr4: Hello\n\tstr5: aaaaaaaaaa\n\tstr6: Hello\n\tstr7: aaaaa\n\t*/\n    return 0;\n}\n```\n\n### string增删改查\n\n```cpp\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n//遍历获取元素\nvoid display()\n{\n    //size(),length()  //返回字符数量\n    string str(\"hello world!\");\n    //size_t 作为unsigned int 和unsigned long 的别名,编译器根据不同的系统类型替换标准类型,旨在增强移植性\n    for(size_t i = 0; i < str.length(); ++i)\n    {\n        cout<<\"str[\"<<i<<\"]: \"<<str[i]<<endl;\n    }\n    cout<<endl;\n    \n    //逆序迭代器方式\n    for(auto t = str.rbegin(); t != str.rend(); ++t)\n    {\n        cout<<*t<<\",\";\n    }\n    cout<<endl;\n    \n    cout<<str.c_str()<<endl;//将内容以C_string返回\n}\n\n//拼接字符串\nvoid append()\n{\n    //+=,append()\n    //push_back() //在尾部添加字符\n    string str1(\"Hello World!\");\n    string str2(\"Hello Programer!\");\n    \n    str1 += str2;  //+=\n    cout<<\" str1 += str2, str1: \"<<str1<<endl; \n    \n    str1.append(str2); //append()\n    cout<<\" str1.append(str2)2, str1: \"<<str1<<endl;\n    \n    str2.push_back('?');\n    cout<<\" str2.push_back('?'), str2: \"<<str2<<endl;  //push_back()在末尾添加字符\n}\n\n//查找字符(串)\nvoid find()\n{\n    string s(\"dog bird chicken bird cat\");\n    \n    cout <<\ts.find(\"bird\") << endl;  //查找子串s,返回找到的位置索引，\n\tcout << (int)s.find(\"pig\") << endl;   //-1表示查找不到子串\n\n\tcout << s.rfind(\"bird\") << endl; //反向查找子串s，返回找到的位置索引，\n\tcout << s.rfind('i') << endl;    \n\n\tcout << s.find_first_of(\"13r98\") << endl; //查找第个属于某子串的字符\n\tcout << s.find_first_not_of(\"dog bird 2006\") << endl;//查找第一个不属于某字符串的字符\n    \n}\n//删除\nvoid erase()\n{\n    string s(\"123456789abcd!\");\n    //iterator erase(iterator p);//删除字符串中p所指的字符\n    s.erase(s.begin());\n    cout << s << endl;  //out: 23456789abcd!\n    //iterator erase(iterator first, iterator last);//删除字符串中迭代器区间[first,last)上所有字符\n    s.erase(s.begin()+2,s.begin()+3);\n    cout << s << endl; //out: 2356789abcd!\n    //string& erase(size_t pos = 0, size_t len = npos);//删除字符串中从索引位置pos开始的len个字符\n    s.erase(0,2);\n    cout << s << endl; //out: 56789abcd!\n    //void clear();//删除字符串中所有字符\n    s.clear();\n    cout << s << endl;\n}\n\n//比较\nvoid compare()\n{\n    string s1(\"abcdef\"), s2(\"abc\");\n    \n    //相等返回0，大于返回 正数，小于返回  负数\n    cout << s1.compare(\"abcdef\") << endl;  //相等,打印0\n\tcout << s1.compare(s2) << endl;   //s1 > s2,打印 >0\n\tcout << s1.compare(\"abyz\") << endl; //s1 < \"abyz\",打印 <0\n\tcout << s1.compare(0,3,s2) << endl; //s1的前3个字符**s2,打印0\n}\n\n//反转算法\n//需要 头文件是#include <algorithm>\nvoid reverse()\n{\n    string str(\"hello string!\");\n    cout<<\"str: \"<<str<<endl;\n    reverse(str.begin(),str.end());\n    cout<<\"reverse str: \"<<str<<endl;\n}\n\nint main()\n{\n    //display();\n    //append();\n    //erase();\n    find();\n    compare();\n    reverse();\n    \n    return 0;\n}\n```\n\n## STL vector类\n\n+ 需包含头文件`#include <vector>`\n\n### 实例化vector\n\n```cpp\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<int> intArray;  //默认构造\n    \n    vector<float> floatArray{20.4, 15.9}; //初始化两个元素的值\n    \n    vector<int> intArray2(10); //初始化包含10个元素\n    \n    vector<int> intArray3(10, 1);//初始化包含10个元素,且值都为1\n    \n    vector<int> intArray4(intArray3); //使用一个实例初始化\n    return 0;\n}\n```\n\n### vector增删改查\n\n```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n//遍历\nvoid  traverse()\n{\n    vector<int> temp{10,12,14,16};\n    \n    for(auto t : temp)\n    {\n        cout<<t<<\" \";\n    }\n    cout<<endl;\n    \n    cout<<\"temp[3]: \"<<temp[3]<<endl; //注意 索引不能越界\n    cout<<\"temp[2]: \"<<temp.at(2)<<endl; //at()在运行阶段执行检查  更安全\n}\nvoid  traverse(const vector<int>& temp)\n{\n    cout<<\"size = \"<<temp.size()<<\": \";\n    for(auto t : temp)\n    {\n        cout<<t<<\" \";\n    }\n    cout<<endl;\n}\n//插入、删除\nvoid insert()\n{\n    vector<int> integers;\n    \n    //push_back()在末尾添加元素,首选\n    integers.push_back(1);\n    integers.push_back(2);\n    traverse(integers);\n    \n    //insert()在指定位置插入元素,效率低\n    integers.insert(integers.begin()+1, 25); //在第一个元素后面插入25\n    integers.insert(integers.end(),2,45);  //在数组末尾插入2个元素,值都为45\n    traverse(integers);\n    \n    vector<int> temp = {15,16};\n    integers.insert(integers.begin(), temp.begin(), temp.end());//插入temp的值到数组开头\n    traverse(integers);\n    \n    //pop_back()从末尾删除元素\n    integers.pop_back();\n    traverse(integers);\n    \n    //清空元素\n    integers.clear();\n    traverse(integers);\n    \n    //判空\n    if(integers.empty())\n    {\n        cout<<\"The container is now empty!\"<<endl;\n    }\n}\n\n\nint main()\n{\n    traverse();\n    insert();\n    \n    return 0;\n    \n}\n```\n\n+ size()：实际存储的元素数；capacity()：总的容量。  数组的大小 $<=$ 容量。（如果数组进行了插入，vector需要重新分配内部缓冲区，**重新分配的逻辑实现是智能的：提前分配更多的容量**）。\n+ 重新分配内部缓冲区时，需要复制容器中包含的对象，这可能降低性能。\n\n### STL deque类\n\n+ 需包含`#include <deque>`\n+ 具有vector的所有性质。\n+ 使用`push_front`和`pop_front`在开头插入/删除元素。\n\n## STL list类\n\n+ 需包含`#include<list>`。\n+ 双向链表。\n+ 迭代器可以`++`或者`--`。\n+ 虽然STL提供了sort()和remove()两种算法，但是list也提供了这两种算法。这些算法的成员函数版本**确保元素的相对位置发生变化后指向元素的迭代器仍然有效。**\n\n### 实例化list\n\n```cpp\n#include<list>\n#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n    list<int> linkInts0;   //初始化空链表\n    \n    list<int> linkInts1(10); //初始化包含10个元素的list\n    \n    list<int> linkInts2(10,99);//包含10个元素，均为99\n    \n    list<int> linkInts3(linkInts2);//复制构造\n    \n    vector<int> vecInts(10,200);\n    list<int> linkInts4(vecInts.begin(),vecInts.end());//从vector对象中复制\n    \n    return 0;\n}\n```\n\n### list增删改查\n\n```cpp\n#include<list>\n#include<iostream>\n\nusing namespace std;\n\n\n//遍历\ntemplate<typename T>\nvoid display(const T& container)\n{\n    for(auto element = container.cbegin(); element != container.cend(); ++element)\n    {\n        cout<<*element<<\" \";\n    }\n    cout<<endl;\n   \n}\n//插入\nvoid insert()\n{\n    list<int> listInts;\n    \n    listInts.push_back(10);\n    listInts.push_back(20);\n    listInts.push_front(0);\n    display(listInts);\n    \n    //iterator insert(iterator pos, const T& x)\n    /*\n    既然是链表，其迭代器就无法进行加减运算，但可以自增自减\n    */\n    //listInts.insert(listInts.begin()+1, 5);// error: no match for ‘operator+’ (operand types are ‘std::_Fwd_list_iterator<int>’ and ‘int’)\n    listInts.insert(++listInts.begin(), 5); //(插入位置，值)\n    display(listInts);\n    //void insert(iterator pos, sizer_type n, const T& x)\n    listInts.insert(listInts.end(), 2, 0); //(插入位置，插入个数，值)\n    display(listInts);\n    /*template<class InputIterator>\n     void insert(iterator pos, InputIterator f, InputIterator l);\n    */\n    list<int> listInts1;\n    listInts1.insert(listInts1.begin(), listInts.begin(), listInts.end());\n    display(listInts1);\n}\n//删除\nvoid erase()\n{\n    list<int> listInts{0,10,20,30,40};\n    \n    listInts.erase(listInts.begin()); //删除\n    display(listInts);\n    \n    listInts.clear(); //清空\n}\n//反转、排序\nbool Sort_Desc(const int& t1, const int& t2)  //二元谓词，告诉sort如何解释小于。\n{\n    return (t1 > t2); \n}\nvoid sort()\n{\n    list<int> listInts{-20,20,10,100,40};\n    //反转\n    listInts.reverse();\n    display(listInts);\n    \n    //排序\n    //默认排序\n    listInts.sort();\n    display(listInts);\n    \n    //高级排序\n    listInts.sort(Sort_Desc);  //降序\n    display(listInts);\n}\n\nint main()\n{\n    sort();\n    return 0;\n}\n```\n\n+ 对包含对象的list进行排序\n  + 在list包含的对象所属类中，实现运算符<；\n  + 提供一个排序二元谓词。\n\n### STL forward_list(C++11)\n\n+ 单向链表\n+ 与list类似\n+ 插入元素不能使用`push_back`；而只能使用`push_front`。\n+ 对迭代器只能使用`++`，不能使用`--`。\n+ 相比list，占用的内存稍少，因为只需指向下一个元素，而无需指向上一个元素。\n\n<!--end: 2022.03.10-->\n\n<!--start: 2022.03.11-->\n\n## STL 集合类\n\n### set和multiset\n\n+ set存储唯一值，multiset可存储重复值。\n+ 需包含头文件`#include<set>`。\n+ 插入时就对元素进行排序（默认升序）。\n+ <font color=#ff0000>对频繁需要查找的应用程序来说，set和multiset很有优势。因为其内容是经过排序的（当然，插入时进行排序是需要额外开销的），查找速度更快。</font>时间复杂度为$ log(n)$。\n+ **如果用set等容器来存储自定义类的对象，务必要实现运算符`<`（排序谓词）和`**`（用于`std::find()`函数）。**\n\n#### 实例化\n\n```cpp\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n//创建二元排序谓词，可在类中定义一个operator()\ntemplate<typename T>\nstruce SortDescending   //降序\n{\n    bool operator()(const T& t1, const T& t2) const\n    {\n        return (t1 > t2);\n    }\n};\n\nint main()\n{\n    set<int> setInts1;\n    multiset<int> multisetInts1{10,20}; //使用默认的排序谓词：std::less<T>\n    multiset<int, less<int>> multisetInts2{30,10,20}; //升序：std::less<T>\n     multiset<int, greater<int>> multisetInts2{30,10,20}; //降序：std::greater<T>\n    set<int>::const_iterator element1;\n    multiset<int>::iterator element2;\n    \n    set<int, SortDescending<int>> setInts2;\n    \n    return 0;\n}\n```\n\n#### 增删查\n\n```cpp\n#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid display(const T& temp)\n{\n    for(auto element = temp.cbegin(); element != temp.cend(); ++element)\n    {\n        cout<<*element<<\" \";\n    }\n    cout<<endl;\n}\n\n//插入\nvoid insert()\n{\n    set<int> setInts{100,10,20,-20};\n    multiset<int> multisetInts{100,10,20,-20};\n    display(setInts);\n    display(multisetInts);\n    \n    setInts.insert(50);\n    setInts.insert(50);\n    multisetInts.insert(50);\n    multisetInts.insert(50);\n    display(setInts);\n    display(multisetInts);\n    //multisetInts.count(x)返回存储了值为x的元素个数\n    cout<<multisetInts.count(50)<<endl;\n    /*输出\n    -20 10 20 100 \n\t-20 10 20 100 \n\t-20 10 20 50 100 \n\t-20 10 20 50 50 100 \n\t2\n    */\n}\n\n//查找\nvoid find()\n{\n    set<string> setInts{\"100a\",\"10a\",\"20a\",\"-20a\"};\n  \n    auto elementFound = setInts.find(\"-20a\");\n    if(elementFound != setInts.cend())\n    {\n        cout<<*elementFound<<endl;\n    }\n    else\n    {\n\t\tcout<<\"Not Found\"<<endl;\n\t}\n}\n\n//删除\nvoid erase()\n{\n    multiset<int, greater<int>> multisetInts{43,75,75,12,-18};  //std::greater<T>降序排列的二元谓词\n    display(multisetInts);\n    \n    //根据值来删除\n    multisetInts.erase(75);  //删除值为78的所有元素\n    display(multisetInts);\n    \n    //根据迭代器来删除\n    auto elementFound = multisetInts.find(43);\n    if(elementFound != multisetInts.cend())\n    {\n         multisetInts.erase(elementFound);\n    }\n    display(multisetInts);\n    \n    multisetInts.clear();//清空\n}\n\n//set不能进行修改值\n\nint main()\n{\n    erase();\n    return 0;\n}\n```\n\n### unordered_set和unordered_multiset(C++11)\n\n+ 需包含头文件`#include <unordered_set>`。\n\n+ 基于散列的`set`。因此基本操作相同。\n\n+ `unordered_set`的一个重要特征是：<font color =#000fff >有一个负责确定排序顺序的散列函数。</font>\n\n  ```cpp\n  unordered_set<int> usetInt;\n  unordered_set<int>::hasher HFn = usetInt.hash_function();\n  ```\n\n+ <font color=#000fff>要决定选择使用`std::unordered_set`还是`std::set`，最好是在模拟环境中测试这两种容器的性能。</font>\n\n## STL 映射类\n\n### map和multimap\n\n+ 键值对容器。\n+ 需包含头文件`#include <map>`。\n+ `map`键值唯一，`multimap`键值可重复。\n+ 内部结构类似二叉树，在插入时排序，不能修改元素。\n+ multimap 不支持下标运算符，因为键并不能确定一个唯一元素。\n\n#### 实例化\n\n```cpp\nmap<keyType, valueType, Predicate = std::less<keyType>> mapObj;  //默认升序\nmultimap<keyType, valueType, Predicate = std::less<keyType>> multimapObj;\n```\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    map<int, string> map1;\n    map<int, string> map2(map1);\n    return 0;\n}\n```\n\n#### 增删查\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid display(const T& temp)\n{\n    for(auto element = temp.cbegin(); element != temp.cend(); ++element)\n    {\n        //first: 表示键  second: 表示值\n        cout<<element->first<<\"->\"<<element->second<<endl;\n    }\n    cout<<endl;\n}\n//插入\nvoid insert()\n{\n    map<int, string> map1({{0,\"zero\"}});\n    \n    map1.insert(make_pair(1,\"First\")); //使用make_pair()\n    display(map1);\n    map1.insert(pair<int, string>(2, \"Second\"));  //使用std::pair\n    display(map1);\n    \n    map1[10] = \"Ten\"; //使用数组语法：[]里面的是键。不同于map，multimap不能使用中括号[]法插入\n    display(map1);\n    \n    //上述方式同样适用multimap\n    multimap<int, string> multimap1(map1.cbegin(),map1.cend());\n    display(multimap1);\n    //multimap 不支持下标运算符，因为键并不能确定一个唯一元素。\n    //multimap1[10] = \"Double Ten\";//不同于map，multimap不能使用中括号[]法插入\n    multimap1.insert(pair<int, string>(10,\"Double Ten\"));\n    display(multimap1);\n    cout<<multimap1.count(10)<<endl; //返回指定键10有多少个元素\n    \n}\n\n//查找\nvoid find()\n{\n    map<int, string> map1({{0,\"zero\"},{1,\"first\"},{3,\"third\"}});\n    auto pairFound = map1.find(1);\n    //首先检查迭代器确保find()已成功\n    if(pairFound != map1.cend())\n    {\n        cout<<pairFound->first<<\"->\"<<pairFound->second<<endl;\n    }\n    else{\n        cout<<\"Not Found!\"<<endl;\n    }\n}\n\n//删除\nvoid erase()\n{\n    multimap<int, string> multimap1({{0,\"zero\"},{1,\"first\"},{1,\" double first\"},{3,\"third\"}});\n    display(multimap1);\n    \n    auto num = multimap1.erase(1);  //返回删除的元素数目  删除键为1的所有元素\n    display(multimap1);\n    \n    //根据迭代器来删除\n    auto elementFound = multimap1.find(0);\n    if(elementFound != multimap1.cend())\n    {\n         multimap1.erase(elementFound);\n    }\n    display(multimap1);\n    \n    multimap1.clear();//清空\n}\nint main()\n{\n    find();\n    return 0;\n}\n```\n\n### unordered_map和unordered_multimap(C++11)\n\n+ 基于散列表的map容器。\n+ 需包含头文件`#include <unordered_map>`。\n+ 在不发生冲突的情况下，平均插入/删除时间是固定的，查找时间也是固定的，不受包含元素数目的影响。\n\n## 函数对象\n\n<!--书上内容较少，没啥好看的-->\n\n> 函数对象（functor）：从概念上说，函数对象是用作函数的对象；但从实现上说，函数对象是实现了operator()的类的对象。\n\n### 一元函数\n\n> **一元函数**：接收一个参数的函数。如果其返回一个布尔值，则该函数称为**谓词**。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\n/*\n *一元函数\n */\ntemplate<typename T>\nvoid FuncDisplay(const T& element)\n{\n    cout << element <<' ';\n}\n\n//一元函数的另一种表现形式,即其包含在类或结构的operator()中\ntemplate<typename T>\nstruct StructDisplay   //这里用结构struct;如果用类class,需要指定为public。\n{\n    int count;\n    \n    StructDisplay():count(0){}\n    \n    void operator()(const T& element)\n    {\n        ++count;\n        cout << element <<' ';\n    }\n};\n\n//使用全局函数\nvoid ByFunc()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n    //STL for_each()\n    for_each(vecInts.begin(),vecInts.end(), FuncDisplay<int>);\n    \n}\n//使用结构: 由于可以包含成员，这就可以用来保存状态。\nvoid ByStruct()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n    \n    StructDisplay<int> result;\n    result = for_each(vecInts.begin(),vecInts.end(), StructDisplay<int>());\n    cout<<endl<<\"Functor invoked \"<<result.count<<\" times\"<<endl;\n    \n}  \n//使用lambda表达式\nvoid ByLambda()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n\n    for_each(vecInts.begin(),vecInts.end(),\n             [](int& element)\n             {\n                 cout<<element<<' ';\n             });\n}\nint main()\n{\n    ByFunc();\n\tcout<<endl<<endl;\n\tByStruct();\n    cout<<endl;\n    ByLambda();\n    return 0;\n}\n```\n\n\n\n### 二元函数\n\n> **二元函数**：接收两个参数的函数。如果其返回一个布尔值，则该函数称为**二元谓词**。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n\n//二元谓词\nclass StructDisplay   \n{\npublic：\n    //该二元谓词 将两个字符串转换为小写，再对其进行比较。用于字符串进行不区分大小写的排序。\n    bool operator()(const string& str1, const string& str2) const\n    {\n        string str1LowerCase;\n        str1LowerCase.resize(str1.size());\n        transform(str1.begin(), str1.end(), str1LowerCase.begin(), ::tolower);\n    \n        string str2LowerCase;\n        str2LowerCase.resize(str2.size());\n        transform(str2.begin(), str2.end(), str2LowerCase.begin(), ::tolower);\n    \n        return (str1LowerCase < str2LowerCase);\n    }\n};\n```\n\n## lambda表达式（C++11新增）\n\n> lambda表达式是一种定义匿名函数对象的简洁方式。\n\n### 定义lambda表达式\n\n> + 以方括号[]打头。（告诉编译器，接下来是一个lambda表达式）\n> + 方括号后面是一个参数列表，该参数列表与不使用lambda表达式时提供给operator()的参数列表相同。\n\n### 一元函数对应的lambda表达式\n\n```cpp\n[](Type paramName){//lambda expression}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//在算法for_each()中使用lambda表达式\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  for_each(nums.cbegin(), nums.cend(),\n           [](auto& element) { cout << element << \",\"; });\n  cout << endl;\n  return 0;\n}\n```\n\n### 一元谓词对应的lambda表达式\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//[](int& element){return ((element%2)==0);}//在element为偶数时\n//find_if()中使用，找到数组中的第一个偶数\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  auto evenNum = find_if(nums.cbegin(), nums.cend(),\n                         [](const int& element) { return ((element % 2) == 0); });\n  if (evenNum != nums.cend()) {\n    cout << *evenNum << endl;\n  }\n  return 0;\n}\n```\n\n> <font color=#ff0000>**务必使用const来限定输入参数，在输入参数为引用参数时尤其如此。这样可避免无意间修改容器中元素的值。**</font>\n\n### 通过捕获列表接受状态变量的lambda表达式\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//指定除数\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  int divisor = 50;\n  auto evenNum = find_if(\n      nums.cbegin(), nums.cend(),\n      [divisor](const int& element) { return ((element % divisor) == 0); });\n  if (evenNum != nums.cend()) {\n    cout << *evenNum << endl;\n  }\n  return 0;\n}\n```\n\n> 一系列以状态变量的方式传递的参数（`[...]`）也被称为**lambda表达式的捕获列表**（capture list）。\n\n### lambda表达式的通用语法\n\n```cpp\n//接收多个状态变量的lambda表达式\n[stateVar1, stateVar2](Type& param){}\n//添加关键字mutable，可在lambda表达式中修改状态变量的值\n//修改只在lambda表达式内生效\n[stateVar1, stateVar2](Type& param) mutable{}\n//要保证修改的值在其外部也有效，需要按引用传递\n[stateVar1, &stateVar2](Type& param){}\n//向编译器明确指定返回类型，使用 ->\n//如果lambda表达式包含多行代码，就必须显式指定返回类型。\n[stateVar1, stateVar2](Type1& param1, Type2& param2)->ReturnType {return (value);}\n```\n\n### 二元函数对应的lambda表达式\n\n二元函数接收两个参数，还可返回一个值\n\n```cpp\n[...](Type1& param1, Type2& param2){}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//使用lambda表达式在std::transform()中实现元素相乘\nint main() {\n  vector<int> nums1{101, -4, 500, 21, 42, -1, -50};\n  vector<int> nums2{101, -4, 500, 21, 42, -1, -50};\n  vector<int> result;\n  result.resize(nums2.size());\n\n  transform(nums1.cbegin(), nums1.cend(), nums2.cbegin(), result.begin(),\n            [](int a, int b) { return a * b; });\n\n  for_each(nums1.cbegin(), nums1.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  for_each(nums2.cbegin(), nums2.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  for_each(result.cbegin(), result.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  return 0;\n}\n```\n\n> 注：\n>\n> + **lambda表达式总是以[]或[...]打头。**\n> + **除非用mutable进行指定，否则不能修改捕获列表中指定的状态变量。**\n> + **当lambda表达式的语句块（{}）包含多条语句时，需要显式地指定返回类型。**\n> + **lambda表达式地使用旨在简洁高效。因此当其语句块较为复杂或者涉及重用时，应该转为使用函数对象。**\n\n## STL算法\n\n> + 头文件：`#include<algorithm>`\n\n### STL算法的分类\n\n> 分为两大类：**变序算法**和**非变序算法**。\n\n#### 非变序算法\n\n> 不改变容器中元素的顺序和内容的算法称为非变序算法。\n\n主要有：\n\n1. 计数算法 \n   + `count()`  \n   +  `count_if()` \n\n2. 搜索算法\n   + `search()`\n   + `search_n()`  \n   + `find()`\n   + `find_if()`\n   + `find_end()`      \n   + `find_first_of()` \n   + `adjacent_find()`\n\n3. 比较算法\n   + `equal()`\n   + `mismatch()` \n   + `lexicographical_compare()`\n\n#### 变序算法\n\n> 改变容器中元素的顺序或内容的算法称为变序算法。\n\n主要有：\n\n1. 初始化算法\n   + fill()\n   + fill_n()\n   + generate()\n   + generate_n()\n2. 修改算法\n   + for_each()\n   + transform()\n3. 复制算法\n   + copy()\n   + copy_backward()\n4. 删除算法\n   + remove()\n   + remove_if()\n   + remove_copy()\n   + remove_copy_if()\n   + unique()\n   + unique_copy()\n5. 替换算法\n   + replace()\n   + replace_if()\n6. 排序算法\n   + sort()\n   + stable_sort()\n   + partial_sort()\n   + partial_sort_copy()\n7. 分区算法\n   + partition()\n   + stable_partition()\n8. 可用于有序容器的算法\n   + binary_search()\n   + lower_bound()\n   + upper_bound()\n\n### 使用STL算法\n\n> 注：\n>\n> <font color=#ff0000>**如果STL算法返回的是一个迭代器，务必要对其进行检查，以保证其有效性。**</font>\n\n#### find() & find_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//函数对象:如果是奇数,返回true\ntemplate <typename T>\nbool specify_condition(const T& number) {\n  return ((number % 2) != 0);\n}\n\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n\n  //使用find()找到特定的值\n  int numToFind = 21;\n  auto element = find(nums.cbegin(), nums.cend(), numToFind);\n  if (element != nums.cend()) {\n    cout << \"vector容器中找到了值:\" << *element << endl;\n  } else {\n    cout << \"vector容器中找不到值:\" << numToFind << endl;\n  }\n\n  //使用find_if()找到满足指定条件的第一个值\n  auto element1 = find_if(nums.cbegin(), nums.cend(), specify_condition<int>);\n  if (element1 != nums.cend()) {\n    cout << \"vector容器中找到了满足特定条件的第一个值:\" << *element1 << endl;\n  } else {\n    cout << \"vector容器中找不到满足特定条件的值:\" << numToFind << endl;\n  }\n  return 0;\n}\n\n/*输出\nvector容器中找到了值:21\nvector容器中找到了满足特定条件的第一个值:101\n*/\n```\n\n#### count() & count_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//函数对象:如果是奇数,返回true\ntemplate <typename T>\nbool specify_condition(const T& number) {\n  return ((number % 2) != 0);\n}\n\nint main() {\n  vector<int> nums{101, -1, 500, 21, 42, -1, -50};\n\n  //使用count()对特定的值计数，返回计数值\n  int numToFind = -1;\n  size_t num = count(nums.cbegin(), nums.cend(), numToFind);\n  cout << \"vector容器中找到了值\" << numToFind << \"共\" << num << \"个\" << endl;\n\n  //使用count_if()对满足指定条件的值计数，返回计数值\n  num = count_if(nums.cbegin(), nums.cend(), specify_condition<int>);\n  cout << \"vector容器中找到了满足特定条件的值\"\n       << \"共\" << num << \"个\" << endl;\n  return 0;\n}\n\n/**输出\nvector容器中找到了值-1共2个\nvector容器中找到了满足特定条件的值共4个\n*/\n```\n\n#### fill() & fill_n()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid display(const T& number) {\n  cout << number << \",\";\n}\nint main() {\n  vector<int> nums(5);\n\n  //使用fill()填充指定范围内的元素为指定值\n  //输入:起始位置;终止位置;指定的值\n  fill(nums.begin(), nums.begin() + 2, 10); //这里不能使用常量迭代器,因为要修改容器中元素的值\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  //使用fill_n()填充指定个数的元素为指定值\n  //输入：起始位置；指定个数；指定的值\n  fill_n(nums.begin() + 2, 3, 9);\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  return 0;\n}\n\n/**输出\n10,10,0,0,0,\n10,10,9,9,9,\n*/\n```\n\n#### generate() & generate_n()\n\n```cpp\n#include <algorithm>\n#include <ctime>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid display(const T& number) {\n  cout << number << \",\";\n}\n\nint main() {\n  vector<int> nums(5);\n\n  srand(time(NULL));\n\n  //使用fill()填充指定范围内的元素为一元函数返回的值\n  //输入:起始位置;终止位置;指定条件\n  generate(nums.begin(), nums.begin() + 2, rand);  // rand为随机数生成器\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  //使用fill_n()填充指定个数的元素为一元函数返回的值\n  //输入:起始位置;指定个数;指定条件\n  generate_n(nums.begin() + 2, 5, rand);\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  return 0;\n}\n\n/**输出\n19362,17346,0,0,0,\n19362,17346,11224,31780,17349,\n*/\n```\n\n#### for_each()\n\n> 对指定范围内的每个元素执行指定的一元函数对象\n\n#### transform()\n\n> + 和for_each()很像,都对源范围内的每个元素调用指定的函数对象,包括两个版本。\n> + **第一个版本接收一元函数，常用于字符串转换大小写（使用toupper()或tolower()）。**\n> + **第二个版本接收二元函数，让transform()能够处理一对来自两个不同范围的元素(用于加减乘除)。**\n\n```cpp\n#include <algorithm>\n#include <deque>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n  string str(\"This is a test string!\");\n  string strToUpper;\n  strToUpper.resize(str.size());\n  //将字符串转换为大写\n  //输入:原字符串起始位置;原字符串终止位置;目标字符串起始位置;一元函数对象\n  transform(str.cbegin(), str.cend(), strToUpper.begin(), ::toupper);\n  cout << strToUpper << endl;\n\n  vector<int> nums1{1, 2, 3, 4, 5, 6};\n  vector<int> nums2(nums1.size(), 10);\n  deque<int> productInList(nums1.size());\n  //将两个等大小的vector元素对应相乘\n  //容器1起始位置;容器1终止位置;容器2起始位置;目标容器起始位置;二元函数对象\n  transform(nums1.cbegin(), nums1.cend(), nums2.cbegin(), productInList.begin(),\n            [](int a, int b) { return a * b; });\n\n  for (size_t i = 0; i < nums1.size(); i++) {\n    cout << i << \"\\t\" << nums1[i] << \" * \" << nums2[i] << \" = \"\n         << productInList[i] << endl;\n  }\n  return 0;\n}\n\n/**输出\nTHIS IS A TEST STRING!\n0\t1 * 10 = 10\n1\t2 * 10 = 20\n2\t3 * 10 = 30\n3\t4 * 10 = 40\n4\t5 * 10 = 50\n5\t6 * 10 = 60\n*/\n```\n\n> 上述例子，通过两个vector容器相加赋给到deque容器中。表明：通过使用迭代器，可将容器及其实现同STL算法分离（STL算法无需知道容器的具体细节）。\n\n#### copy() & copy_if() & remove() & remove_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T& container) {\n  for (auto element = container.cbegin(); element != container.cend();\n       ++element) {\n    cout << *element << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  list<int> numsList1{10, 2020, 0, 2017, -15, -14, 0, 58, 1};\n  list<int> numsList2(numsList1.size(), 21);\n  Display(numsList1);\n  Display(numsList2);\n  vector<int> numsVector(numsList1.size() * 2);//设置为上述容器的2倍\n  //将numsList2的值复制到numsVector中，返回一个迭代器\n  auto lastElement =\n      copy(numsList2.cbegin(), numsList2.cend(), numsVector.begin());\n  //将numsList1中的偶数值复制到numsVector中，从上面返回的位置开始复制。\n  copy_if(numsList1.cbegin(), numsList1.cend(), lastElement,\n          [](int element) { return ((element % 2) == 0); });\n  Display(numsVector);\n    \n  //删除numsVector中的0\n  auto newEnd = remove(numsVector.begin(), numsVector.end(), 0);\n  numsVector.erase(newEnd, numsVector.end()); //调整容器大小\n  Display(numsVector);\n  //删除numsVector中的奇数\n  newEnd = remove_if(numsVector.begin(), numsVector.end(),\n                     [](int element) { return ((element % 2) == 1); });\n  numsVector.erase(newEnd, numsVector.end());\n  Display(numsVector);\n\n  return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -14 0 58 1 \n21 21 21 21 21 21 21 21 21 \n21 21 21 21 21 21 21 21 21 10 2020 0 -14 0 58 0 0 0 \n21 21 21 21 21 21 21 21 21 10 2020 -14 58 \n10 2020 -14 58 \n*/\n```\n\n#### replace() & replace_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    list<int> numsList1{10, 2020, 0, 2017, -15, -14, 0, 58, 1};\n    list<int> numsList2{10, 11, 20, 21, 30, 31};\n    Display(numsList1);\n    Display(numsList2);\n    cout << endl;\n    //replace()根据比较运算符==的返回值来替换元素\n    //输入:集合的起始位置;集合的终止位置;要替换的值;替换成的值\n    replace(numsList1.begin(), numsList1.end(), 0, -1);\n    Display(numsList1);\n    \n    //replace_if()接收一个一元谓词,替换满足其条件的值\n    //输入:集合的起始位置;集合的终止位置;一元谓词;替换成的值\n    replace_if(\n        numsList2.begin(), numsList2.end(), [](int a)\n        { return (a % 2) == 0; },\n        -1);\n    Display(numsList2);\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -14 0 58 1 \n10 11 20 21 30 31 \n\n10 2020 -1 2017 -15 -14 -1 58 1 \n-1 11 -1 21 -1 31 \n*/\n```\n\n#### sort() & resize() & binary_search()\n\n1. sort()：排序\n\n> + stable_sort()与sort()一样，只不过它是稳定的，这相对于sort()就降低了性能，使用时需要权衡考虑。\n> + sort()不要用于list容器。sort()接受的输入迭代器是随机访问迭代器，但是双向list链表容器的访问方式是双向迭代器，因此，不能使用STL本身的排序算法sort()。可使用list自己的成员方法sort()。\n\n```cpp\n//默认使用std::less<>,即默认为升序排序\nsort(nums.begin(),nums.end());\n//可以使用二元谓词指定排序方式\nsort(nums.begin(),nums.end(),[](int a, int b){return (a > b);});//实现降序排序\n```\n\n2. unique()：删除相邻重复元素\n\n> + **只能删除相邻的重复元素**。\n> + 因此为了达到去重的效果，应该先进行排序，再使用unique()。\n\n```cpp\nauto newEnd = unique(nums.begin(),nums.end());\nnums.erase(newEnd,nums.end()); //to resize\n```\n\n3. binary_search()\n\n> binary_search()它只能用于**有序的容器**，实现快速查找。（如果用于未经排序的容器，结果不可知。）\n\n```cpp\nbool elementFound = binary_search(nums.cbegin(),nums.cend(),2001);\nif(elementFound)\n{\n    cout<<\"Element found in the vector!\"<<endl;\n}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> numsList1{10, 2020, 0, 2017, -15, -15, 0, 58, 10};\n    Display(numsList1);\n    cout << endl;\n\n    //升序排序\n    sort(numsList1.begin(), numsList1.end());\n    Display(numsList1);\n    cout << endl;\n    \n    //快速查找\n    bool elementFound = binary_search(numsList1.cbegin(), numsList1.cend(), 2011);\n    if (elementFound)\n    {\n        cout << \"Element was found in the vector!\" << endl;\n    }\n    else\n    {\n        cout << \"Element not found!\" << endl;\n    }\n    cout << endl;\n    \n    //去重\n    auto newEnd = unique(numsList1.begin(), numsList1.end());\n    numsList1.erase(newEnd, numsList1.end());\n    Display(numsList1);\n\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -15 0 58 10 \n\n-15 -15 0 0 10 10 58 2017 2020 \n\nElement not found!\n\n-15 0 10 58 2017 2020 \n*/\n```\n\n#### partition()\n\n> + partition()将范围分区，不稳定的。\n>\n>   ```cpp\n>   //输入：容器起始位置；容器终止位置；一元谓词\n>   partition(numsList1.begin(), numsList1.end(),[](int a){return a<0;});\n>   ```\n>\n> + stable_partition()是稳定的。但为了保证相对顺序不变，性能有所降低。\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> numsList1{10, 2020, 0, 2017, -14, -15, 0, -58, 10};\n    vector<int> numsList2(numsList1);\n    Display(numsList1);\n    cout << endl;\n\n    //非稳定分区\n    //分为负数和非负数\n    partition(numsList1.begin(), numsList1.end(), [](int b)\n              { return b < 0; });\n    Display(numsList1);\n    cout << endl;\n\n    //稳定分区\n    stable_partition(numsList2.begin(), numsList2.end(), [](int b)\n                     { return b < 0; });\n    Display(numsList2);\n    cout << endl;\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -14 -15 0 -58 10 \n\n-58 -15 -14 2017 0 2020 0 10 10 \n\n-14 -15 -58 10 2020 0 2017 0 10 \n*/\n```\n\n#### lower_bound() & upper_bound()\n\n> + 向有序容器中插入元素\n\n```cpp\n//都返回一个迭代器，分别指向在不破坏现有顺序的情况下，元素可插入到有序容器中的最前位置和最后位置。\nauto minInsertPos = lower_bound(nums.begin(),nums.end(),21);\nauto maxInsertPos = upper_bound(nums.begin(),nums.end(),21);\n```\n\n### 总结\n\n> 1. **使用`remove()`，`remove_if()`，`unique()`算法删除元素后，务必使用容器的成员方法erase()调整容器的大小。**\n> 2. **使用`unique()`算法，务必在使用前进行排序，保证重复元素彼此相邻。**\n> 3. **使用`find()`，`find_if()`，`search()`，`search_n`算法返回的迭代器之前，务必将其与容器的`end()`进行比较，保证有效。**\n> 4. **仅当元素的相对顺序重要时，才使用`stable_sort()`，`stable_partition()`。**\n> 5. **`binary_search()`只能用于有序容器。**\n> 6. **对于有序容器，需要进行插入时，应使用`lower_bound()`，`upper_bound()`，保证插入后容器仍然是有序的。**\n\n## 自适应容器：栈和队列\n\n### 栈\n\n> + LIFO(后入先出)，从栈顶删除/插入元素。“后来居上”\n>\n> + 泛型容器`std::stack`\n>\n> + 头文件`#include<stack>`\n>\n> + stack内部是默认yongstd::deque来实现的。\n>\n>   ```cpp\n>   template<\n>      class elementType,\n>      class Container=deque<Type>\n>   >class stack;\n>   ```\n>\n> + stack改变了其内部实现容器的行为，通过限制元素插入或者删除的方式实现其功能，从而提供严格遵守栈机制的行为特征。\n\n#### std::stack实例化\n\n```cpp\n#include <stack>\n#include <vector>\nint main()\n{\n    using namespace std;\n    //实例化整型栈\n    stack<int> numsInStack;\n    //在内部改用std::vector来存储数据，默认是std::deque\n    stack<double, vector<double>> doubleStackedInVec;\n    //拷贝构造\n    stack<int> numsInStackCopy(numsInStack);\n}\n```\n\n#### std::stack的成员函数\n\n```cpp\npush() //在栈顶插入元素\npop()  //删除栈顶元素\nempty()//检查栈是否为空并返回true/false\nsize() //返回栈的大小\ntop()  //获取指向栈顶元素的引用\n```\n\n### 队列\n\n> + FIFO(先入先出)，在末尾插入元素，在开头删除元素。\n>\n> + `std::queue`\n>\n> + 头文件`#include<queue>`\n>\n> + 定义\n>\n>   ```cpp\n>   template<\n>      class elementType,\n>      class Container=deque<Type>\n>   >class queue;\n>   ```\n\n#### std::queue实例化\n\n```cpp\n#include <queue>\n#include <list>\n\nvoid main()\n{\n    std::queue<double> doubleInQueue;\n    \n    std::queue<double,list<double>> doubleInQueueInList;\n    \n    std::queue<double> doubleInQueueCopy(doubleInQueue);\n}\n```\n\n#### std::queue的成员函数\n\n```cpp\npush()   //在队尾插入元素\npop()    //在队头删除元素\nfront()  //返回指向队头元素的引用\nback()   //返回指向队尾元素的引用\nempty()  //检查队列是否为空，返回true/false\nsize()   //返回队列中的元素数\n```\n\n### 优先级队列\n\n> + `STL::priority_queue`\n> + 头文件`#include<queue>`\n>\n> + 与`queue`的区别在于：优先级最高的元素位于队首，且只能在队首执行操作。\n>\n> + 定义：\n>\n>   ```cpp\n>   template<\n>      class elementType,   //指定元素类型\n>      class Container=vector<Type>,  //指定内部的存储容器\n>      class Compare=less<typename Container::value_type>  //指定二元谓词，默认使用std::less\n>   >class priority_queue;\n>   ```\n>\n>   \n\n#### std::priority_queue实例化\n\n```cpp\n#include <queue>\n#include <list>\n#include <functional>  //为了使用std::greate<>r\n\nvoid main()\n{\n    std::priority_queue<double> doubleInPQ;\n    \n    //std::greater使得最小的元素位于队首\n    std::queue<int,deque<int>,std::greater<int>> doubleInQueueInList;\n    \n    std::queue<double> doubleInPQCopy(doubleInPQ);\n}\n```\n\n#### std::priority_queue的成员函数\n\n```cpp\npush()   //插入一个元素\npop()    //删除队首元素\ntop()    //返回队首元素的引用\nempty()  //检查队列是否为空，返回true/false\nsize()   //返回队列中的元素数\n```\n\n## STL位标志\n\n### bitset类\n\n> + `std::bitset`\n> + 头文件`#include<bitset>`\n> + 用于处理以位和位标志表示的信息。它不是容器类（因为不能调整长度）。它针对处理长度在编译阶段已知的位序列进行了优化。\n> + 元素只能为0、1。\n\n#### std::bitset实例化\n\n```cpp\n//初始化位数为4，值为0000\nbitset<4> fourBits;\n//用字符串字面量的位序列初始化\nbitset<5> fiveBits(\"10101\");\n//拷贝构造\nbitset<5> fiveBitsCopy(fiveBits);\n//用十进制初始化,11111111（C++14新增）还可使用0b11111111\nbitset<8> eightBits(255);\n```\n\n> **位数在编译阶段已指定，不能动态改变。**\n\n#### std::bitset运算符\n\n```cpp\n#include <bitset>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    bitset<4> Bits1(7);\n    bitset<4> Bits2(8);\n\n    /*运算符*/\n    //<< : 输出\n    cout << \"Bits1:\" << Bits1 << endl;\n    cout << \"Bits2:\" << Bits2 << endl;\n    //按位与&\n    bitset<4> result(Bits1 & Bits2);\n    cout << \"Bits1 & Bits2:\" << result << endl;\n    //按位或|\n    result = Bits1 | Bits2;\n    cout << \"Bits1 | Bits2:\" << result << endl;\n    //按位异或^\n    result = Bits1 ^ Bits2;\n    cout << \"Bits1 ^ Bits2:\" << result << endl;\n    //按位取反~\n    result = ~Bits1;\n    cout << \"~Bits1:\" << result << endl;\n    //按位右移>>=\n    Bits1 >>= 2;\n    cout << \"Bits1>>=2:\" << Bits1 << endl;\n    //按位左移<<=\n    Bits1 <<= 2;\n    cout << \"Bits1<<=2:\" << Bits1 << endl;\n    //通过下标访问\n    Bits1[1] = 0;\n    cout << \"Bits[1]:\" << Bits1[1] << endl;\n\n    return 0;\n}\n\n/**输出\nBits1:0111\nBits2:1000\nBits1 & Bits2:0000\nBits1 | Bits2:1111\nBits1 ^ Bits2:1111\n~Bits1:1000\nBits1>>=2:0001\nBits1<<=2:0100\nBits[1]:0\n*/\n```\n\n#### std::bitset成员方法\n\n```cpp\nset();      //序列中的所有位设置为1\nset(N, 0);  //设置第N+1位为0\nreset();    //重置为0\nreset(N);   //第N+1为重置为0\nflip();     //所有位取反\nsize();     //返回位数\ncount();    //返回值为1的位数\n```\n\n```cpp\n#include <bitset>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    bitset<4> Bits;\n    cout << \"Bits:\" << Bits << endl;\n\n    Bits.set();\n    cout << \"Bits:\" << Bits << endl;\n    Bits.set(3, 0);\n    cout << \"Bits:\" << Bits << endl;\n    Bits.reset(0);\n    cout << \"Bits:\" << Bits << endl;\n    Bits.flip();\n    cout << \"Bits:\" << Bits << endl;\n    cout << \"Bits.count():\" << Bits.count() << endl;\n    cout << \"Bits.size():\" << Bits.size() << endl;\n    Bits.reset();\n    cout << \"Bits:\" << Bits << endl;\n\n    return 0;\n}\n\n/**输出\nBits:0000\nBits:1111\nBits:0111\nBits:0110\nBits:1001\nBits.count():2\nBits.size():4\nBits:0000\n*/\n```\n\n### vector<bool\\>\n\n> + 克服bitset类不能动态调整长度的缺点。可动态调整长度。\n> + 作为对`std::vector`的部分具体化，用于存储布尔数据。\n> + 头文件`#include<vector>`。\n\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid display(vector<bool> bools)\n{\n    for (size_t i = 0; i < bools.size(); i++)\n    {\n        cout << bools[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    //默认初始化为0\n    vector<bool> boolFlags1(4);\n    display(boolFlags1);\n    //构造包含10个元素,值为1(true)\n    vector<bool> boolFlags2(4, 1);\n    display(boolFlags2);\n    //列表初始化\n    vector<bool> boolFlags3{true, false, false, true};\n    display(boolFlags3);\n    //插入元素\n    boolFlags3.push_back(true);\n    display(boolFlags3);\n    //取反\n    boolFlags3.flip();\n    display(boolFlags3);\n    return 0;\n}\n\n/**输出\n0 0 0 0 \n1 1 1 1\n1 0 0 1\n1 0 0 1 1\n0 1 1 0 0\n*/\n```\n\n## 智能指针\n\n> + 简单来说，C++智能指针是包含重载运算符的类，其行为像常规指针，但智能指针能够及时、妥善地销毁动态分配的数据，并实现了明确的对象生命周期，因此更有价值。\n>\n> + 常规指针存在的问题：动态分配的对象没有正确地释放导致<font color=#ff0000>**内存泄漏**</font>。\n> + 智能指针类重载了解除引用运算符(*)和成员选择运算符(_>)，让程序员可以像使用常规指针那样使用它们。\n\n### 智能指针类型\n\n> 智能指针的分类实际上就是内存资源管理策略的分类，可分为：\n>\n> + 深拷贝\n> + 写时拷贝（Copy on Write, COW）\n> + 引用计数\n> + 引用链接\n> + 破坏性拷贝\n\n#### 深拷贝\n\n> + 在实现深拷贝的智能指针中，每个智能指针实例都保存一个它管理的对象的完整副本。\n> + 性能有所欠缺。\n\n#### 写时拷贝机制\n\n> + COW试图对深拷贝智能指针的性能进行优化。它共享指针，直到首次写入对象。\n\n#### 引用计数智能指针\n\n> + 引用计数是一种记录对象的用户数量的机制。当计数降低到0时，便将对象释放。\n> + 这种智能指针被复制时，需要将对象的引用计数加1。有两种常用方法来跟踪计数：\n>   + 在对象中维护引用计数。（修改对象以维护和递增引用计数，并将其提供给管理对象的智能指针。）\n>   + 引用计数由共享对象中的指针类维护。（智能指针类将计数保存在自由存储区，拷贝是拷贝构造函数将这个值加1。）\n> + 使用引用计数机制，只应通过智能指针来处理对象。\n> + 如果两个对象分别存储指向对方的指针，这两个对象永远不会被释放，因为他们的生命周期依赖性导致其引用计数最少为1。\n\n#### 引用链接智能指针\n\n> + 它不主动维护对象的引用计数，而只需知道计数什么时候变为0，以便能够释放对象。\n> + 其实现基于双向链表，通过拷贝智能指针来创建新智能指针时，新指针将被插入到链表中。\n> + 与引用计数一样，也存在生命周期依赖性导致的问题。\n\n#### 破坏性拷贝\n\n> + 在智能指针被拷贝时，将对象的所有权转交给目标指针并重置原来的指针。\n> + 因为它可确保任何时刻只有一个活动指针指向对象。因此，它非常适合从函数返回指针以及需要利用其“破坏性”的情形。\n\n### std::unique_str\n\n> + C++11新增，同时摒弃auto_str（一种基于破坏性复制的智能指针）。\n> + 头文件`#include<memeory>`。\n> + 它的拷贝构造函数和赋值运算符是私有的，因此不能复制它，即不能进行值传递，只能按引用传递。\n\n## 文件和流\n\n(图源网络[C++流(读写文件)__Space_的博客](https://blog.csdn.net/qq_45140193/article/details/119789181))\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204120852048.png)\n\n### C++流类和流对象\n\n(图源网络[C++流(读写文件)__Space_的博客](https://blog.csdn.net/qq_45140193/article/details/119789181))\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204120854656.png)\n\n> + cin遇到空格停止，这时应当使用getline()。\n\n| 类/对象          | 用途                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| cout             | 标准输出流                                                   |\n| cin              | 标准输入流                                                   |\n| cerr             | 用于显示错误信息的标准输出流                                 |\n| fstream          | 用于操作文件的输入输出流，继承了ofstream和ifstream           |\n| ofstream         | 用于操作文件的输出流类，即用于写入文件                       |\n| ifstream         | 用于操作文件的输入流类，即用于读取文件                       |\n| stringstream     | 用于操作字符串的输入输出流，继承了istringstream和ostringstream，通常用于在字符串和其他类型之间进行转换 |\n|                  |                                                              |\n| 输出控制符       |                                                              |\n| endl             | 插入一个换行符                                               |\n| ends             | 插入一个空字符                                               |\n| 基数控制符       |                                                              |\n| dec              | 让流以十进制方式解释输入或显示输出                           |\n| hex              | 让流以十六进制方式解释输入或显示输出                         |\n| oct              | 让流以八进制方式解释输入或显示输出                           |\n| 浮点数表示控制符 |                                                              |\n| fixed            | 让流以定点表示法显示数据                                     |\n| scientific       | 让流以科学表示法显示数据                                     |\n| <iomanip\\>控制符 |                                                              |\n| setprecision     | 设置小数精度                                                 |\n| setw             | 设置字段宽度                                                 |\n| setfill          | 设置填充字符                                                 |\n| setbase          | 设置基数，等效于dec/hex/oct                                  |\n| setiosflag       | 通过类型为std::ios_base::fmtflags的掩码输入参数设置标志      |\n| resetiosflag     | 将std::ios_base::fmtflags参数指定的标志重置为默认值          |\n\n### 文件流的操作模式\n\n| 模式标志    | 描述                                                   |\n| :---------- | :----------------------------------------------------- |\n| ios::app    | 附加到现有文件末尾，而不是覆盖。                       |\n| ios::ate    | 文件打开后定位到文件末尾。                             |\n| ios::in     | 以只读方式打开文件                                     |\n| ios::out    | 以只写方式打开文件                                     |\n| ios::trunc  | 如果该文件已经存在，则将其覆盖，这是ofstream默认设置。 |\n| ios::binary | 创建二进制文件                                         |\n\n### 文件流的状态检查\n\n| 状态      | 描述                                    |\n| --------- | --------------------------------------- |\n| is_open() | 文件流是否打开成功                      |\n| eof()     | 流是否结束                              |\n| fail()    | 流的failbit或者badbit被置位时, 返回true |\n| bad()     | 流的badbit置位时, 返回true              |\n| good()    | 流处于有效状态时, 返回true              |\n| clear()   | 流的所有状态都被复位                    |\n\n### 文件流的定位\n\n#### seekg\n\n> + 关于 istream\n> + 用于设置输入流的位置\n>\n> ```cpp\n> //参数1：偏移量  参数2：相对位置\n> //对于参数2：beg 相对于开始位置；cur 相对于当前位置；end 相对于结束位置\n> seekg(off_type offset, ios::seekdir origin);\n> //seekg(50,infile.beg);//表示定位到从文件开始的第50个字符后\n> //seekg(-50,infile.end);//表示定位到最后50个字符\n> //seekg(0,infile.end);//定位到文件末尾\n> ```\n\n#### tellg\n\n> + 返回该输入流的当前位置（距离文件的起始位置的偏移量）。\n>\n> ```cpp\n> //获取文件的长度\n> infile.seekg(0,infile.end);\n> int len = infile.tellg();\n> ```\n\n\n\n#### seekp\n\n> + 关于 ostream\n> + 设置输出流的位置\n> + 参数同seekg\n\n### cin & cout\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int input = 10;\n    cout << \"input an integer:\";\n    cin >> input;\n    cout << \"integer in Octal:\" << oct << input << endl;\n    cout << \"integer in Hexadecimal:\" << hex << input << endl;\n\n    double PI = 3.1415926;\n    cout << \"PI = \" << PI << endl;\n    cout << \"PI = \" << setprecision(7) << PI << endl;\n    cout << \"PI = \" << scientific << PI << endl;\n    cout << \"PI = \" << fixed << PI << endl;\n\n    string str = \"Hello World!\";\n    cout << str << endl;\n    //设置字段宽度\n    cout << setw(20) << str << endl;\n    // setfill()设置用什么字符来填充空白区域\n    cout << setw(20) << setfill('*') << str << endl;\n\n    // cin遇到空格停止插入,要读取整行,需要使用getline()\n    cout << \"input a string by getline():\";\n    getline(cin, str);\n    cout << str << endl;\n    return 0;\n}\n```\n\n### std::fstream\n\n> + 头文件`#include<fstream>`\n\n#### 打开文件\n\n> + 使用`open()`函数。\n> + 使用构造函数。\n> + 使用`is_open()`检测`open()`是否成功。\n\n#### 关闭文件\n\n> + 文件打开后必须关闭，`close()`。\n\n\n\n### 文本文件读取/写入\n\n> 直接使用运算符`<<`，`>>`。\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nvoid outputData()\n{\n    string name(\"I am a small bird!\");\n    int age = 30;\n    //如果不包含路径,则表示在当前工作目录(和cpp文件的同级目录)\n    string filename = \"user.txt\";\n\n    // ofstream的默认打开方式是,截断式写入 ios::out|ios::trunc\n    // fstream的默认打开方式是, ios::out\n    //建议指定打开方式\n    //文件不存在则创建\n    ofstream outfile;\n    // outfile.open(filename);\n    outfile.open(filename, ios::out | ios::trunc);\n    \n    //判断文件打开成功\n    if (outfile.is_open())\n    {\n        outfile << \"name: \" << name << endl\n                << \"age: \" << age << endl;\n\n        outfile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nvoid inputData()\n{\n    string name;\n    string line;\n    int age;\n    //使用构造函数打开文件\n    string filename = \"user.txt\";\n    ifstream infile(filename, ios::in);\n\n    if (infile.is_open())\n    {\n        while (1)\n        {\n            getline(infile, line);\n            if (infile.eof())\n            {\n                break;\n            }\n            cout << line << endl;\n        }\n\n        infile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nint main()\n{\n    outputData();\n    inputData();\n    return 0;\n}\n```\n\n### 二进制文件读取/写入\n\n> + 使用`write()`，`read()`。\n> + 将要读写的数据转换为C风格的字符（串）进行输入/输出。\n> + **指定了打开模式ios::binary，文件才能以二进制的方式操作，否则将以ASCII方式(文本文件)打开。**\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\n//这里可以看到:使用二进制读写文件,需要将数据转换为C风格的字符或字符串\nvoid outputBinaryData()\n{\n    string name(\"I am a small bird!\");\n    int age = 30;\n    string filename = \"user.dat\";\n\n    ofstream outfile;\n    outfile.open(filename, ios::out | ios::trunc | ios::binary);\n\n    if (outfile.is_open())\n    {\n        outfile.write((char *)&age, sizeof(int));\n        outfile.write(name.c_str(), sizeof(char) * (name.size()));\n\n        outfile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nvoid inputBinaryData()\n{\n    char line[256] = {0};\n    int age;\n    //指定了打开模式ios::binary,文件才能以二进制的方式操作,否则将以ASCII方式(文本文件)打开\n    string filename = \"user.dat\";\n    ifstream infile(filename, ios::in | ios::binary);\n\n    if (infile.is_open())\n    {\n        infile.read((char *)&age, sizeof(int));\n        infile.read(line, sizeof(char) * 256);\n\n        cout << \"age:\" << age << endl;\n        cout << \"line:\" << line << endl;\n\n        infile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nint main()\n{\n    outputBinaryData();\n    inputBinaryData();\n    return 0;\n}\n```\n\n### std::stringstream进行字符串转换\n\n> + 头文件`#include <sstream>`\n\n```cpp\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main()\n{\n    int input = 10;\n    int copy = 0;\n    string inputAsStr;\n    stringstream converterStream1;\n    converterStream1 << input;\n    converterStream1 >> inputAsStr;\n    stringstream converterStream2;\n    converterStream2 << inputAsStr;\n    converterStream2 >> copy;\n\n    // Integer <convert> String\n    cout << \"Integer Input = \" << input << endl;\n    cout << \"String gained from integer = \" << inputAsStr << endl;\n    cout << \"Integer gained from String, copy = \" << copy << endl;\n    return 0;\n}\n\n/**输出\nInteger Input = 10\nString gained from integer = 10\nInteger gained from String, copy = 10\n*/\n```\n\n### 总结\n\n> + **只想读取文件时，务必使用`ifstream`。**\n> + **只想写入文件时，务必使用`ofstream`。**\n> + **打开文件时，务必使用`is_open`判断打开成功。**\n> + **打开文件后，务必使用`close()`进行关闭。**\n> + **使用`cin>>`进行输入字符串时，遇到空格停止，此时应使用`getline()`。**\n\n<!--end in 2022.04.11-->\n\n## 异常处理\n\n### 异常\n\n> + 异常会打断应用程序的正常流程。\n> + 异常处理就是应对打断程序流程的特殊情形。\n> + 异常可能是外部因素导致的，如系统没有足够的内存；也可能是应用程序内部因素导致的，如除数为0。\n\n### 使用try-catch捕获异常\n\n1. 可使用`catch(...)`处理所有异常。参数`...`意味着catch块捕获所有的异常。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    try\n    {\n        int input = -1;\n\n        int *array = new int[input];\n        delete[] array;\n    }\n    catch (...)\n    {\n        cout << \"Exception occurred!\" << endl;\n    }\n    return 0;\n}\n```\n\n2. 捕获特定类型的异常。\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    try\n    {\n        int input = -1;\n\n        int *array = new int[input];\n        delete[] array;\n    }\n    catch (std::bad_alloc &exp) //捕获并处理内存分配异常\n    {\n        std::cout << \"Exception encountered: \" << exp.what() << std::endl;\n    }\n    catch (...) //捕获除了上述异常的其他所有异常\n    {\n        std::cout << \"Exception encountered!\" << std::endl;\n    }\n    return 0;\n}\n```\n\n3. 使用`throw`引发自定义异常\n\n### std::exception类\n\n> + `std::exception`异常基类，头文件`#include<exception>`。\n> + 重要的异常类（都是从std::exception派生而来）\n>   + `bad_alloc`：使用`new`请求申请内存失败时引发。\n>   + `bad_cast`：试图使用`dynamic_cast`转换错误类型时引发。\n>   + `ios_base::failure`：由`iostream`库中的函数和方法引发。\n> + `std::exception`定义了虚方法`what()`，它详细描述了导致异常的原因。\n> + 可以使用`catch(const std::exception& exp)`捕获所有以它作为基类的异常。\n> + 可以从`std::exception`派生出自定义异常类。\n\n## 编写实践\n\n> + 给变量指定有意义的名称。\n> + 对于int，float等变量，务必进行初始化。\n> + 务必将指针初始化为NULL或有效的地址。\n> + 使用数组时，务必不要访问越界！\n> + 不要使用C风格的字符串缓冲区（char*）及其相关函数和方法，而是使用std::string！\n> + 仅当确定要包含的元素数时才使用静态数组，否则，应使用动态数组。\n> + 如果类包含原始指针成员，务必考虑编写复制构造函数和重载赋值运算符。\n> + 正确的使用const。\n> + 尽可能避免使用原始指针，而使用智能指针。\n> + 务必使用模板而不是宏。\n> + 如果lambda表达式过于复杂或者有重用需求，务必将其转为函数对象。\n> + 务必捕获并处理所有可能引发的异常，如内存分配失败等。\n> + 绝不要在析构函数中引发异常。\n\n<!--总结：离谱整整拖了一个月才把这本书看完，中间拖了有好几天没有看，中途还因为图书超期了，先把书还了再重新借回来。不过，总算是看完了（走出了C++的第一步，之前本科学的感觉学了个寂寞）。-->\n\n<!--Completed by GuoJin Lv, 2022.04.13-->\n\n"},{"title":"A5算法","url":"/hexo-blog/2022/04/07/A5算法/","content":"\n## A5算法\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.04.07 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n+ A5是用于数据加密的。为了保护隐私，GSM网络上的所有空中传输都用称为A5的流密码进行加密。该算法有四个变体。\n+ A5/0是一种无操作密码，不对数据进行加密。\n+ A5/1是标准版本，是在20世纪80年代中期几个北约国家对该算法的强度发生争议后指定的。\n+ A5/2是一个弱化的版本，它被选择来处理对强密码的出口限制问题。\n+ A5/3是后来为3G网络（UMTS-GSM的继承者）添加的，是一种基于时钟密码的全新算法。\n\n### 算法步骤\n\n<img src=\"https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204020903100.png\" alt=\"A5/1\" style=\"zoom:150%;\" />\n\n1. A5/1算法使用3个**线性反馈移位寄存器，简称为LFSR**。三个寄存器的级数分别为19位、22位、23位。\n\n2. 每个回合步骤可以拆分为：反馈多项式（Feedback Polynomial），位移，取KEY，。\n\n   + <font color=#ff0000>**反馈多项式（Feedback Polynomial）**</font>\n\n     > LFSR进行位移的前置操作，具体可以分成两步：判定是否需要进行位移，判定新的充填的值。\n     >\n     > + **判定是否需要进行位移**\n     >\n     > > 这里使用的是**择多原则**，三个寄存器中选择三个钟控信号，级数19寄存器中的第8位，级数22寄存器、级数23寄存器中皆为第10位，两种二进制0、1，必定有0或1数量居多，居多的寄存器需要进行位移操作。\n     >\n     > + **判定新的充填的值**\n     >\n     > > 这里就需要使用**反馈多项式**。见上图。XOR后得到的值是填充到第0位的值。\n\n   + <font color=#ff0000>**位移**</font>\n\n     > 三个寄存器，由上一步的判定后进行位移（从低位到高位的左移），空出第0位用于填充反馈多项式得到的值。\n     >\n   + <font color=#ff0000>**取KEY**</font>\n\n     > 取三个寄存器的最后一位，也就是19位、22位、23位，进行XOR操作，得到的结果为这一轮Key的一位。\n\n### C++代码\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n/*定义三个LFSR*/\n//级数为19的R1\nvoid R1(bool r1[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r1[18] ^ r1[4] ^ r1[1] ^ r1[0];\n  bool temp = r1[18] ^ r1[17] ^ r1[16] ^ r1[13];\n  //低位像高位左移一位\n  for (size_t i = 18; i > 0; i--)\n  {\n    r1[i] = r1[i - 1];\n  }\n  //第0位填充temp\n  r1[0] = temp;\n}\n//级数为22的R2\nvoid R2(bool r2[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r2[21] ^ r2[0];\n  bool temp = r2[21] ^ r2[20];\n  //低位像高位左移一位\n  for (size_t i = 21; i > 0; i--)\n  {\n    r2[i] = r2[i - 1];\n  }\n  //第0位填充temp\n  r2[0] = temp;\n}\n//级数为23的R3\nvoid R3(bool r3[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r3[22] ^ r3[15] ^ r3[1] ^ r3[0];\n  bool temp = r3[22] ^ r3[21] ^ r3[20] ^ r3[7];\n  //低位像高位左移一位\n  for (size_t i = 22; i > 0; i--)\n  {\n    r3[i] = r3[i - 1];\n  }\n  //第0位填充temp\n  r3[0] = temp;\n}\n/**\n * @description: 生成密钥流\n * @param {int} n 需要生成的密钥数\n * @return {*}\n */\nbool *generate_key_stream(size_t n, bool r1[], bool r2[], bool r3[])\n{\n  bool *key_stream = (bool *)malloc(n * sizeof(bool));\n\n  for (size_t i = 0; i < n; i++)\n  {\n    bool m = (r1[8] + r2[10] + r3[10] >= 2) ? 1 : 0;\n    if (r1[8] == m)\n    {\n      R1(r1);\n    }\n    if (r2[10] == m)\n    {\n      R2(r2);\n    }\n    if (r3[10] == m)\n    {\n      R3(r3);\n    }\n    bool key = r1[18] ^ r2[21] ^ r3[22];\n    key_stream[i] = key;\n  }\n\n  return key_stream;\n}\n\nvoid print_data(bool r[], int length)\n{\n  for (int i = 0; i < length; i++)\n  {\n    if (i != length - 1)\n    {\n      cout << r[i] << \",\";\n    }\n    else\n    {\n      cout << r[i];\n    }\n  }\n  cout << endl;\n}\n\nint main()\n{\n  bool r1[19] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n  bool r2[22] = {1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1};\n  bool r3[23] = {1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};\n\n  size_t num = 64; //需要获取的密钥流位数\n\n  print_data(r1, 19);\n  print_data(r2, 22);\n  print_data(r2, 23);\n  cout << endl;\n\n  bool *key_stream = generate_key_stream(num, r1, r2, r3);\n\n  print_data(key_stream, num);\n\n  cout << endl;\n  print_data(r1, 19);\n  print_data(r2, 22);\n  print_data(r2, 23);\n\n  return 0;\n}\n```\n\n### 疑问\n\n1. 关于图中的Characteristic Polynomial的具体用处?\n","tags":["C-plus-plus","A5/1"],"categories":["课程作业"]},{"title":"LSTM算法的C语言实现","url":"/hexo-blog/2022/04/07/LSTM算法的C语言实现/","content":"\n# LSTM算法的C语言实现\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2022-04-11 -->\n> 更新：参考《LSTM还没“死”！》\n> <!-- endtimeline -->\n>\n> <!-- timeline 2022-04-07 -->\n> 第一次提交<!--某师兄的毕设相关，因为曾经有过相关基础，被导师叫来帮师兄打工。-->\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## LSTM简介\n\n> + LSTM(<font color=#ff0000>Long Short-Term Memory Networks,长短时记忆网络</font>)，由Hochreiter和Schmidhuber于1997年提出，目的是解决一般循环神经网络中存在的梯度爆炸（输入信息激活后权重过小）及梯度消失（例如sigmoid、tanh的激活值在输入很大时其梯度趋于零）问题，主要通过引入门和Cell状态的概念来实现梯度的调整，已被大量应用于时间序列预测等深度学习领域。\n>\n> +　早在1997年，LSTM在论文 《LONG SHORT-TERM MEMORY 》中被提出，直到2014年才进入高速发展阶段。它们属于循环神经网络家族- RNN，以及门控循环单元GRU。\n> +　LSTM有两个缺点：首先LSTM不容易在训练过程中并行化；其次由于它们具有周期性，它们可以建模的序列长度是有限制的。\n\n## LSTM算法流程\n\nLSTM采用了门控输出的方式，即<font color=#ff0000>**三门（输入门、遗忘门、输出门）两态（Cell State长时、Hidden State短时）**</font>。结构图如下所示（图源[Understanding LSTM Networks](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)）。作为机器学习算法的一种，LSTM 的预测过程也分为正向传播和反向传播两个过程。\n\n![LSTM结构示意图](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202205300922952.png)\n\n### 正向传播过程\n\n#### 隐藏层\n\n如上图所示，一个LSTM单元应当包含的权值参数有：\n$$\nW_{fh},W_{fx},b_{f},W_{ih},W_{ix},b_{i},W_{ch},W_{cx},b_{c},W_{oh},W_{ox},b_{o}\n$$\n\n> + $W_{fh}$：遗忘门与短时记忆的权值向量。\n> + $W_{fx}$：遗忘门与特征输入的权值向量。\n> + $b_{f}$：遗忘门的偏置。\n> + $W_{ih}$：输入门与短时记忆的权值向量。\n> + $W_{ix}$：输入门与特征输入的权值向量。\n> + $b_{i}$：输入门的偏置\n> + $W_{ch}$：产生新记忆信息部分与短时记忆的权值向量。\n> + $W_{cx}$：产生新记忆信息部分与特征输入的权值向量。\n> + $b_{c}$：产生新记忆信息部分的偏置\n> + $W_{oh}$：输出门与短时记忆的权值向量。\n> + $W_{ox}$：输出门与特征输入的权值向量。\n> + $b_{0}$：输出门的偏置\n\n> 设：\n>\n> + 序列总长度为：$n$，$t=1,2,...,n-1,n$。\n> + $t$时刻的特征输入向量：$x_{t}$。\n> + $t-1$时刻的短时记忆（$t-1$时刻LSTM单元的输出值）：$h_{t-1}$。\n> + sigmoid激活函数：$\\sigma(x)=\\frac{1}{1+e^{-x}}$。\n> + tanh激活函数：$tanh(x)$。\n> + 对于第一个时刻$t=1$，前一个时刻的$h_{0}=0$，$C_{0}=0$。\n\n##### 遗忘门\n\n遗忘门接收$h_{t-1}$和$x_{t}$，得到要舍弃的信息$f_{t}$，公式为：\n$$\nF_{t}=W_{fh}h_{t-1}+W_{fx}x_{t}+b_{f} \\tag{1}\n$$\n\n\n$$\nf_{t}=\\sigma(F_{t}) \\tag{2}\n$$\n\n##### 输入门\n\n输入门可分为两个部分：输入门部分和产生新记忆信息部分。\n\n+ 接收$h_{t-1}$和$x_{t}$，得到要更新的信息$i_{t}$，公式为：\n\n\n$$\nI_{t}=W_{ih}h_{t-1}+W_{ix}x_{t}+b_{i} \\tag{3}\n$$\n\n\n$$\ni_{t}=\\sigma(I_{t}) \\tag{4}\n$$\n\n+ 以及得到新的记忆信息$\\widetilde{c}_{t}$（这里的$\\widetilde{c}_{t}$代表的是图中的$\\widetilde{C}_{t}$），公式为：\n\n\n$$\n\\widetilde{C}_{t}=W_{ch}h_{t-1}+W_{cx}x_{t}+b_{c} \\tag{5}\n$$\n\n\n$$\n\\widetilde{c}_{t}=\\tanh(\\widetilde{C}_{t}) \\tag{6}\n$$\n\n##### 长时记忆部分\n\n由遗忘门和记忆门的信息可以得到$t$时刻的（长时记忆）状态值，公式为：\n$$\n{C}_{t}={C}_{t-1}f_{t}+i_{t}\\widetilde{c}_{t} \\tag{7}\n$$\n\n##### 输出门\n\n输出门接收$h_{t-1}$和$x_{t}$，得到要输出的信息（这是一个中间版本）$o_{t}$，公式为：\n\n$$\nO_{t}=W_{oh}h_{t-1}+W_{ox}x_{t}+b_{o} \\tag{8}\n$$\n\n\n$$\no_{t}=\\sigma(O_{t}) \\tag{9}\n$$\n\n##### 短时记忆部分\n\n并再根据长时记忆值得到最终LSTM单元的输出值（短时记忆），公式为：\n$$\nh_{t}=tanh(C_{t})\\ast o_{t} \\tag{10}\n$$\n\n#### 输出层\n\n如果LSTM隐层与输出层之间是全连接的，并且采用sigmoid激活函数，得到预测输出$\\hat{y}_{t}$，那么公式为：\n$$\n\\hat{Y}_{t}=W_{out}h_{t}+b_{out} \\tag{11}\n$$\n\n\n$$\n\\hat{y}_{t}=\\sigma(\\hat{Y}_{t}) \\tag{12}\n$$\n\n#### 损失函数\n\n损失函数用来评价模型的预测值和真实值不一样的程度。这里使用**MSE**(Mean Square Error, 均方差)来进行评估评估实际输出与期望输出的误差。MSE的公式为：（$\\hat{y}_{t}$为预测值，$y_{t}$标签值，$n$为序列长度）\n$$\nE=\\frac{1}{n}\\sum_{t=1}^{n}(\\hat{y}_t-y_{t})^{2} \\tag{13}\n$$\n\n### 反向传播过程\n\n反向传播就是根据正向传播的误差来求梯度，然后根据梯度调整原来的权重。\n\n> + sigmoid函数的导数为：${\\sigma}'(x)=\\sigma(x) \\ast (1-\\sigma(x))$。\n> + tanh函数的导数为：${tanh}'(x)=1-tanh^{2}(x)$。\n> + 使用$grad(x)$来代表误差$E$关于$x$的梯度。\n> + 对于最后一个时刻$t=n$，需要参与计算的$C_{n+1}$，$f_{n+1}$，$i_{n+1}$，$\\hat{c}_{n+1}$，$o_{n+1}$都为0。\n\n#### 关于输出层的梯度\n\n对预测值的梯度计算：\n$$\ngrad(\\hat{y}_{t})=\\frac{\\partial{E}}{\\partial{\\hat{y}_{t}}}=\\frac{2}{n}(\\hat{y}_{t}-y_{t}) \\tag{14}\n$$\n\n$$\ngrad(\\hat{Y}_{t})=\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=\\frac{\\partial{\\hat{y}}_{t}}{\\partial{\\hat{Y}}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{y}}_{t}}={\\sigma}'(x)\\ast grad(\\hat{y}_{t}) \\tag{15}\n$$\n\n对隐层与输出层之间的连接权值的梯度计算：\n$$\ngrad(W_{out})=\\frac{\\partial{E}}{\\partial{W}_{out}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{W}_{out}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=h_{t}\\ast grad(\\hat{Y}_{t}) \\tag{16}\n$$\n\n$$\ngrad(b_{out})=\\frac{\\partial{E}}{\\partial{b}_{out}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{b}_{out}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=grad(\\hat{Y}_{t}) \\tag{17}\n$$\n\n#### 隐层（LSTM单元）——关于短时记忆的梯度\n\n​\t\t**对于$h_t$，由公式$(1)$、$(3)$、$(5)$、$(8)$、$(11)$可知，由于其既是当前时刻输出层的输入，又参与了下一个时刻LSTM单元的输入**，因此下列计算得到的梯度只是$grad(h_{t})$的一部分，其余部分见公式$(34)$、$(38)$、$(42)$、 $(46)$。最后的$grad(h_{t})$见公式$(47)$。\n$$\ngrad(h^{1}_{t})=\\frac{\\partial{E}}{\\partial{h}_{t}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=W_{out}\\ast grad(\\hat{Y}_{t}) \\tag{18}\n$$\n\n#### 隐层（LSTM单元）——关于长时记忆的梯度\n\n由公式$(7)$、$(10)$可知，$C_{t}$的梯度计算既参与计算下一个时刻的$C_{t+1}$，也参与当前时刻的$h_{t}$的计算。因此由公式$(19)$、$(21)$得到$grad(C_{t})$见公式$(22)$。\n$$\ngrad(C^{1}_{t})=\\frac{\\partial{E}}{\\partial{C_{t}}}=\\frac{\\partial{h}_{t}}{\\partial{C}_{t}}\\ast\\frac{\\partial{E}}{\\partial{h}_{t}}={tanh}'(C_{t})\\ast o_{t}\\ast grad(h_{t}) \\tag{19}\n$$\n\n$$\ngrad(C^{1}_{t-1})=\\frac{\\partial{E}}{\\partial{C_{t-1}}}=\\frac{\\partial{C}_{t}}{\\partial{C}_{t-1}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=f_{t}\\ast grad(C_{t}) \\tag{20}\n$$\n\n$$\ngrad(C^{2}_{t})=\\frac{\\partial{E}}{\\partial{C_{t}}}=\\frac{\\partial{C}_{t+1}}{\\partial{C}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t+1}}=f_{t+1}\\ast grad(C_{t+1}) \\tag{21}\n$$\n\n$$\ngrad(C_{t})=grad(C^{1}_{t})+grad(C^{2}_{t})={tanh}'(C_{t})\\ast o_{t}\\ast grad(h_{t})+f_{t+1}\\ast grad(C_{t+1}) \\tag{22}\n$$\n\n#### 关于隐层（LSTM单元）——关于三门各自输出的梯度\n\n由公式$(7)$、$(10)$计算，关于遗忘门输出的梯度为：\n$$\ngrad(f_{t})=\\frac{\\partial{E}}{\\partial{f_{t}}}=\\frac{\\partial{C}_{t}}{\\partial{f}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=C_{t-1}\\ast grad(C_{t}) \\tag{23}\n$$\n\n$$\ngrad(F_{t})=\\frac{\\partial{E}}{\\partial{F_{t}}}=\\frac{\\partial{f}_{t}}{\\partial{F}_{t}}\\ast\\frac{\\partial{E}}{\\partial{f}_{t}}={\\sigma}'(F_{t})\\ast grad(f_{t}) \\tag{24}\n$$\n\n关于输入门输出的梯度为：\n$$\ngrad(i_{t})=\\frac{\\partial{E}}{\\partial{i_{t}}}=\\frac{\\partial{C}_{t}}{\\partial{i}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=\\widetilde{C}_{t}\\ast grad(C_{t}) \\tag{25}\n$$\n\n$$\ngrad(I_{t})=\\frac{\\partial{E}}{\\partial{I_{t}}}=\\frac{\\partial{i}_{t}}{\\partial{I}_{t}}\\ast\\frac{\\partial{E}}{\\partial{i}_{t}}={\\sigma}'(I_{t})\\ast grad(i_{t}) \\tag{26}\n$$\n\n关于新记忆信息输出的梯度为：\n$$\ngrad(\\widetilde{c}_{t})=\\frac{\\partial{E}}{\\partial{\\widetilde{c}_{t}}}=\\frac{\\partial{C}_{t}}{\\partial\\widetilde{c}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}={i}_{t}\\ast grad(C_{t}) \\tag{27}\n$$\n\n$$\ngrad(\\widetilde{C}_{t})=\\frac{\\partial{E}}{\\partial{\\widetilde{C}_{t}}}=\\frac{\\partial{\\widetilde{c}}_{t}}{\\partial{\\widetilde{C}}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{c}}_{t}}={tanh}'(\\widetilde{C}_{t})\\ast grad(\\widetilde{c}_{t}) \\tag{28}\n$$\n\n关于输出门输出的梯度为：\n$$\ngrad(o_{t})=\\frac{\\partial{E}}{\\partial{o_{t}}}=\\frac{\\partial{h}_{t}}{\\partial{o}_{t}}\\ast\\frac{\\partial{E}}{\\partial{h}_{t}}=tanh(C_{t})\\ast grad(h_{t}) \\tag{29}\n$$\n\n$$\ngrad(O_{t})=\\frac{\\partial{E}}{\\partial{O_{t}}}=\\frac{\\partial{o}_{t}}{\\partial{O}_{t}}\\ast\\frac{\\partial{E}}{\\partial{o}_{t}}={\\sigma}'(O_{t})\\ast grad(o_{t}) \\tag{30}\n$$\n\n#### 关于隐层（LSTM单元）——关于输出门连接权的梯度\n\n\n$$\ngrad(W_{oh})=\\frac{\\partial{E}}{\\partial{W}_{oh}}=\\frac{\\partial{O}_{t}}{\\partial{W}_{oh}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=h_{t-1}\\ast grad({O}_{t}) \\tag{31}\n$$\n\n$$\ngrad(W_{ox})=\\frac{\\partial{E}}{\\partial{W}_{ox}}=\\frac{\\partial{O}_{t}}{\\partial{W}_{ox}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=x_{t}\\ast grad({O}_{t}) \\tag{32}\n$$\n\n$$\ngrad(b_{o})=\\frac{\\partial{E}}{\\partial{b}_{o}}=\\frac{\\partial{O}_{t}}{\\partial{b}_{o}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=grad({O}_{t}) \\tag{33}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第2部分梯度：\n$$\ngrad(h^{2}_{t})=\\frac{\\partial{E}}{\\partial{h}^{2}_{t}}=\\frac{\\partial{O}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t+1}}=W_{oh}\\ast grad({O}_{t+1}) \\tag{34}\n$$\n\n#### 关于隐层（LSTM单元）——关于产生新记忆信息部分连接权的梯度\n\n\n$$\ngrad(W_{ch})=\\frac{\\partial{E}}{\\partial{W}_{ch}}=\\frac{\\partial\\widetilde{C}_{t}}{\\partial{W}_{ch}} \\ast \\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=h_{t-1}\\ast grad(\\widetilde{C}_{t}) \\tag{35}\n$$\n\n$$\ngrad(W_{cx})=\\frac{\\partial{E}}{\\partial{W}_{cx}}=\\frac{\\partial{\\widetilde{C}}_{t}}{\\partial{W}_{cx}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=x_{t}\\ast grad({\\widetilde{C}}_{t}) \\tag{36}\n$$\n\n$$\ngrad(b_{c})=\\frac{\\partial{E}}{\\partial{b}_{c}}=\\frac{\\partial{\\widetilde{C}}_{t}}{\\partial{b}_{c}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=grad({\\widetilde{C}}_{t}) \\tag{37}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第3部分梯度：\n$$\ngrad(h^{3}_{t})=\\frac{\\partial{E}}{\\partial{h}^{3}_{t}}=\\frac{\\partial{\\widetilde{C}}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t+1}}=W_{ch}\\ast grad({\\widetilde{C}}_{t+1}) \\tag{38}\n$$\n\n#### 关于隐层（LSTM单元）——关于输入门连接权的梯度\n\n\n$$\ngrad(W_{ih})=\\frac{\\partial{E}}{\\partial{W}_{ih}}=\\frac{\\partial{I}_{t}}{\\partial{W}_{ih}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=h_{t-1}\\ast grad({I}_{t}) \\tag{39}\n$$\n\n$$\ngrad(W_{ix})=\\frac{\\partial{E}}{\\partial{W}_{ix}}=\\frac{\\partial{I}_{t}}{\\partial{W}_{ix}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=x_{t}\\ast grad({I}_{t}) \\tag{40}\n$$\n\n$$\ngrad(b_{i})=\\frac{\\partial{E}}{\\partial{b}_{i}}=\\frac{\\partial{I}_{t}}{\\partial{b}_{i}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=grad({I}_{t}) \\tag{41}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第4部分梯度：\n$$\ngrad(h^{4}_{t})=\\frac{\\partial{E}}{\\partial{h}^{4}_{t}}=\\frac{\\partial{I}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t+1}}=W_{ih}\\ast grad({I}_{t+1}) \\tag{42}\n$$\n\n#### 关于隐层（LSTM单元）——关于遗忘门连接权的梯度\n\n\n$$\ngrad(W_{fh})=\\frac{\\partial{E}}{\\partial{W}_{fh}}=\\frac{\\partial{F}_{t}}{\\partial{W}_{fh}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=h_{t-1}\\ast grad({F}_{t}) \\tag{43}\n$$\n\n$$\ngrad(W_{fx})=\\frac{\\partial{E}}{\\partial{W}_{fx}}=\\frac{\\partial{F}_{t}}{\\partial{W}_{fx}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=x_{t}\\ast grad({F}_{t}) \\tag{44}\n$$\n\n$$\ngrad(b_{f})=\\frac{\\partial{E}}{\\partial{b}_{f}}=\\frac{\\partial{F}_{t}}{\\partial{b}_{f}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=grad({F}_{t}) \\tag{45}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第5部分梯度：\n$$\ngrad(h^{5}_{t})=\\frac{\\partial{E}}{\\partial{h}^{5}_{t}}=\\frac{\\partial{F}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t+1}}=W_{fh}\\ast grad({F}_{t+1}) \\tag{46}\n$$\n\n这里将上述计算的部分梯度累加，得到关于短时记忆$h_{t}$的梯度：\n$$\ngrad(h_{t})=grad(h^{1}_{t})+grad(h^{2}_{t})+grad(h^{3}_{t})+grad(h^{4}_{t})+grad(h^{5}_{t}) \\tag{47}\n$$\n\n## LSTM的C语言实现\n\n> 实现单向的、一层的LSTM。\n\n### 读取数据集\n\n#### 需求背景\n\n假设有这样一个需求：城市的货运量受不同产业GDP、市场消费额度、居民可支配收入等因素的影响，需要根据某城市上一年的货运量预测下一年的货运量，给定数据集如下：\n\n| YEAR | GDP1   | GDP2    | GDP3    | AC      | TI       | VI       | TARGET   |\n| ---- | ------ | ------- | ------- | ------- | -------- | -------- | -------- |\n| 2002 | 90.4   | 635.5   | 741.9   | 798.64  | 7820.24  | 3295     | 15942.57 |\n| 2003 | 95.13  | 701.87  | 825.18  | 885.69  | 8524.52  | 3497     | 16609.79 |\n| 2004 | 102.23 | 825.78  | 954.23  | 996.22  | 9564.05  | 3954.5   | 17044.8  |\n| 2005 | 109.57 | 1026.27 | 1125.33 | 1128.64 | 10849.72 | 4341     | 19611.72 |\n| 2006 | 115.91 | 1205.42 | 1358    | 1293.33 | 12360    | 4748     | 20485.76 |\n| 2007 | 129.15 | 1440    | 1540.32 | 1518.3  | 14357.64 | 5371     | 22554.93 |\n| 2008 | 144.7  | 1867.21 | 2103.6  | 1850.05 | 16712.44 | 6349     | 29142.98 |\n| 2009 | 149.06 | 2142.14 | 2329.66 | 2164.09 | 18385.02 | 7161     | 34208.9  |\n| 2010 | 170.04 | 2532.82 | 2863.07 | 2570.4  | 20806.32 | 8294.81  | 40287.93 |\n| 2011 | 198.7  | 3254.02 | 3309.48 | 3031.79 | 23738    | 9814     | 41804.45 |\n| 2012 | 301.21 | 3859.56 | 3843.05 | 3467.37 | 27061    | 11190    | 43892.49 |\n| 2013 | 335.4  | 4396.17 | 4319.7  | 3916.6  | 29821.22 | 12713    | 44528.75 |\n| 2014 | 350.06 | 4785.66 | 4933.76 | 4573.54 | 33270.39 | 16160.14 | 48529.99 |\n| 2015 | 359.81 | 4981.54 | 5564.25 | 5102.24 | 36436    | 17722.18 | 48185.19 |\n| 2016 | 390.62 | 5227.05 | 6294.94 | 5610.59 | 39737    | 19152    | 49981.81 |\n| 2017 | 408.2  | 5862.35 | 7140.49 | 6196.3  | 43405    | 20887    | 57271.17 |\n\n分析数据集可知：\n\n+ 给定的是某个城市的数据，因此$样本数=1$。\n+ 第1列为年份，因此可知$数据集行数(减去第一行)=时间序列的长度$。\n+ 第2-7列为影响货运量的输入，即为$特征输入维度=6$。\n+ 第8列为货运量，即为$标签值$。\n\n#### 代码实现\n\n> 注：以下代码，声明放在.h文件中，定义放在.c文件中。\n\n```cpp\n//获取行列数\nvoid get_row_and_column(char *filename, int *row, int *column);\n//读取数据\nvoid read_data(double **data, char *filename);\n```\n\n```cpp\n//获取行列数\nvoid get_row_and_column(char *filename, int *row, int *column)\n{\n\tchar line[1024];\n\tFILE *fp = fopen(filename, \"r\");\n\tint i = 0, j = 0;\n\t/*先读取第一行，以便从中划分出列*/\n\tfgets(line, 1024, fp);\n\ti++;\n\tconst char *delim = \",\"; //分节符为逗号\n\tchar *token = strtok(line, delim);\n\twhile (token)\n\t{\n\t\ttoken = strtok(NULL, delim);\n\t\tj++;\n\t}\n\t/*继续读取每一行， 计算行数*/\n\twhile (fgets(line, 1024, fp))\n\t{\n\t\ti++;\n\t}\n\t*row = i;\n\t*column = j;\n\n\tfclose(fp);\n}\n\n// 获取完整数据集\nvoid read_data(double **data, char *filename)\n{\n\tchar line[1024];\n\tFILE *stream = fopen(filename, \"r\");\n\tint i = 0;\n\t//过滤掉第一行\n\tfgets(line, 1024, stream);\n\twhile (fgets(line, 1024, stream)) //逐行读取\n\t{\n\t\tint j = 0;\n\t\tchar *tok;\n\t\t//这里过滤掉第一列\n\t\ttok = strtok(line, \",\");\n\t\ttok = strtok(NULL, \",\");\n\t\tfor (; tok && *tok; j++, tok = strtok(NULL, \",\"))\n\t\t{\n\t\t\tdata[i][j] = atof(tok); //转换成浮点数\n\t\t}                         //字符串拆分操作\n\t\ti++;\n\t}\n\tfclose(stream); //文件打开后要进行关闭操作\n\n}\n```\n\n### 数据标准化\n\n这里采用最大最小标准化方式，将原数据线性映射到$[0,1]$之间。公式为：\n$$\nx^{*}=\\frac{x-min}{max-min} \\tag{48}\n$$\n这里对每列数据求得的最大最小值需要保存下来，用于后面的数据还原操作；该值也需要保存为模型参数，后续使用该模型来预测时，测试数据的标准化依赖于这两个值。\n\n```cpp\n//数据标准化:最大最小标准化\nvoid normalize_dataset(double **dataset, int row, int col);\n//数据还原，返回原来值\ndouble restore_data(double y_data, int col_number); //col_number：在原来数据集中的列号,从0开始的\n```\n\n```cpp\ndouble *MAX = NULL;  //保存每列数据的最大值\ndouble *MIN = NULL;  //保存每列数据的最小值\n\n//数据标准化\nvoid normalize_dataset(double **dataset, int row, int col)\n{\n\tMAX = (double*)malloc(col * sizeof(double));\n\tMIN = (double*)malloc(col * sizeof(double));\n\n\t// 先 对列循环\n\tdouble maximum, minimum;\n\tfor (int i = 0; i < col; i++)\n\t{\n\t\tmaximum = dataset[0][i];\n\t\tminimum = dataset[0][i];\n\t\t//再 对行循环\n\t\tfor (int j = 0; j < row; j++)\n\t\t{\n\t\t\tmaximum = (dataset[j][i] > maximum) ? dataset[j][i] : maximum;\n\t\t\tminimum = (dataset[j][i] < minimum) ? dataset[j][i] : minimum;\n\t\t}\n\t\t// 归一化处理\n\t\tfor (int j = 0; j < row; j++)\n\t\t{\n\t\t\tdataset[j][i] = (dataset[j][i] - minimum) / (maximum - minimum);\n\t\t}\n\n\t\tMAX[i] = maximum;\n\t\tMIN[i] = minimum;\n\t}\n}\n\n//数据还原\ndouble restore_data(double y_data, int col_number)\n{\n\ty_data = (y_data * (MAX[col_number] - MIN[col_number])) + MIN[col_number];\n\n\treturn y_data;\n}\n```\n\n### 损失函数\n\n```cpp\n//损失函数:均方差MSE\n//输入：实际标签值；预测值；时间序列长度\ndouble mse(double *actual, double *predicted, int n);\n```\n\n```cpp\n//损失函数\ndouble mse(double *actual, double *predicted, int n)\n{\n\tdouble sum_err = 0.0;\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tdouble err = predicted[i] - actual[i];\n\t\tsum_err += err * err;\n\t}\n\tdouble mean_err = sum_err / n;\n\treturn mean_err;\n}\n```\n\n### 评价指标\n\n这里采用**MAPE**（Mean Absolute Percentage Error，平均绝对百分比误差）。公式为：\n$$\nMAPE=\\frac{100\\%}{n} \\sum^{n}_{t=1}{|{\\frac{\\hat{y}_{t}-y_{t}}{y_{t}}|}} \\tag{49}\n$$\n\n> + 范围[0,+∞)，MAPE 为0%表示完美模型，MAPE 大于 100 %则表示劣质模型。\n> + 根据公式，分母不能为0，因此标签值不能为0。所以需要对标准化的标签数据进行还原。\n\n```cpp\n//预测评价指标：平均绝对百分比误差MAPE\ndouble mape(double *actual, double *predicted, int n);\n```\n\n```cpp\n//预测评价指标\ndouble mape(double *actual, double *predicted, int n)\n{\n\tdouble sum_err = 0.0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsum_err += fabs((predicted[i] - actual[i]) / actual[i]);\n\t}\n\tdouble mean_err = sum_err / n;\n\treturn mean_err;\n}\n```\n\n### 激活函数及其导数\n\n```cpp\n//激活函数及其导数\ndouble sigmoid(double x);\ndouble dsigmoid(double y);\ndouble dtanh(double y);\n```\n\n```cpp\n//simoid函数\ndouble sigmoid(double x)\n{\n\treturn 1.0 / (1.0 + exp(-x));\n}\n\n//simoid的导数，y为simoid值\ndouble dsigmoid(double y)\n{\n\treturn y * (1.0 - y);\n}\n\n// tanh的导数，y为tanh值\ndouble dtanh(double y)\n{\n\treturn 1.0 - y * y;\n}\n```\n\n### 优化算法\n\n这里采用的是Adam（Adaptive Moment Estimation，自适应矩估计）算法。\n\n> 设在$t$时刻下：\n>\n> + $w_{t}$为权重，$g_{t}$为$w_{t}$的梯度，$m_{t}$为$w_{t}$的一阶矩估计，$r_{t}$为$w_{t}$的二阶矩估计。\n> + $\\alpha$为学习率，$\\beta_{1}$和$\\beta_{2}$为控制指数衰减的常数，$\\epsilon$为用于数值稳定的常数。\n> + $\\alpha$一般需要调节，其他均可采用默认设置：$\\beta_{1}=0.9$，$\\beta_{2}=0.999$，$\\epsilon=10^{-8}$。\n\n算法流程如下：\n\n>1. 更新一阶矩估计$m_{t}$：$m_{t}=\\beta_{1} \\ast m_{t-1}+(1-\\beta_{1}) \\ast g_{t}$\n>\n>2. 更新二阶矩估计$r_{t}$：$r_{t}=\\beta_{2} \\ast r_{t-1}+(1-\\beta_{2}) \\ast g_{t}^{2}$\n>3. 求得$m_{t}$的偏差修正$\\hat{m}_{t}$：$\\hat{m}_{t}=\\frac{m_{t}}{1-\\beta_{1}}$\n>4. 求得$r_{t}$的偏差修正$\\hat{r}_{t}$：$\\hat{r}_{t}=\\frac{r_{t}}{1-\\beta_{2}}$\n>5. 更新权重$w_{t}$：$w_{t}=w_{t-1}-\\alpha \\ast  \\frac{\\hat{m}_{t}}{\\sqrt{\\hat{r}_{t}}+\\epsilon}$\n\n```cpp\n//优化算法: Adam算法\n//输入: 权重,一阶矩估计,二阶矩估计,学习率,w的梯度dw，beta1、beta2为矩估计的指数衰减速率,epsilon为步长\nvoid adam(double* w, double* m, double* r, double g, double l_rate, double beta1, double beta2, double epsilon);\n```\n\n> 注：这里的函数形参采用指针形式传入地址，以修改值。\n\n```cpp\n//优化算法: Adam算法\n//输入: 权重,一阶矩估计,二阶矩估计,w的梯度dw，学习率,beta1、beta2为矩估计的指数衰减速率,epsilon为步长\nvoid adam(double* w, double* m, double* r, double g, double l_rate, double beta1, double beta2, double epsilon)\n{\n\tdouble temp_w = *w;\n\tdouble temp_m = *m;\n\tdouble temp_r = *r;\n\n\ttemp_m = beta1 * temp_m + (1 - beta1)*g;//一阶矩：梯度的指数移动平均值\n\ttemp_r = beta2 * temp_r + (1 - beta2)*g*g;//二阶矩：平方梯度\n\n\t//偏差修正\n\tdouble temp_m_correction = temp_m / (1 - beta1); \n\tdouble temp_r_correction = temp_r / (1 - beta2);\n\n\t//更新权重\n\ttemp_w = temp_w - l_rate * ((temp_m_correction) / (sqrt(temp_r_correction) + epsilon));\n\n\t*w = temp_w;\n\t*m = temp_m;\n\t*r = temp_r;\n}\n```\n\n### 构建LSTM网络\n\n> + 定义全局的二维数组作为权值矩阵，并在开始时分配内存，在结束时释放。\n> + 由优化算法可知，每个权值都有对应的一阶矩估计和二阶矩估计，因此需要定义的参数除了上述算法中的$(12+2)$个之外，还需要$(12+2)*2$个参数，总共$14*3=42$个参数。\n> + **不足之处：为了更好的可扩展性和可读性，事实上应当定义一个LSTM单元为结构体**。\n> + 网络建立后就需要对权值进行初始化，这里采用正太分布初始化权重，一、二阶矩估计和偏置初始化为0。\n\n```cpp\n//随机数生成\ndouble normal_standard(); //标准正态分布随机数生成\ndouble normal(double mean, double stdev); //正太分布随机数生成：指定期望为mean，方差为stdev\n//构建网络：申请内存建立权重数组，初始化权重\n//输入：特征维度；隐层节点数（LSTM单元数）\nvoid init_normal_weight(int dim, int hidenode_num); //正太分布初始化\n```\n\n```cpp\n/* F_t = sigmoid(X_t * W_fx + H_pre * W_fh + B_f) */\ndouble** W_fx = NULL;   //连接输入X_t与本细胞中遗忘门的权值矩阵\ndouble** W_fx_m = NULL; //adam优化算法的权值参数\ndouble** W_fx_r = NULL; //adam优化算法的权值参数\ndouble** W_fh = NULL;   //连接上一细胞输出H_pre与本细胞中遗忘门的权值矩阵\ndouble** W_fh_m = NULL;\ndouble** W_fh_r = NULL;\ndouble* B_f = NULL;     //偏置\ndouble* B_f_m = NULL;\ndouble* B_f_r = NULL;\n/* I_t = sigmoid(X_t * W_ix + H_pre * W_ih + B_i) */\ndouble** W_ix = NULL;  \ndouble** W_ix_m = NULL;\ndouble** W_ix_r = NULL;\ndouble** W_ih = NULL;\ndouble** W_ih_m = NULL;\ndouble** W_ih_r = NULL;\ndouble* B_i = NULL;\ndouble* B_i_m = NULL;\ndouble* B_i_r = NULL;\n/* O_t = sigmoid(X_t * W_ox + H_pre * W_oh + B_o) */\ndouble** W_ox = NULL;     \ndouble** W_ox_m = NULL;\ndouble** W_ox_r = NULL;\ndouble** W_oh = NULL; \ndouble** W_oh_m = NULL;\ndouble** W_oh_r = NULL;\ndouble* B_o = NULL;\ndouble* B_o_m = NULL;\ndouble* B_o_r = NULL;\n/* C`_t = tanh(X_t * W_cx + H_pre * W_ch + B_c) */\ndouble** W_cx = NULL; \ndouble** W_cx_m = NULL;\ndouble** W_cx_r = NULL;\ndouble** W_ch = NULL;\ndouble** W_ch_m = NULL;\ndouble** W_ch_r = NULL;\ndouble* B_c = NULL;\ndouble* B_c_m = NULL;\ndouble* B_c_r = NULL;\n/* Y_t = sigmoid(H_t * W_out + b_out)*/\ndouble* W_out = NULL; \ndouble* W_out_m = NULL;\ndouble* W_out_r = NULL;\ndouble b_out;\ndouble b_out_m;\ndouble b_out_r;\n\n// Box-Muller法\n//生成的正太分布随机数序列的期望为0.0，方差为1.0。若指定期望为E，标准为V，则只需增加：X = X * V + E;\ndouble normal_standard()\n{\n\tstatic double U, V, S;\n\tstatic int phase = 0;\n\tdouble X;\n\t// srand((unsigned int)time(NULL));\n\tif (phase == 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\tU = (double)rand() / RAND_MAX;\n\t\t\tV = (double)rand() / RAND_MAX;\n\t\t\tU = 2 * U - 1;\n\t\t\tV = 2 * V - 1;\n\t\t\tS = U * U + V * V;\n\t\t} while (S >= 1 || S == 0);\n\t\tX = U * sqrt(-2 * log(S) / S);\n\t}\n\telse\n\t{\n\t\tX = U * sqrt(-2 * log(S) / S);\n\t}\n\tphase = 1 - phase;\n\treturn X;\n}\n\n//正太分布随机数生成：指定期望为mean，标准差为stdev\ndouble normal(double mean, double stdev)\n{\n\treturn mean + stdev * normal_standard();\n}\n\n/* 建立权重数组，初始化权重 */\nvoid init_normal_weight(int dim, int hidenode_num) //正太分布初始化\n{\n\tint i, j;\n\tdouble mean = 0.0, stdev = 0.001;\n\n\tW_ix = (double **)malloc(dim * sizeof(double *));\n\tW_fx = (double **)malloc(dim * sizeof(double *));\n\tW_ox = (double **)malloc(dim * sizeof(double *));\n\tW_cx = (double **)malloc(dim * sizeof(double *));\n\tW_ix_m = (double **)malloc(dim * sizeof(double *));\n\tW_fx_m = (double **)malloc(dim * sizeof(double *));\n\tW_ox_m = (double **)malloc(dim * sizeof(double *));\n\tW_cx_m = (double **)malloc(dim * sizeof(double *));\n\tW_ix_r = (double **)malloc(dim * sizeof(double *));\n\tW_fx_r = (double **)malloc(dim * sizeof(double *));\n\tW_ox_r = (double **)malloc(dim * sizeof(double *));\n\tW_cx_r = (double **)malloc(dim * sizeof(double *));\n\tfor (i = 0; i < dim; i++)\n\t{\n\t\tW_ix[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ix_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ix_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tW_ix[i][j] = normal(mean, stdev);\n\t\t\tW_fx[i][j] = normal(mean, stdev);\n\t\t\tW_ox[i][j] = normal(mean, stdev);\n\t\t\tW_cx[i][j] = normal(mean, stdev);\n\n\t\t\tW_ix_m[i][j] = 0;\n\t\t\tW_fx_m[i][j] = 0;\n\t\t\tW_ox_m[i][j] = 0;\n\t\t\tW_cx_m[i][j] = 0;\n\n\t\t\tW_ix_r[i][j] = 0;\n\t\t\tW_fx_r[i][j] = 0;\n\t\t\tW_ox_r[i][j] = 0;\n\t\t\tW_cx_r[i][j] = 0;\n\t\t}\n\t}\n\t\n\tW_ih = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ih_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ih_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch_r = (double **)malloc(hidenode_num * sizeof(double *));\n\n\tB_i = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c = (double *)malloc(hidenode_num * sizeof(double));\n\tB_i_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_i_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c_r = (double *)malloc(hidenode_num * sizeof(double));\n\n\tW_out = (double *)malloc(hidenode_num * sizeof(double));\n\tW_out_m = (double *)malloc(hidenode_num * sizeof(double));\n\tW_out_r = (double *)malloc(hidenode_num * sizeof(double));\n\n\tfor (i = 0; i < hidenode_num; i++)\n\t{\n\t\tW_ih[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ih_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ih_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tW_ih[i][j] = normal(mean, stdev);\n\t\t\tW_fh[i][j] = normal(mean, stdev);\n\t\t\tW_oh[i][j] = normal(mean, stdev);\n\t\t\tW_ch[i][j] = normal(mean, stdev);\n\n\t\t\tW_ih_m[i][j] = 0;\n\t\t\tW_fh_m[i][j] = 0;\n\t\t\tW_oh_m[i][j] = 0;\n\t\t\tW_ch_m[i][j] = 0;\n\n\t\t\tW_ih_r[i][j] = 0;\n\t\t\tW_fh_r[i][j] = 0;\n\t\t\tW_oh_r[i][j] = 0;\n\t\t\tW_ch_r[i][j] = 0;\n\t\t}\n\t\tB_f[i] = 0.0;\n\t\tB_i[i] = 0.0;\n\t\tB_c[i] = 0.0;\n\t\tB_o[i] = 0.0;\n\n\t\tB_f_m[i] = 0.0;\n\t\tB_i_m[i] = 0.0;\n\t\tB_c_m[i] = 0.0;\n\t\tB_o_m[i] = 0.0;\n\n\t\tB_f_r[i] = 0.0;\n\t\tB_i_r[i] = 0.0;\n\t\tB_c_r[i] = 0.0;\n\t\tB_o_r[i] = 0.0;\n\n\t\tW_out[i] = normal(mean, stdev);\n\t\tW_out_m[i] = 0.0;\n\t\tW_out_r[i] = 0.0;\n\t}\n\tb_out = 0.0;\n\n\tb_out_m = 0.0;\n\tb_out_r = 0.0;\n}\n```\n\n### 训练模型\n\n> + 训练过程分为正向传播和反向传播两个过程。\n> + 由于训练过程中需要保存LSTM单元中各个门的临时信息，这里继续定义全局变量用于分配内存来存储。\n> + 对每一次正向传播计算MSE和MAPE。\n\n#### 临时内存的分配和释放\n\n```cpp\n//临时内存的申请释放\n//输入：时间序列长度；LSTM单元节点数\nvoid setup_memory(int seq_size, int hidenode_num);\nvoid free_memory(int seq_size, int hidenode_num);\n```\n\n```cpp\ndouble* y_delta = NULL; //保存误差关于输出层的梯度\ndouble* predictions = NULL; //保存每次生成的预测值\ndouble **F_vector = NULL;     //保存遗忘门信息\ndouble **I_vector = NULL;     //保存输入门信息\ndouble **C_tmp_vector = NULL; //保存新记忆信息(C`t)\ndouble **O_vector = NULL;     //保存输出门信息\ndouble **C_vector = NULL;     //保存长时记忆信息(Ct)\ndouble **H_vector = NULL;     //保存细胞输出信息\n\n/* 为存储记忆信息的数组建立内存 */\nvoid setup_memory(int seq_size, int hidenode_num)\n{\n\ty_delta = (double *)malloc(seq_size * sizeof(double));\n\tpredictions = (double *)malloc(seq_size * sizeof(double));\n\n\tI_vector = (double **)malloc((seq_size) * sizeof(double *));\n\tF_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tO_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tC_tmp_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tC_vector = (double **)malloc((seq_size + 1) * sizeof(double *));\n\tH_vector = (double **)malloc((seq_size + 1) * sizeof(double *));\n\n\tfor (int j = 0; j < seq_size; j++)\n\t{\n\t\tC_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tH_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tI_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tF_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tO_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tC_tmp_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t}\n\n\tC_vector[seq_size] = (double *)malloc(hidenode_num * sizeof(double));\n\tH_vector[seq_size] = (double *)malloc(hidenode_num * sizeof(double));\n}\n\n/* 为存储记忆信息的数组释放内存 */\nvoid free_memory(int seq_size, int hidenode_num)\n{\n\tint i;\n\tfor (i = 0; i < seq_size; i++)\n\t{\n\t\tfree(F_vector[i]);\n\t\tfree(I_vector[i]);\n\t\tfree(C_tmp_vector[i]);\n\t\tfree(O_vector[i]);\n\t\tfree(C_vector[i]);\n\t\tfree(H_vector[i]);\n\t}\n\tfree(C_vector[i]);\n\tfree(H_vector[i]);\n\n\tfree(F_vector);\n\tfree(I_vector);\n\tfree(C_tmp_vector);\n\tfree(O_vector);\n\tfree(C_vector);\n\tfree(H_vector);\n\n\tfree(y_delta);\n\tfree(predictions);\n}\n```\n\n#### 正向传播过程\n\n```cpp\n//前向传播\nvoid forward(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num);\n```\n\n```cpp\n// 前向传播 \nvoid forward(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num)\n{\n\tint p, k, m, j;\n\n\t//遍历时刻序列\n\tfor (p = 0; p < train_seq_size; p++)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double)); //遗忘门，存储要遗忘的信息f_t，激活函数sigmoid()\n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));    //输入门，存储要更新的信息i_t，激活函数sigmoid()\n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));      // c_t ，存储当前时刻计算得到新记忆c_t，激活函数tanh()\n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double));    //输出门，存储输出的信息o_t，激活函数sigmoid()\n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double));      //记忆值，由遗忘门和输入们组合得到的当前时刻的长时记忆C_t\n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));           //输出值，由(tanh(C_t)*o_t)得到的当前时刻的输出值h_t\n\n\t\tdouble *h_pre = H_vector[p];\n\t\tdouble *memory_pre = C_vector[p];\n\n\t\tfor (k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\t\n\t\t\tdouble inGate = 0.0;\n\t\t\tdouble outGate = 0.0;\n\t\t\tdouble forgetGate = 0.0;\n\t\t\tdouble gGate = 0.0;\n\t\t\t//输入层转播到隐层\n\t\t\tfor (m = 0; m < dim; m++)\n\t\t\t{\n\t\t\t\tforgetGate += X_train_seq[p][m] * W_fx[m][k];//输入x 与 遗忘门 的权重运算\n\t\t\t\tinGate += X_train_seq[p][m] * W_ix[m][k];    //输入x 与 输入门 的权重运算\n\t\t\t\tgGate += X_train_seq[p][m] * W_cx[m][k];     //输入x 与 当前时刻的Cell状态 的权重运算\n\t\t\t\toutGate += X_train_seq[p][m] * W_ox[m][k];   //输入x 与 输出门 的权重运算\n\t\t\t}\n\t\t\tfor (m = 0; m < hidenode_num; m++)\n\t\t\t{\n\t\t\t\tforgetGate += h_pre[m] * W_fh[m][k];//上一时刻的输出值h_pre 与 遗忘门 的权重运算\n\t\t\t\tinGate += h_pre[m] * W_ih[m][k];    //上一时刻的输出值h_pre 与 输入门 的权重运算\n\t\t\t\tgGate += h_pre[m] * W_ch[m][k];     //上一时刻的输出值h_pre 与 当前时刻的Cell状态 的权重运算\n\t\t\t\toutGate += h_pre[m] * W_oh[m][k];   //上一时刻的输出值h_pre 与 输出门 的权重运算\n\t\t\t}\n\t\t\t//添加偏置b\n\t\t\tinGate += B_i[k];\n\t\t\toutGate += B_o[k];\n\t\t\tforgetGate += B_f[k];\n\t\t\tgGate += B_c[k];\n\n\t\t\tforget_gate[k] = sigmoid(forgetGate); //得到决定要舍弃的信息f_t\n\t\t\tin_gate[k] = sigmoid(inGate);   //得到要更新的信息i_t\n\t\t\tg_gate[k] = tanh(gGate);     //得到当前时刻的Cell状态ｃ_t\n\t\t\tout_gate[k] = sigmoid(outGate); //得到决定要输出的信息o_t\n\n\t\t\tdouble m_pre = memory_pre[k];  //前一时刻的cell状态C_pre\n\n\t\t\t//整合遗忘门和输入门,得到当前时刻的cell状态C_t(长时信息)\n\t\t\tmemory[k] = forget_gate[k] * m_pre + g_gate[k] * in_gate[k];//f_t * C_pre + i_t * c_t\n\n\t\t\t//最后整合输出门，得到当前时刻的输出值h_t(短时信息)\n\t\t\th[k] = out_gate[k] * tanh(memory[k]); //o_t * tanh(C_t)\n\n\t        //将这些所有信息全部保存\n\t\t\tI_vector[p][k] = in_gate[k];\n\t\t\tF_vector[p][k] = forget_gate[k];\n\t\t\tO_vector[p][k] = out_gate[k];\n\t\t\tC_vector[p + 1][k] = memory[k];\n\t\t\tC_tmp_vector[p][k] = g_gate[k];\n\t\t\tH_vector[p + 1][k] = h[k];\n\t\t}\n\n\t\t//隐藏层传播到输出层\n\t\tdouble out = 0.0;\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tout += h[j] * W_out[j];\n\t\t}\n\t\tout += b_out;\n\n\t\t//输出层各单元输出\n\t\tpredictions[p] = sigmoid(out); //激活函数sigmoid()\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n}\n```\n\n#### 反向传播过程\n\n```cpp\n//反向传播\nvoid backward(double **X_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon);\n```\n\n```cpp\n//反向传播\nvoid backward(double **X_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon)\n{\n\t//隐层误差，通过当前之后一个时间点的隐含层误差和当前输出层的误差计算\n\tdouble* h_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* O_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* I_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* F_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* G_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* memory_delta = (double *)malloc(hidenode_num * sizeof(double));\n\t//当前时间之后的一个隐层误差\n\tdouble* O_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* I_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* F_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* G_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* memory_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* forget_gate_future = (double *)malloc(hidenode_num * sizeof(double));\n\n\tdouble g = 0.0; //临时变量，存储梯度\n\tfor (int j = 0; j < hidenode_num; j++)\n\t{\n\t\tO_future_delta[j] = 0.0;\n\t\tI_future_delta[j] = 0.0;\n\t\tF_future_delta[j] = 0.0;\n\t\tG_future_delta[j] = 0.0;\n\t\tmemory_future_delta[j] = 0.0;\n\t\tforget_gate_future[j] = 0.0;\n\t}\n\n\t//从最后一个时刻序列从后往前传播\n\tfor (int p = train_seq_size - 1; p >= 0; p--)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double));\n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));   \n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));   \n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));   \n\n\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\tin_gate[k] = I_vector[p][k];\n\t\t\tout_gate[k] = O_vector[p][k];\n\t\t\tforget_gate[k] = F_vector[p][k];\n\t\t\tg_gate[k] = C_tmp_vector[p][k];\n\t\t\tmemory[k] = C_vector[p + 1][k];\n\t\t\th[k] = H_vector[p + 1][k];\n\t\t}\n\t\t\n\t\t//前一个时刻的长短记忆\n\t\tdouble *h_pre = H_vector[p];\n\t\tdouble *memory_pre = C_vector[p];\n\n\t\t//更新隐层和输出层之间的连接权\n\t\tfor (int j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tg = y_delta[p] * h[j];\n\t\t\tadam(&W_out[j], &W_out_m[j], &W_out_r[j], g,l_rate, beta1, beta2, epsilon);\n\t\t}\n\t\t//偏置的误差更新\n\t\tg = y_delta[p];\n\t\tadam(&b_out, &b_out_m, &b_out_r, g, l_rate, beta1, beta2, epsilon);\n\n\t\t//对于网络中每个隐藏单元，计算误差项，并更新权值\n\t\tfor (int j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\th_delta[j] = y_delta[p] * W_out[j];\n\t\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t\t{\n\t\t\t\th_delta[j] += I_future_delta[k] * W_ih[j][k];\n\t\t\t\th_delta[j] += F_future_delta[k] * W_fh[j][k];\n\t\t\t\th_delta[j] += O_future_delta[k] * W_oh[j][k];\n\t\t\t\th_delta[j] += G_future_delta[k] * W_ch[j][k];\n\t\t\t}\n\n\t\t\tO_delta[j] = 0.0;\n\t\t\tI_delta[j] = 0.0;\n\t\t\tF_delta[j] = 0.0;\n\t\t\tG_delta[j] = 0.0;\n\t\t\tmemory_delta[j] = 0.0;\n\n\t\t\t//隐含层的校正误差\n\t\t\tO_delta[j] = h_delta[j] * tanh(memory[j]) * dsigmoid(out_gate[j]);\n\t\t\tmemory_delta[j] = h_delta[j] * out_gate[j] * dtanh(tanh(memory[j])) +\n\t\t\t\tmemory_future_delta[j] * forget_gate_future[j];\n\t\t\tF_delta[j] = memory_delta[j] * memory_pre[j] * dsigmoid(forget_gate[j]);\n\t\t\tI_delta[j] = memory_delta[j] * g_gate[j] * dsigmoid(in_gate[j]);\n\t\t\tG_delta[j] = memory_delta[j] * in_gate[j] * dtanh(g_gate[j]);\n\n\t\t\tO_future_delta[j] = O_delta[j];\n\t\t\tF_future_delta[j] = F_delta[j];\n\t\t\tI_future_delta[j] = I_delta[j];\n\t\t\tG_future_delta[j] = G_delta[j];\n\t\t\tmemory_future_delta[j] = memory_delta[j];\n\t\t\tforget_gate_future[j] = forget_gate[j];\n\n\t\t\t//更新前一个时刻和当前时刻隐层之间的权值\n\t\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t\t{\n\t\t\t\tg = I_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_ih[k][j], &W_ih_m[k][j], &W_ih_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = F_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_fh[k][j], &W_fh_m[k][j], &W_fh_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = O_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_oh[k][j], &W_oh_m[k][j], &W_oh_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = G_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_ch[k][j], &W_ch_m[k][j], &W_ch_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\t\t\t}\n\n\t\t\t//更新输入层和隐层之间的权值\n\t\t\tfor (int k = 0; k < dim; k++)\n\t\t\t{\n\t\t\t\tg = I_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_ix[k][j], &W_ix_m[k][j], &W_ix_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = F_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_fx[k][j], &W_fx_m[k][j], &W_fx_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = O_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_ox[k][j], &W_ox_m[k][j], &W_ox_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = G_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_cx[k][j], &W_cx_m[k][j], &W_cx_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\t\t\t}\n\n\t\t\t//偏置误差更新\n\t\t\tg = I_delta[j];\n\t\t\tadam(&B_i[j], &B_i_m[j], &B_i_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = F_delta[j];\n\t\t\tadam(&B_f[j], &B_f_m[j], &B_f_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = O_delta[j];\n\t\t\tadam(&B_o[j], &B_o_m[j], &B_o_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = G_delta[j];\n\t\t\tadam(&B_c[j], &B_c_m[j], &B_c_r[j], g, l_rate, beta1, beta2, epsilon);\n\t\t}\n\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n\n\tfree(h_delta);\n\tfree(O_delta);\n\tfree(I_delta);\n\tfree(F_delta);\n\tfree(G_delta);\n\tfree(memory_delta);\n\tfree(O_future_delta);\n\tfree(I_future_delta);\n\tfree(F_future_delta);\n\tfree(G_future_delta);\n\tfree(memory_future_delta);\n\tfree(forget_gate_future);\n}\n```\n\n#### 模型训练\n\n```cpp\n//训练模型: 包括前向传播和反向传播两部分\n//输入：特征输入；标签值；时间序列大小；特征输入维度；隐层节点数；学习率；beta1；beta2；epsilon；训练轮数\nvoid train_model(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon, int n_epoch);\n\n```\n\n```cpp\n/训练模型: 包括前向传播和反向传播两部分\n//输入：特征输入；标签值；时间序列大小；特征输入维度；隐层节点数；学习率；beta1；beta2；epsilon；训练轮数\nvoid train_model(double **X_train_seq, double* Y_train_seq, int train_seq_size,int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon, int n_epoch)\n{\n\tint epoch, i, j;\n\n\tfor (epoch = 0; epoch < n_epoch; epoch++)\n\t{//对每一轮\n\n\t\t//申请内存存储细胞信息\n\t\tsetup_memory(train_seq_size, hidenode_num);\n\t\t//对于第一个时间序列，前序记忆信息为0\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tC_vector[0][j] = 0;\n\t\t\tH_vector[0][j] = 0;\n\t\t}\n\n\t\t//前向传播\n\t\tforward(X_train_seq, Y_train_seq, train_seq_size, dim, hidenode_num);\n\n\t\t//计算该次训练的MAPE和MSE\n\t\tfor (i = 0; i < train_seq_size; i++)\n\t\t{\n\t\t\t//保存标准误差关于输出层的偏导\n\t\t\ty_delta[i] = 2.0 * (predictions[i] - Y_train_seq[i]) * dsigmoid(predictions[i]) / train_seq_size;\n\t\t}\n\t\tdouble MSE = mse(Y_train_seq, predictions, train_seq_size);//对于MSE计算不还原数据\n\t\tdouble* y = (double *)malloc(train_seq_size * sizeof(double)); //这里将实际输出拷贝一下，避免对原数据进行还原\n\t\tfor (i = 0; i < train_seq_size; i++)\n\t\t{\n\t\t\tpredictions[i] = restore_data(predictions[i], dim);\n\t\t\ty[i] = restore_data(Y_train_seq[i], dim);\n\t\t}\n\t\tdouble MAPE = mape(y, predictions, train_seq_size);//对于MAPE计算需要还原数据\n\t\tif ((epoch + 1) % 100 == 0)\n\t\t{\n\t\t\tprintf(\"\\nepoch %d MAPE为 %f%%, MSE为 %f\\n\", epoch + 1, MAPE * 100, MSE);\n\t\t}\n\n\t\t//反向传播\n\t\tbackward(X_train_seq, train_seq_size, dim, hidenode_num, l_rate, beta1, beta2, epsilon);\n\n\t\tfree_memory(dim, hidenode_num);\n\t}\n\n}\n```\n\n### 预测模型\n\n```cpp\n// 预测模型：与前向传播一样，只不过这里只需要保存细胞的长时记忆、短时记忆信息\nvoid test_model(double **X_test_seq, double* Y_test_seq, int test_seq_size, int dim, int hidenode_num);\n\n```\n\n```cpp\n// 预测模型：与前向传播一样，只不过这里只需要保存细胞的长时记忆、短时记忆信息\nvoid test_model(double **X_test_seq, double* Y_test_seq, int test_seq_size, int dim, int hidenode_num)\n{\n\t// 预测\n\tint p, k, m, j, i;\n\t//定义存储记忆信息和输出值的数组\n\tdouble **M_vector = (double **)malloc((test_seq_size + 1) * sizeof(double *));\n\tdouble **h_vector = (double **)malloc((test_seq_size + 1) * sizeof(double *));\n\tfor (j = 0; j < test_seq_size + 1; j++)\n\t{\n\t\tM_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\th_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t}\n\tdouble* predict = (double *)malloc(test_seq_size * sizeof(double));\n\tfor (j = 0; j < hidenode_num; j++)\n\t{\n\t\tM_vector[0][j] = 0;\n\t\th_vector[0][j] = 0;\n\t}\n\t\n\tfor (p = 0; p < test_seq_size; p++)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double));      \n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));           \n\n\t\tdouble *h_pre = h_vector[p];\n\t\tdouble *memory_pre = M_vector[p];\n\n\t\tfor (k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\tdouble inGate = 0.0;\n\t\t\tdouble outGate = 0.0;\n\t\t\tdouble forgetGate = 0.0;\n\t\t\tdouble gGate = 0.0;\n\n\t\t\tfor (m = 0; m < dim; m++)\n\t\t\t{\n\t\t\t\tforgetGate += X_test_seq[p][m] * W_fx[m][k];\n\t\t\t\tinGate += X_test_seq[p][m] * W_ix[m][k];  \n\t\t\t\tgGate += X_test_seq[p][m] * W_cx[m][k];    \n\t\t\t\toutGate += X_test_seq[p][m] * W_ox[m][k];  \n\t\t\t}\n\n\t\t\tfor (m = 0; m < hidenode_num; m++)\n\t\t\t{\n\t\t\t\tforgetGate += h_pre[m] * W_fh[m][k];\n\t\t\t\tinGate += h_pre[m] * W_ih[m][k];   \n\t\t\t\tgGate += h_pre[m] * W_ch[m][k];     \n\t\t\t\toutGate += h_pre[m] * W_oh[m][k];   \n\t\t\t}\n\n\t\t\tinGate += B_i[k];\n\t\t\toutGate += B_o[k];\n\t\t\tforgetGate += B_f[k];\n\t\t\tgGate += B_c[k];\n\n\t\t\tforget_gate[k] = sigmoid(forgetGate);\n\t\t\tin_gate[k] = sigmoid(inGate);\n\t\t\tg_gate[k] = tanh(gGate); \n\t\t\tout_gate[k] = sigmoid(outGate);\n\t\t\tdouble m_pre = memory_pre[k];  \n\t\t\tmemory[k] = forget_gate[k] * m_pre + g_gate[k] * in_gate[k];\n\n\t\t\th[k] = out_gate[k] * tanh(memory[k]); \n\n\t\t\tM_vector[p + 1][k] = memory[k];\n\t\t\th_vector[p + 1][k] = h[k];\n\t\t}\n\n\t\tdouble out = 0.0;\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tout += h[j] * W_out[j];\n\t\t}\n\t\tout += b_out;\n\n\t\tpredict[p] = sigmoid(out);\n\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n\n\t//计算MAPE和MSE\n\tdouble MSE = mse(Y_test_seq, predict, test_seq_size);//对于MSE计算不还原数据\n\tfor (i = 0; i < test_seq_size; i++)\n\t{\n\t\tpredict[i] = restore_data(predict[i], dim);\n\t\tY_test_seq[i] = restore_data(Y_test_seq[i], dim);\n\t}\n\tdouble MAPE = mape(Y_test_seq, predict, test_seq_size);//对于MAPE计算需要还原数据\n\n\tprintf(\"\\nMAPE为 %f%%, MSE为 %f\\n\", MAPE * 100, MSE);\n\n\tfor (j = 0; j < test_seq_size + 1; j++)\n\t{\n\t\tfree(M_vector[j]);\n\t\tfree(h_vector[j]);\n\t}\n\tfree(M_vector);\n\tfree(h_vector);\n\tfree(predict);\n}\n```\n\n### 销毁网络\n\n> 注：在销毁网络之前，应当将训练好的权值参数保存到文件中。\n\n```cpp\n// 销毁网络，释放内存\nvoid destroy_network(int dim, int hidenode_num);\n```\n\n```cpp\nvoid destroy_network(int dim, int hidenode_num)\n{\n\tint i;\n\n\tfor (i = 0; i < dim; i++)\n\t{\n\t\tfree(W_ix[i]);\n\t\tfree(W_fx[i]);\n\t\tfree(W_ox[i]);\n\t\tfree(W_cx[i]);\n\t\tfree(W_ix_m[i]);\n\t\tfree(W_fx_m[i]);\n\t\tfree(W_ox_m[i]);\n\t\tfree(W_cx_m[i]);\n\t\tfree(W_ix_r[i]);\n\t\tfree(W_fx_r[i]);\n\t\tfree(W_ox_r[i]);\n\t\tfree(W_cx_r[i]);\n\t}\n\tfree(W_ix);\n\tfree(W_fx);\n\tfree(W_ox);\n\tfree(W_cx);\n\tfree(W_ix_m);\n\tfree(W_fx_m);\n\tfree(W_ox_m);\n\tfree(W_cx_m);\n\tfree(W_ix_r);\n\tfree(W_fx_r);\n\tfree(W_ox_r);\n\tfree(W_cx_r);\n\n\tfree(B_i);\n\tfree(B_f);\n\tfree(B_o);\n\tfree(B_c);\n\tfree(B_i_m);\n\tfree(B_f_m);\n\tfree(B_o_m);\n\tfree(B_c_m);\n\tfree(B_i_r);\n\tfree(B_f_r);\n\tfree(B_o_r);\n\tfree(B_c_r);\n\tfree(W_out);\n\tfree(W_out_m);\n\tfree(W_out_r);\n\n\tfor (i = 0; i < hidenode_num; i++)\n\t{\n\t\tfree(W_ih[i]);\n\t\tfree(W_fh[i]);\n\t\tfree(W_oh[i]);\n\t\tfree(W_ch[i]);\n\t\tfree(W_ih_m[i]);\n\t\tfree(W_fh_m[i]);\n\t\tfree(W_oh_m[i]);\n\t\tfree(W_ch_m[i]);\n\t\tfree(W_ih_r[i]);\n\t\tfree(W_fh_r[i]);\n\t\tfree(W_oh_r[i]);\n\t\tfree(W_ch_r[i]);\n\t}\n\tfree(W_ih);\n\tfree(W_fh);\n\tfree(W_oh);\n\tfree(W_ch);\n\tfree(W_ih_m);\n\tfree(W_fh_m);\n\tfree(W_oh_m);\n\tfree(W_ch_m);\n\tfree(W_ih_r);\n\tfree(W_fh_r);\n\tfree(W_oh_r);\n\tfree(W_ch_r);\n}\n```\n\n### 主函数调用\n\n```cpp\nvoid main()\n{\n\n\tchar filename[] = \"GraInput_1.csv\";\n\tint row = 0, col = 0;\n\n\tget_row_and_column(filename, &row, &col);//读取行列\n\n\t//动态申请二维数组,需要过滤掉第一行和第一列\n\trow--;\n\tcol--;\n\tdouble **dataset = (double **)malloc(row * sizeof(int *));\n\tfor (int i = 0; i < row; ++i)\n\t{\n\t\tdataset[i] = (double *)malloc(col * sizeof(double));\n\t}\n\t//读取数据\n\tread_data(dataset, filename);\n\t//print_data(dataset, row, col);\n\t//数据标准化\n\tnormalize_dataset(dataset, row, col);\n\t//print_data(dataset, row, col);\n\n\t//划分训练集和测试集\n\tdouble distribute_ratio = 0.70;//数据集中前70%为训练集,后30%为测试集\n\tint train_seq_size = row * distribute_ratio; //训练集的时间序列长度\n\tint test_seq_size = row - train_seq_size;  //测试集的时间序列长度\n\tint k = 0,i = 0,j = 0;\n\tdouble** X_train_seq = (double**)malloc(train_seq_size * sizeof(double*));\n\tdouble* Y_train_seq = (double*)malloc(train_seq_size * sizeof(double));\n\tdouble** X_test_seq = (double**)malloc(test_seq_size * sizeof(double*));\n\tdouble* Y_test_seq = (double*)malloc(test_seq_size * sizeof(double));\n\tint dim = col - 1; //输入特征维度\n\tfor (k = 0; k < row; k++) {\n\t\tif (k < train_seq_size)\n\t\t{\n\t\t\tX_train_seq[k] = (double*)malloc(dim * sizeof(double));\n\t\t\tfor (j = 0; j < dim; j++)\n\t\t\t{\n\t\t\t\tX_train_seq[k][j] = dataset[k][j]; //这里对值进行拷贝\n\t\t\t}\n\t\t\tY_train_seq[k] = dataset[k][j];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tX_test_seq[i] = (double*)malloc(dim * sizeof(double));\n\t\t\tfor (j = 0; j < dim; j++)\n\t\t\t{\n\t\t\t\tX_test_seq[i][j] = dataset[k][j];\n\t\t\t}\n\t\t\tY_test_seq[i] = dataset[k][j];\n\t\t\ti++;\n\t\t}\n\t}\n\n\tdouble l_rate = 0.001; //学习率\n\tdouble beta1 = 0.9;   //adam算法更新所需超参数beta1\n\tdouble beta2 = 0.999; //adam算法更新所需超参数beta2\n\tdouble epsilon = 10e-8;////adam算法更新所需超参数epsilon\n\tint hidenode_num = 32; //隐层节点数，隐层默认为1层\n\tint n_epoch = 1000;   //训练轮数\n\n\t//构建网络并初始化：建立权重数组，并进行正太分布随机初始化\n\tinit_normal_weight(dim, hidenode_num);\n\n\t//模型训练\n\tprintf(\"模型训练：\\n\");\n\ttrain_model(X_train_seq, Y_train_seq, train_seq_size, dim,hidenode_num, l_rate,beta1,beta2,epsilon, n_epoch);\n\n\t//模型预测\n\tprintf(\"\\n模型预测：\\n\");\n\ttest_model(X_test_seq, Y_test_seq, test_seq_size, dim, hidenode_num);\n\n\t//保存权值\n\tchar output[] = \"weight_output.txt\";\n\t//saveWeight(output, dim, 32);\n\n\t//销毁网络\n\tdestroy_network(dim, hidenode_num);\n\n\t//释放内存\n\tfor (int j = 0; j < train_seq_size; j++)\n\t{\n\t\tfree(X_train_seq[j]);\n\t}\n\tfree(X_train_seq);\n\tfree(Y_train_seq);\n\tfor (int j = 0; j < test_seq_size; j++)\n\t{\n\t\tfree(X_test_seq[j]);\n\t}\n\tfree(X_test_seq);\n\tfree(Y_test_seq);\n\tfor (int j = 0; j < row; j++)\n\t{\n\t\tfree(dataset[j]);\n\t}\n\tfree(dataset);\n}\n```\n\n## 参考\n\n1. [C语言实现LSTM算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/262132576)\n2. [LSTM模型结构的可视化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/139617364)\n3. [Step-by-step to LSTM: 解析LSTM神经网络设计原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/30465140)\n4. [Understanding LSTM Networks -- colah's blog](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)\n4. [LSTM还没「死」！ (qq.com)](https://mp.weixin.qq.com/s/DEHSiPP1IHEnfLdDYxmjOA)\n\n<!--Completed on 2022.04.07 15:51, by GoeJoody LV-->\n\n","tags":["C","LSTM","神经网络"],"categories":["机器学习"]},{"title":"RSA算法","url":"/hexo-blog/2022/04/03/RSA算法/","content":"\n# RSA算法\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.04.03 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n<!--start: 2022.03.12-->\n\n## 什么是RSA\n\n非对称加密算法也叫公钥密码算法，通过生成的公私钥来对明文密文进行加密解密。RSA加密算法就是一种非对称加密算法，1977年由麻省理工学院的三位密码学家和计算机科学家共同发明，这种算法非常可靠，密钥越长，它就越难破解。 RSA的名字是由它的三个开发者Ron Rivest, Adi Shamir和 Leonard Adleman的首字母而来的[<sup>1</sup>](#refer-anchor-1)。\n\nRSA公钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。\n\n## RSA的加密\n\nRSA的加密可以用下面的公式来表示：\n\n> $密文=明文^E mod N$\n\n通过公式我们可以知道RSA的密文是通过明文的E次方再对$N$进行$mod$运算得到的。\n\n如果知道了$E$和$N$，那么就可以得到密文，所以我们把$E$和$N$的组合称为公钥，表示为 公钥{$E$,$N$}。\n\n## RSA的解密\n\nRSA的解密可以用下面的公式来表示：\n\n> $明文 = 密文^D mod N$\n\n通过公式可以看到，明文是通过密文的$D$次方，再和$N$取模得到的。这里的$N$和加密的$N$是同一个数字。\n\n$D$和$N$的组合表示为私钥{$D$,$N$}。\n\n## RSA的工作流程\n\n1. 选择两个比较大的质数$p$和$q$，计算$N = p * q$。[<sup>2</sup>](#refer-anchor-2)\n2. 计算$N$的欧拉函数$\\lambda(N)$，$\\lambda(N)=(p-1)*(q-1)$\n3.  选择一个小于$\\lambda(N)$且与之互质的数$E$（一般$E$可以取65537），并求得$E$关于$\\lambda(N)$的[模逆元](https://zh.wikipedia.org/zh-cn/模反元素)$D = E^{-1}(mod \\lambda(N))$。\n   + 模逆元的定义是，找到$D$使得$（E*D） mod \\lambda(N) = 1$。\n   + 模逆元可以用[扩展的欧几里得算法](https://zh.wikipedia.org/zh-cn/扩展欧几里得算法)得出。\n4. $(N,E)$是公钥，$(N,D)$是私钥\n   + 公钥公开，私钥必须密藏。\n   + 销毁所有 $p$,$q$,$\\lambda(N)$ 的记录。\n5. 发送方先按照双方约定好的编码格式将消息转化为一个小于$N$的正整数$m$，然后使用接收方的公钥计算出密文$c$，计算公式是 $c≡m^E(modN)$。\n6. 接收方收到密文后，使用自己的私钥计算出明文$m$，计算公式是 $m≡c^D(modN)$，然后解码成原始消息。\n7. 使用私钥加密的消息也可以由公钥解密，即如果 $s≡m^D(modN)$，则 $m≡s^E(modN)$。这就是所支持的数字签名功能\n\n## RSA的安全性\n\n1. 历经40多年的广泛研究和现实应用的考验，虽然发现了不少精巧的攻击手段，总体上RSA是安全的。这些攻击手段都是利用RSA的不当使用或软硬件实现中脆弱性，并不能动摇其加密算法的安全性根基。另一方面，对这些攻击手段的研究表明，实现一个安全而牢固的RSA应用并不是一个简单的任务。实际上，密码学和网络安全软硬件工程实践中的一个共识就是：不要试图从头开始实现RSA！恰当的方案，是使用现有的、久经测试并有可靠维护的库或API，去实现RSA算法和协议的应用。\n2. 查询[RSA大数分解挑战](https://en.wikipedia.org/wiki/RSA_Factoring_Challenge)网站公布的最新纪录，2020二月法国计算数学家保罗·齐默尔曼 (Paul Zimmermann) 领导的团队成功分解了250位十进制数字 (**829比特**) 的大数 [RSA-250](https://en.wikipedia.org/wiki/RSA_numbers#RSA-250)[<sup>3</sup>](#refer-anchor-3)。因此目前来说，1024位的RSA密钥基本安全，2048位的RSA密钥极其安全。\n\n## RSA算法实现（C++）\n\n### 安装GMP\n\n> 生成并存储一个1024位128个字节的高精度整数，用C++自带的库很难完成这个工作，就需要第三方库：GMP，这个库支持任意精度的大整数存储与运算。\n\n> 使用MinGW安装GMP，执行命令`mingw-get install mingw32-gmp`。\n\n> 编写程序时，包含`#include<gmpxx.h>`头文件，编译时需要加上`-lgmp -lgmpxx`（由于这个原因，一直没能找到在VScode下运行的正确解决方案），因此在命令行进行编译。\n\n### 代码实现\n\n```cpp\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-02\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-02\n * @Description: RSA算法实现\n */\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"gmpxx.h\"\n\nusing namespace std;\n\nvoid RSA_get_key(string &e, string &d, string &n) {\n  mpz_t p, q;        //两个大质数\n  mpz_t N, L, E, D;  // L为欧拉函数\n\n  //初始化\n  mpz_init(p);\n  mpz_init(q);\n  mpz_init(N);\n  mpz_init(L);\n  mpz_init(E);\n  mpz_init(D);\n\n  /*\n   * 生成随机1024位质数\n   */\n  gmp_randstate_t grat;  //随机数种子\n  gmp_randinit_default(grat);  //默认生成方式,在随机性与效率之间取一个折中\n  //生成两个1024位的随机整数\n  mpz_urandomb(p, grat, 1024);\n  mpz_urandomb(q, grat, 1024);  //随机生成一个0-2^1024的一个数\n  //生成素数\n  mpz_nextprime(p, p);  // GMP自带的素数生成函数\n  mpz_nextprime(q, q);\n\n  /*\n   * 求得N, L\n   */\n  mpz_mul(N, p, q);     // N = p*q;\n  mpz_sub_ui(p, p, 1);  // p = (p-1)\n  mpz_sub_ui(q, q, 1);  // p = (q-1)\n  mpz_mul(L, p, q);     // L = (p-1)*(q-1)\n\n  /*\n   * 求得E到公钥e此值可取65537、17、37、47;但除65537以外其他小值*\n   * 做公钥得到的密文是固定不变的，安全性不可靠!\n   */\n  mpz_set_ui(E, 65537);  // E = 65537\n  /*\n   * 逆元运算\n   */\n  mpz_invert(D, E, L);  //(D*E)%L = 1\n\n  /*\n   * 将D,E,N转为字符串\n   */\n  mpz_class temp_D(D);  //构造函数mpz_class x(z); #z为mpz_t类型\n  mpz_class temp_E(E);\n  mpz_class temp_N(N);\n  d = temp_D.get_str();\n  e = temp_E.get_str();\n  n = temp_N.get_str();\n\n  /*\n   * 释放变量\n   */\n  mpz_clear(q);\n  mpz_clear(p);\n  mpz_clear(N);\n  mpz_clear(D);\n  mpz_clear(E);\n  mpz_clear(L);\n}\n\nstring RSA_encode(string in_data, string e, string n) {\n  mpz_t m, pub_e, temp_n;\n  mpz_init(m);\n  mpz_init(pub_e);\n  mpz_init(temp_n);\n  //将公钥{N,E}统一转化为十进制高精度整数\n  mpz_set_str(pub_e, e.c_str(), 10);\n  mpz_set_str(temp_n, n.c_str(), 10);\n\n  int length = in_data.size();\n  /*\n   * 对字符串循环加密\n   */\n  string out_data;\n  for (int i = 0; i < length; i++) {\n    mpz_set_ui(m, (unsigned long)in_data[i]);\n    mpz_powm(m, m, pub_e, temp_n);  // c = (m^e) mod n\n\n    mpz_class c_data(m);\n    out_data.append(c_data.get_str());  //取得字符串\n    out_data.append(\"\\n\");  //用回车隔开防止字符串密文混乱无法辨识\n  }\n\n  mpz_clear(m);\n  mpz_clear(pub_e);\n  mpz_clear(temp_n);\n\n  return out_data;\n}\n\nstring RSA_decode(string in_data, string d, string n) {\n  vector<string> C_List;\n  string temp_str;\n  int length = in_data.size();\n  //循环拆分字符串，根据原有字符个数拆分为字符串容器列表\n  for (int i = 0; i < length; i++) {\n    if (in_data.at(i) == '\\n') {\n      C_List.push_back(temp_str);\n      temp_str.clear();\n      continue;\n    }\n    temp_str += in_data.at(i);\n  }\n\n  mpz_t pri_key, temp_n, temp_Data;\n  mpz_init(pri_key);\n  mpz_init(temp_n);\n  mpz_init(temp_Data);\n  //将字符串转为mpz_t高精度整数\n  mpz_set_str(pri_key, d.c_str(), 10);\n  mpz_set_str(temp_n, n.c_str(), 10);\n\n  //循环根据容器个数来判断原本有几个字符，并将其密文解析为明文\n  string back_data;\n  for (int i = 0; i < C_List.size(); i++) {\n    //从字符串取值转化为十进制大整数\n    mpz_set_str(temp_Data, C_List.at(i).c_str(), 10);\n    //模幂运算M=(C^d) mod n\n    mpz_powm(temp_Data, temp_Data, pri_key, temp_n);\n\n    //先将取到的明文ASCII转化为C语言基本类型\n    //再直接将ASCII码转为字符，再将字符追加进字符串\n    //这样就完美还原了明文\n    mpz_class CD(temp_Data);\n    unsigned long lchar = CD.get_ui();\n    char words = (char)lchar;\n    back_data += words;\n  }\n\n  mpz_clear(pri_key);\n  mpz_clear(temp_n);\n  mpz_clear(temp_Data);\n  //返回明文\n  return back_data;\n}\n\nint main() {\n  string e, d, n;\n  string plaintext = \"我是一串明文\";\n  RSA_get_key(e, d, n);\n  string ciphertext = RSA_encode(plaintext, e, n);\n  string plaintext_1 = RSA_decode(ciphertext, d, n);\n\n  ofstream os;\n  string filename = \"output.txt\";\n  os.open(filename);\n\n  os << \"E:\\n\" << e << endl;\n  os << \"D:\\n\" << d << endl;\n  os << \"N:\\n\" << n << endl;\n  os << \"原始明文: \\n\" << plaintext << endl;\n  os << \"加密密文: \\n\" << ciphertext << endl;\n  os << \"解密明文: \\n\" << plaintext_1 << endl;\n  os.close();\n\n  return 0;\n}\n```\n\n### 编译运行\n\n在项目目录下，命令行执行：\n\n```shell\ng++ RSA_algorithm.cpp -lgmp -lgmpxx -o test\n\ntest.exe\n```\n\n### 运行结果\n\n![image-20220403000519735](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204030005162.png)\n\n## 参考\n\n<div id=\"refer-anchor-1\"></div>\n+ [1] Rivest R.L. ,  Shamir A. ,   Adelman L. . A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Comm.ACM, 1977.\n<div id=\"refer-anchor-2\"></div>\n+ [2] 子曦. RSA的攻与防（一）[EB]/[OL].https://www.packetmania.net/2020/12/01/RSA-attack-defense/. 2021-11-27.\n<div id=\"refer-anchor-3\"></div>\n+ [3] 维基百科“RSA Factoring Challenge”[EB]/[OL].https://en.wikipedia.org/wiki/RSA_Factoring_Challenge. 2022-04-02.\n+ [4] [GMP大法教你重新做人(从入门到实战) - Angel_Kitty](https://www.cnblogs.com/ECJTUACM-873284962/p/8350320.html)\n+ [5] [ RSA加密算法解释与C++实现_Anansi_safe](https://blog.csdn.net/weixin_43815930/article/details/105887662)\n\n\n\n","tags":["C-plus-plus","RSA","GMP"],"categories":["课程作业"]},{"title":"正则表达式","url":"/hexo-blog/2022/03/26/正则表达式/","content":"# 正则表达式\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.03.27 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 结构组成\n\n+ 普通字符：大小写字母，数字。只作为字符，不具备其他含义。\n+ 元字符：除了本身作为字符，还可以表达其他含义。对于元字符来说，要表示其原本的普通字符含义，可使用转义字符`\\`。\n\n## 用途场景\n\n1. 字符串规则验证。\n2. 字符串替换。\n3. 字符（串）提取。\n\n## 正则元字符\n\n### 正则：普通字符\n\n> 正则表达式为一串普通字符（不包含元字符）时，校验字符串只有和正则串一致时，才会校验通过。\n\n```markdown\n//regex: a1b2c3\na1b2c: false\na1b2c3: true\na1b2c3d: false\n```\n\n### 正则：\\d\n\n> **\\d**表示一个数字。\n\n```markdown\n//regex: aaa\\d  //表示三个“a”再加一个数字组成的字符串。\naaaa1: false\naaa1: true\naaa5: true\naaa8: true\naaa: false\n```\n\n### 正则：\\D\n\n> **\\D** 表示一个非数字，它和 \\d 的意思恰好相反。\n\n```markdown\n//regex: \\D\\D\\D   //表示一个长度为3且不包含数字的字符串\naaa: true\naaaa: false\nas1: false\na+c: true\n```\n\n### 正则：\\w\n\n> **\\w**表示一个字母（大小写均可）、数字，或下划线。\n\n```markdown\n// regex: \\d\\w\\D\n111: false\n12d: true\n1dd: true\nddd: false\n1_d: true\n```\n\n### 正则：\\W\n\n> **\\W**与\\w相反，表示这个位置的字符既不是字母、数字，也不是下划线。也就是：特殊符号（除下划线），或者空格等满足。\n\n```markdown\n// regex: \\d\\W\\D\n11d: false\n1wd: false\n1_d: false\n1+d: true\n```\n\n### 正则：\\s\n\n> **\\s**表示匹配一个看不见的符号（空白符），即空格、制表符（Tab键）、换行符。\n\n```markdown\n// regex: \\d\\s\\w\n1f5: false\n1+f: false\n1 d: true\n1\tf: true\n```\n\n### 正则：\\S\n\n>  **\\S** 与 \\s 相反，表示一个可以看得见的符号（非空白符）。\n>\n>  + `\\s\\S`：匹配所有。\n\n```markdown\nregex: \\d\\S\\w\n1f5: true\n1+f: true\n1 d: false\n1\tf: false\n```\n\n### 正则：.\n\n> **.** (小数点) 则表示“\\n”和\"\\r\"之外的任何单个字符，等价于`[^\\n\\r]` 。如果要表示点号，最好用`[.]`或者`\\.`\n\n```markdown\n// regex: ....    //表示任意四个字符\nafdv: true\nsf15: true\nd^%#: true\n5c:<: true\n```\n\n### 正则：|\n\n> **|**（竖线）表示“或”的关系，表示检测的字符串需满足其中一个时，才满足条件。\n\n```markdown\n// regex: aa|bb|cc\naa: true\nbb: true\ncc: true\ndd: false\n```\n\n### 正则：[abc]\n\n> **[]**表示匹配其中任意一个字符。\n\n```markdown\n// regex: \\D[bcd]\\W\nfb+: true\nfc+: true\nfd+: true\nfd+: false\n```\n\n### 正则：**[^abc]**\n\n> **[^]**表示不与括号里的任意字符匹配。\n\n```markdown\n// regex: \\D[^bcd]\\W\nfb+: false\nfc+: false\nfd+: false\nfd+: true\n```\n\n### 正则：[a-z]\n\n> **[值1-值2]**表示值1到值2中间的所有字符都满足（包括值1和值2）。常见范围为大小写字母范围和数字范围：[a-z]，[A-Z]，[0-9]。\n\n```markdown\n// regex: a[b-e]g   //即a[bcde]g、a(b|c|d|e)g\nabg: true\naeg: true\nadg: true\navg: false\n// regex: a[0-9]e  //等价于a\\de\n```\n\n### 正则：**[^a-z]**\n\n> **[^值1-值2]**表示除值1和值2之外的所有字符，都可以满足。\n\n```markdown\n// regex: a[^a-z]e\naae: false\nage: false\naze: false\na1e: true\n```\n\n### 正则：\\num\n\n> 这里的num指number，也就是数字，当\\后面跟数字，表示匹配第几个括号中的结果。\n>\n> 例如：\n>\n> + `ab(c)d(e)\\1`：`\\1`表示匹配第一个括号里的结果，即`\\1`指`c`。等价于`abcdec`。\n> + `ab(c)d(e)\\2`：等价于`abcdee`。\n> + `12(\\w)d\\1`：等价于`12\\wd\\w`。\n\n### 正则：(?:pattern)\n\n> 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n\n### 正则：限定符\n\n#### 正则：?\n\n> **`?`** 表示匹配前面的子表达式**零次或一次**。\n>\n> 例如：`abc?de`: 表示可匹配的字符串为 `abde` (匹配0次`c`) 或 `abcde` (匹配1次`c`)。\n\n> 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。\n\n```markdown\n// regex: abc?de\nabde: true\nabcde: true\nabccde: false\n```\n\n#### 正则：+\n\n> **`+`**表示匹配前面的表达式**一次或多次**。（至少一次）\n\n```markdown\n// regex: abc+de\nabde: false\nabcde: true\nabccde: true\nabcccde: true\n```\n\n#### 正则：*\n\n> **`*`**表示匹配前面的子表达式任意次(可以为0次)。\n\n```markdown\n// regex: abc*de   //表示ab和de之间有任意个c\nabde: true\nabccde: true\nabcccde: true\nabccccde: true\n```\n\n#### 正则：{n}\n\n> 这里的 `n` 是一个非负整数。匹配确定的前面的子表达式 `n` 次。\n\n```markdown\n// regex: abc{3}de   //表示 ab 和 de 之间有3个 c ，等价于 abcccde。\n\n// regex: aa(xx|yy){3}de  //表示 ab 和 de 之间有 xx 或 yy 的个数， 一起合计为3个。\naaxxxxxxde: true\naaxxyyxxde: true\naaxyxyxyde: false\naaxxyyyyyyde: false\n```\n\n#### 正则：{n,}\n\n> `{n,}`表示匹配 n 次及以上。\n>\n> + `{1,}`：等价于`+`。\n> + `{0,}`：等价于`*`。\n\n#### 正则：{n,m}\n\n> $m$ 和 $n$ 均为非负整数，其中 $n<=m$。最少匹配 $n$ 次且最多匹配 $m$ 次。\n>\n> + `{0,1}`：等价于`?`。\n\n```markdown\n// regex: abc{2,4}de   //表示ab和de之间有2-4个c\nabcde: false\nabccde: true\nabcccde: true\nabccccde: true\n```\n\n### 正则：定位符\n\n| 字符 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| `^`  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |\n| `$`  | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |\n| `\\b` | 匹配一个单词边界，即单词与空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| `\\B` | 非单词边界匹配。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n\n<font color=#ff0000>注：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\\*** 之类的表达式。</font>\n\n### 先行断言(lookahead)和后行断言(lookbehind)\n\n> + 如同 **^** 代表开头，**$** 代表结尾，**\\b** 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为**\"零宽\"**。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。\n> + 对于后行断言，在不同语言中的支持有所限制。\n> + **所谓的先行/后行，正向/负向，断言。事实上这些翻译都不准确。不过能理解具体意思就好**。\n> + **可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存**。这里的<font color=#ff0000>**重写捕获**</font>，需要作详细理解。\n>\n> ![image-20220327223107787](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272231884.png)\n\n>参考：[正则表达式的先行断言(lookahead)和后行断言(lookbehind) | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html)\n\n\n\n#### `(?=pattern)`零宽正向先行断言(zero-width positive lookahead assertion)\n\n> `exp1(?=exp2)`：查找exp2前面的exp1。\n\n![image-20220327214439476](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272144588.png)\n\n#### `(?<=pattern)`零宽正向后行断言(zero-width positive lookbehind assertion)\n\n> `(?<=exp2)exp1`：查找exp2后面的exp1。\n\n![image-20220327214656998](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272146086.png)\n\n#### `(?!pattern)`零宽负向先行断言(zero-width negative lookahead assertion)\n\n> `exp1(?!exp2)`：查找后面不是exp2的exp1。\n\n![image-20220327214847158](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272148270.png)\n\n#### `(?<!pattern)`零宽负向后行断言(zero-width negative lookbehindassertion)\n\n> `(?<!exp2)exp1`：查找前面不是exp2的exp1。\n\n![image-20220327215006162](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272150258.png)\n\n## Tips\n\n### 3个重要的正则式命令\n\nBracket（括号）, Caret（插入符号）和Dollars（美元符号）。\n\n+ **B**在正则表达式中有3种类型的括号。\n  + 方括号`[]`内是需要匹配的字符。\n  + 花括号`{}`内是指定匹配字符的数量。\n  + 圆括号`()` 则是用来分组的。\n\n+ **C** 插入符号 `^` 表示正则式的开始。用在`[]`中，`[^]`表示非。\n\n+ **D** 美元符号`$` 表示正则式的结束。\n\n### 快捷命令\n\n| 实际命令       | 快捷命令 |\n| :------------- | -------- |\n| `[0-9]`        | `\\d`     |\n| `[^0-9]`       | `\\D`     |\n| `[a-zA-Z0-9_]` | `\\w`     |\n\n### 其他\n\n1. ***** 和 **+** 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个**?** 就可以实现非贪婪或最小匹配。\n\n```markdown\n// 字符串： <h1>JoeGoodyLv</h1>\n// regex: <.*>    直接匹配到 <h1>JoeGoodyLv</h1>\n// regex: <.*?>   匹配到 <h1>、</h1>\n```\n\n## 常用正则表达式\n\n+ 国内手机号码\n\n  ```md\n  ^(13[0-9]|14[0-9]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$\n  ```\n\n## Reference\n\n1. [正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)\n\n","tags":["正则表达式"],"categories":["学习笔记"]}]