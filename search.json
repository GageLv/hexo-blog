[{"title":"文献阅读--Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks","url":"/hexo-blogs/2022/08/24/文献阅读--Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks/","content":"\n# 文献阅读：Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks(DCGAN)\n\n> {% timeline 更新时间线, blue %}\n> <!-- timeline 2022.08.30 -->\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n​\t\t近年来，使用卷积网络（CNNs）的监督学习在计算机视觉应用中被广泛采用。相比之下，CNNs的无监督学习却很少有人关注。在这项工作中，我们希望帮助弥合CNNs在监督学和和无监督学习上的成功之间的差距。我们介绍了这样一类CNNs：深度卷积生成对抗网络（DCGANs），它具有一定的架构约束，并且证明了它是无监督学习的有力候选者。在各种图像数据集上进行训练，我们展示了令人信服的证据，表明我们的深度卷积对抗对在生成器和判别器上学习了从对象部分到场景的表示层次。此外，我们将学习到的新特征用于新任务——证明了它作为一般图像表示的通用性。\n\n### 1 引言\n\n​\t\t从大型未标记数据集中学习可重用的特征表示一直是一个活跃的研究领域。在计算机视觉的背景下，人们可以充分利用几乎不限数量的未标记图像和视频来学习良好的中间表示，然后可以用于诸如图像分类的各种监督学习任务。我们提出一种通过训练生成对抗网络（GANs）来构建良好图像表示的方法，接着继续重用生成器和判别器网络的部分作为监督任务中的特征抽取器。GANs为最大似然技术提供了一种有吸引力的替代方案。人们还可以争辩说他们的学习过程和无需启发式成本函数（例如逐像素独立均方误差）对表示学习很有吸引力。众所周知，GANs训练不稳定，经常导致生成器产生出荒谬的输出。在试图理解和可视化GANs的学习内容和多层GANs的中间学习方面，目前已发表的研究十分有限。\n\n​\t\t本文中，我们作出如下贡献：\n\n+ 我们提出并评估了一组在卷积GANs的架构拓朴上的约束，这些约束使它们能够在大多数环境中稳定训练。我们将这类架构命名为深度卷积GANs（DCGANs）。\n+ 我们将训练好的判别器用于图像分类任务，展现出了与其他无监督算法有竞争力的性能。\n+ 我们将GANs学习到的过滤器可视化，凭经验表明这种特定的过滤器学会了绘制特定的对象。我们展示了生成器具有有趣的向量算术特性，可以轻松操作生成样本的许多语义特征。\n\n### 2 相关工作\n\n#### 2.1未标注数据的表示学习\n\n​\t\t在一般计算机视觉研究和图像相关研究中，无监督表示学习是一个研究得相当好的问题。无监督表示学习的一个经典方法是对数据进行聚类（如使用K-means），并且使用聚类提高分类分数。在图像研究中，可以对图像块进行层次聚类来学习优秀的图像表示。另一个流行的方法是训练自动编码器（卷积，堆叠），将代码组件的内容和位置分离，使用梯形结构来将图像编码为简洁的代码，然后将代码解码来重建尽可能准确的图像。这些方法都表明了可以从图片像素中学习优秀的特征表示。深度置信网络也被证明在学习层次表示上效果很好。\n\n#### 2.2 生成自然图像\n\n​\t\t生成图像模型得到了很好的研究，主要分成两类：参数的和非参数的。\n\n​\t\t非参数模型通常是从已有图像的数据库中进行匹配，通常是匹配图像块，然后用于纹理合成、超分辨率和图像修复。\n\n​\t\t用于生成图像的参数模型得到了广泛的探索（例如在MNIST数字或者纹理合成上）。然而，直到最近，生成真实世界中的自然图像也没有取得大的成功。一种生成图像的变分采样方法取得了一些成功，但是样本通常会变得模糊。另一种生成图像的方法运用迭代前向扩散过程。生成对抗网络生成的图像嘈杂且难以理解。这种方法的一种拉普拉斯金字塔扩展展示了更高质量的图像，但由于链接多个模型引入的噪声，他们仍然受到对象看起来不稳定的影响。近来一种循环网络方法和一种去卷积网络在生成自然图像上取得了一些成功。然而，他们都没有在监督任务中利用生成器。\n\n#### 2.3 可视化CNNs内核\n\n​\t\t对使用神经网络的一个持续批评是，它们是黑盒方法，很少能知道这网络在以一种简单的人类可消耗算法的形式做什么。在CNNs相关研究中，Zeiler等人表明，通过使用反卷积和过滤最大激活值，可以找到网络中每个卷积过滤器的大致用途。同样，在输入上使用梯度下降可以让我们检查激活某些过滤器子集的理想图像。\n\n### 3 方法和模型架构\n\n​\t\t使用CNNs对图像建模来扩展GANs的历史尝试并不成功。这促使了LAPGAN的作者开发了一种迭代升级低分辨率生成图像的替代方案，这种方案可以更加可靠地建模。我们尝试使用监督文献中常用的CNN架构来扩展GANs也遇到了困难。然而，经过了广泛的模型探索，我们确立了一系列架构，这些架构在一系列数据集上进行了稳定的训练，并可以训练更高分辨率和更深层的生成模型。\n\n​\t\t我们方法的核心是采用和修改最近展示的CNN架构的三个变化。\n\n​\t\t首先，全卷积网络使用跨步卷积（strided convolution）代替确定性的空间池化函数（例如maxpooling），它允许网络学习自己的空间下采样。我们在生成器中采用这种方法，让它能够学习自己的空间上采样和判别器。\n\n​\t\t其次，在卷积特征上消除全连接层的趋向。关于此最好的例子就是全局平均池化被用到最先进的图像分类模型中。我们发现全局平均池化增加了模型稳定性但降低了收敛速度。将最高卷积特征直接连接到生成器和判别器各自的输入输出的中间地带的效果很好。GAN的第一层，使用一个均匀噪声分布$Z$作为输入，因为它只是一个矩阵乘法，所以可以看作为全连接的。但是结果会被重塑为一个4维的张量并用作卷积堆栈的开始。对判别器来说，最后一个卷积层被展平，然后馈入单个sigmoid输出。图1展示了一个示例模型架构的可视化。\t\n\n​\t\t第三，批量归一化，它通过将每个单元的输入归一化为零均值和单元方差来稳定学习。这可以帮助处理由于不好的初始化导致的训练问题，并有助于梯度在更深层的模型中流动。事实证明，让深度生成器开始学习非常重要，避免生成器将所有样本崩溃到一个点，是GAN中观察到的常见故障模式。然而，直接将批归一化应用于所有层会导致样本振荡和模型不稳定。这可以通过不要再生成器输出层和判别器输入层中使用批归一化来避免。\n\n​\t\t除了输出层使用Tanh函数外，生成器的其他层使用ReLU函数。我们观察到使用有界激活可以使模型更快地学习到饱和并覆盖训练分布的颜色空间。在判别器中我们发现带泄露修正激活（Leaky ReLU）表现很不错，特别是针对更高分辨率的建模。这是与原始使用maxout激活的GAN论文相比。\n\n​\t\t稳定深度卷积GANs架构指南\n\n+ 使用跨步卷积代替池化层（判别器），使用小跨步卷积代替池化层（生成器）。\n+ 在生成器和判别器中使用批归一化（batchnorm）。\n+ 移除更深层架构中的全连接隐藏层。\n+ 除了输出层使用Tanh，生成器其他层使用ReLU激活。\n+ 判别器所有层都使用LeakyReLU激活。\n\n### 4 对抗训练细节\n\n​\t\t我们在三个数据集上训练了DCGANs：大规模场景理解（LSUN），Imagenet-1k，一个新组装的Faces数据集。这些数据集每个的详细用法在下面给出。\n\n![image-20220827150147217](文献阅读--Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks.assets/image-20220827150147217.png)\n\n<font size=\"2\">图1：用于LSUN场景建模的DCGAN生成器。将100维的均匀分布$Z$投影到具有许多特征图的小空间范围卷积表示。一系列四个小跨步卷积（在近期某些论文中，它们被错误的叫做反卷积）将这种高级表示转换为$64\\times64$的像素图片。值得注意的是，这里没有使用全连接层或者池化层。</font>\n\n​\t\t除了将训练图像缩放到Tanh激活函数的范围[-1,1]之外，不进行其他的预处理。所有模型使用小批量随机梯度下降（SGD）来训练，小批量大小为128。所有权重初始化为服从以零为中心的正太分布，标准差为0.02。在LeakyReLU中，所有模型的泄露斜率设置为0.2。虽然之前的GAN工作采用动量来加速训练，但我们采用可以调节超参数的Adam优化器。我们发现建议的0.001学习率太高，改用了0.0002。此外，我们发现将动量项$\\beta_1$留在0.9的建议值会导致训练振荡和不稳定，因此我们减少到了0.5来维持稳定训练。\n\n#### 4.1 LSUN\n\n​\t\t随着生成图像模型的样本视觉质量的提高，对训练样本过拟合和记忆的担忧也随之上升。为了展示我们的模型如何随着更多的数据和更高的分辨率生成而扩展，我们在包含超过300万个训练示例的LSUN卧室数据集上训练了一个模型。最近的分析表明，模型的训练速度和它们的泛化性能存在直接关系。我们展示了来自一轮训练的样本（图2），模仿在线学习，以及收敛后的样本（图3），以此证明我们的模型没有通过简单的过拟合/记忆训练示例来生成高质量的样本。图像中没有采用数据增强。\n\n<font size=\"2\">图2（图略）：数据集上经过一次训练生成的卧室。理论上，模型可以学习到记忆训练示例，但这在实验上不太可能，因为我们采用小的学习率和小批量SGD来训练。我们知道没有先前的经验证据表明能够使用SGD和小学习率来进行记忆。</font>\n\n<font size=\"2\">图3（图略）：经过4轮训练后生成的卧室。通过在多个样本（例如一些床的底板）中重复噪声纹理，这成为出现了视觉欠拟合的证据。</font>\n\n##### 4.1.1 去重\n\n​\t\t为了进一步降低生成器记忆输入示例的可能性（图2），我们进行了一个简单的图像去重过程。我们在训练示例的$32\\times32$下采样center-crops上拟合了一个3072-128-3072去噪dropout正则化RELU自动编码器。然后通过对ReLU激活阈值化，来对生成的代码层激活进行二值化，这已经被证明是一种有效的信息保存方法，并且提供了一种方便的寓意散列形式，这种形式允许线性时间去重。对哈希冲突的目视检查显示出高精度，估计误报率不到 100 分之一。此外，这项技术检测和移除了大约275,000个相近的重复项，这表明召回率很高。\n\n#### 4.2 FACEs\n\n​\t\t我们从人名的随机网络图像查询中抓取包含人脸的图像。以生于现代为标准，人名从数据库百科中获取。该数据集有来自10K个人的300万张图像。我们在这些图像上运行OpenCV面部检测器，在保持充分高分辨率的检测下，给了我们大概35,000张面部框。我们将这些面部框用于训练。图像不采用数据增强。\n\n#### 4.3 IMAGENET-1K\n\n​\t\t我们使用 Imagenet-1k作为自然图像来源进行无监督训练。在$32\\times32$的最小调整大小的center-crops上训练。图像不采用数据增强。\n\n### 5 实验验证DCGANs性能\n\n#### 5.1 使用GANs作为特征提取器对CIFAR-10进行分类\n\n​\t\t一个常用的评估无监督表示学习算法质量的方法是将这些算法作为监督数据集的特征提取器，然后评估拟合在这些特征之上的线性模型的性能。\n\n​\t\t在CIFAR-10数据集上，使用K-means作为特征学习算法，一个经过良好调整的单层特征提取管道已经表现出了非常好的基线性能。当使用大量特征图（4800）时，该技术可实现80.6%的精度。一个基于上述算法的无监督多层扩展达到了82.0%的精度。为了评估将DCGANs学习到的表示用于监督任务的质量，我们在Iamgenet=1k上进行训练，然后将判别器的卷积特征用于所有层，最大池化每一层表示来生成一个$4\\times4$的空间网格。然后将这些特征展平并连接组成一个28672维的向量，并在上面训练一个正则化线性L2-SVM分类器。这实现了82.8%的精度，优于所有基于K-means的算法。值得注意的是，相比基于K-means的方法，判别器的特征图要少得多（最高层为512个），但是由于$4\\times4$个空间位置的多层结构，确实会导致更大的总特征向量大小。DCGANs的性能仍然低于Exemplar CNNs，Exemplar CNNs是一种以无监督方式训练常规判别性CNNs的技术，以区分在源数据集中专门选择的和积极增强的示例样本。可以通过微调判别器的表示来进一步改进，但我们将其留作未来的工作。此外，由于我们的DCGAN从未在CIFAR-10上进行过训练，因此，该实验还展示了学习特征的域鲁棒性。\n\n\n\n#### 5.2 使用GANs作为特征提取器对SVHN数字进行分类\n\n​\t\t在街景门牌号数据集（SVHN，StreeView House Numbers）上，当缺少标记数据时，我们将DCGAN判别器的特征用于监督目的。使用与CIFAR-10实现中类似的数据集准备规则，我们从非额外集合中划分出一个由10,000个示例组成的验证集，并将其用于所有的超参数以及模型的选择。随机选择1000个均匀类分布训练示例，用来在用于CIFAR-10的相同特征提取管道上训练一个正则化线性L2-SVM分类器。这在22.48%的测试误差下实现了最好的结果（使用1000个标签进行分类），改进了旨在利用未标记数据的另一种改进CNN。我们在相同的数据上训练一个同样架构的纯监督CNN，并通过对64个超参数实验的随机搜索来优化模型，验证了在DCGAN中使用的CNN架构不是模型性能的关键因素。它实现了显著更高的28.87%的验证误差。\n\n### 6 调查和可视化网络的内部结构\n\n我们以各种方式对训练的生成器和判别器进行探索。我们不再训练集上执行任何类型的最近邻搜索。像素或特征空间中最近邻会被小的图像变换所愚弄。我们也没有使用对数似然指标来定量评估模型，因为他是一个很差的指标。\n\n#### 6.1 隐空间漫游（探索隐空间）\n\n​\t\t我们做的第一个实验是了解隐空间的景象。在所学的流形上漫游通常可以告诉我们记忆的迹象（如果有急剧的转变），以及空间分层坍塌的方式。如果在这个隐空间中漫游会导致图像生成的语义变化（例如添加和删除对象），我们可以推断模型已经学习了相关且有趣的表示。结果如图4所示。\n\n<font size=\"2\">图4（图略）：顶行：$Z$中一系列9个随机点之间的插值表明，所学习的空间具有平滑的过渡，空间中的每个图象看起来都像一间卧室。在第6行，你可以看到一个没有窗户的房间慢慢编程一个有巨大窗户的房间。在第10行中，你可以看到看起来像是电视的对象慢慢变成窗户。  </font>\n\n#### 6.2 可视化判别器特征\n\n先前的工作已经表明，在大型图像数据集上对CNN进行监督训练会产生非常强大的学习特征。此外，还有工作是在场景分类上训练监督CNNs来学习目标检测。我们证明了在大型图像数据集上训练一个无监督DCGAN也可以学习到有趣的特征层次结构。使用文献中提出的指导性反向传播，判别器学习到的特征在卧室的典型部分（如床和窗户）上激活，这在图5中表明。为了进行比较，在同一图中，我们为随机初始化的特征提供了一个基线，这些特征未在语义相关或有趣的任何事物上激活。\n\n<font size=\"2\">图5（图略）：在右边，判别器中最后一个卷积层中前 6 个学习到的卷积特征的最大轴对齐响应的引导反向传播可视化。请注意，有少数的特征对床做出响应——LSUN卧室数据集中的中心对象。左边是一个随机过滤器基线。与之前的响应相比，几乎没有判别和随机结构。</font>\n\n#### 6.3 篡改生成器表示\n\n##### 6.3.1 忘记绘制某些对象\n\n​\t\t除了判别器学习到的表示之外，还有一个问题，即生成器学习了什么表示。示例质量表明，生成器学习主要场景组件（如床，窗户，灯，门和杂项家具）的特定对象表示。为了探索这些表示形式，我们进行了一个实验，试图从生成器中完全删除窗户。\n\n​\t\t在150个样本中，手动绘制了52个窗口边界框。在第二高的卷积层特征上，逻辑回归适合预测特征激活是否在窗户上（或不在窗户上），方法是使用这样的标准：即绘制的边界框内的激活是正向的，来自相同图像的随机样本是负向的。使用这种简单的模型，从所有空间位置删除所有权重大于零（总共200）的特征图。然后，在删除和不删除特征图的情况下随机生成新样本。\n\n​\t\t删除和不删除窗户生成的图像如图6所示，有趣的是，网络大多忘记在卧室里画窗户，并且用其他对象代替它们。\n\n<font size=\"2\">图6（图略）：顶行：模型的未修改示例。底行：删除了窗户的相同生成样本。一些窗户被删除了，剩下的被转换成具有相似视觉外观的物体，如门和镜子。虽然视觉质量有所下降，但整体场景构图仍然相似，这表明生成器在将场景表示与对象表示分开方面做得很好。可以进行扩展实验以从图像中删除其他对象并修改生成器绘制的对象。</font>\n\n##### 6.3.2 面部样本上的向量算术\n\n​\t\t在评估单词的学习表示的文章中表明，简单的算术运算揭示了表示空间中丰富的线性结构。一个典型的例子表明，向量（“King”）-向量（Man）+向量（“Woman”）产生了最近邻是Queen的向量。我们研究了生成器的 $Z$ 表示中是否会出现类似的结构。我们对视觉概念的示例样本集的 $Z$ 向量执行了类似的算术运算。对每个概念只进行单个样本的实验是不稳定的，但对三个样本的$Z$向量求平均表明，在语义上符合算术的生成是一致和稳定的。除了（图7）中所示的对象操作外，我们还演示了在Z空间中对面部姿态进行线性建模（图8）。\n\n<font size=\"2\">图7（图略）：视觉概念的向量计算。对每一列，对样本的$Z$向量求均值。然后在平均向量上执行算术运算来创建一个新向量$Y$。右手边的中心样本是通过将$Y$作为生成器的输入来生成的。为了演示生成器的插值能力，将采样比例为$+-0.25$的均匀噪声添加到$Y$中来生成其他8个样本。在输入空间中采用算术（底部两个示例）会导致由于未对准而导致的噪声重叠。</font>\n\n<font size=\"2\">图8（图略）：\"turn\"向量是根据四张向左看和向右看的面部平均样本创建的。通过沿着这条轴向随机样本中添加插值，我们可以可靠地改变他们的姿态。</font>\n\n​\t\t这些演示表明，可以使用我们的模型所学到的 $Z$ 表示来开发有趣的应用程序。之前（的文献）已经证明，条件生成模型可以学习对令人信服的对象属性（如比例、旋转和位置）进行建模。据我们所知，这是在纯无监督模型下首次演示这种发生情况。进一步探索和开发上述提到的向量算术可以显著减少复杂图像分布的条件生成建模所需要的数据数量。\n\n### 7 结论和未来工作\n\n​\t\t我们提出了一个训练生成对抗网络的更加稳定的架构集合，并且证明了对抗网络在监督学习和生成建模方面可以学习良好的图像表示。但仍然存在某些形式的模型不稳定性——我们注意到，随着模型训练时间越来越长，它们有时候会将过滤器的子集折叠到单个振荡模式。\n\n​\t\t未来的工作需要解决这一不稳定问题。我们认为将这个框架扩展到其他领域，例如视频（用于帧预测）和音频（用于语音合成的预训练特征）应当会非常有趣。对学习到的潜在空间（隐空间）的进一步研究也会是十分有趣的。\n\n### 致谢\n\n略。\n\n### 参看文献\n\n略。\n\n### 8 补充材料\n\n#### 8.1 评估 DCGANs 捕获数据分布的能力\n\n​\t\t我们提出将标准分类指标应用于我们模型的条件版本，来评估学习到的条件分布。我们在MNIST上训练了一个DCGAN（划分了一个10K的验证集），并且排列不变GAN基线，使用最近邻分类器将真实数据与生成的条件样本进行比较来评估模型。我们发现，从batchnorm中删除比例和偏差参数对两个模型都产生了更好的结果。我们推测batchnorm引入的噪声有助于生成模型更好地探索和生成底层数据分布。表3的结果展示了我们的模型与其他方法的对比。DCGAN模型与在训练数据集上拟合的最近邻分类器具有相同的测试误差——表明DCGAN在建模这个数据集的条件分布上表现出色。当每类100万个样本时，DCGAN性能优于InfiMNIST，一个使用平移和弹性形变训练示例的手工开发的数据增强管道。与利用学习到的每类转换的概率性生成数据增强技术相竞争，DCGAN会更加通用，因为它直接对数据建模而不是对数据进行变换。\n\n## 其他\n\n> 1. 相关术语\n>    + Latent Space（隐空间）\n>    + Leaky ReLU\n> 2. 数据集\n>    + MNIST：[MNIST数据集](http://t.csdn.cn/9RJg1)\n>    + LSUN：[LSUN数据集读取和解压-CSDN博客](https://blog.csdn.net/qq_39909808/article/details/124652219)\n>    + ImageNet-1k：[ImageNet数据集 & 下载-CSDN博客](http://t.csdn.cn/4lJn3)\n>    + CIFAR-10：[Dataset之CIFAR-10：CIFAR-10数据集的简介、下载、使用方法之详细攻略](https://aistudio.csdn.net/62e38a6fcd38997446774c71.html?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-2-82793025-blog-125194540.t5_layer_eslanding_D_0&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-2-82793025-blog-125194540.t5_layer_eslanding_D_0&utm_relevant_index=5)\n> 3. 相关资源\n>    + [UNSUPERVISED REPRESENTATION LEARNING WITH DEEP CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORKS - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/482748077)\n> 4. 引用：[1] Radford A ,  Metz L ,  Chintala S . Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks[J]. Computer ence, 2015.\n\n## 单词\n\n> 1. adoption 采用；接纳\n> 1. side-by-side 并排的，并行的\n> 1. critical 批判的，关键的，极其重要的\n> 1. concatenate  连接，连结\n> 1. elastic  有弹性的，灵活的\n> 1. superb 极佳的，非同一般的\n> 1. speculate  猜测，推测\n> 1. underlying 根本的，潜在的，下层的\n> 1. furniture  家具\n> 1. tackle  解决，与...交涉\n> 1. dramatically  剧烈地，明显地，夸张地\n> 1. obey 遵守，服从\n> 1. this is to our knowledge (that)... 据我们所知 \n> 1. consistent 持续的，一致的\n> 1. canonical   标准的，典型的\n> 1. assess  evaluate 评估\n> 1. differentiate 区分，使不同\n> 1. theoretically 理论上\n> 1. attribute 属性，特质\n> 1. trivially  无能地，琐细地\n> 1. scarce 稀有的，缺少的\n> 1. oscillation  振荡，摆动\n> 1. supplementary material 补充材料\n> 1. inspection 视察，检查\n> 1. robustness 鲁棒性\n> 1. visual inspection 目测，目检\n> 1. hash collision 哈希碰撞\n> 1. false positive rate 假阳性率，误报率\n> 1. information preserving technique 信息保存方法 \n> 1. notably 特别，尤其\n> 1. metric 度量，衡量标准\n> 1. contrast  差异 ，对比 \n> 1. augmentation  增大，增强\n> 1. a direct link 直接联系\n> 1. generalization performance 泛化性能\n> 1. multiplication 乘法\n> 1. demonstrate  证明，示范，演示\n> 1. collapse  倒塌，崩溃，瓦解\n> 1. standard deviation 标准差\n> 1. deviation 偏差\n> 1. utilize 利用，使用\n> 1. comparatively 相对地\n> 1. flatten 变平，击败\n> 1. tensor 张量\n> 1. spatial 空间的\n> 1. criticism 批评\n> 1. approximate 大概的，近似的；类似，接近\n> 1. texture 质地，纹理\n> 1. wobbly 不稳定的，摆动的  unstable\n> 1. diffusion 扩散，传播\n> 1. in the form of 以····形式\n> 1. synthesis 综合，合成\n> 1. incomprehensible 费解的\n> 1. suffer from 忍受，遭受\n> 1. applicability 适用性\n> 1. heuristic  启发式的\n> 1. super-resolution 超分辨率\n> 1. in-painting 图像修复\n> 1. property  特性，特质，财产，所有权\n> 1. compact  紧凑的，简洁的\n> 1. manipulation 操纵，处理\n> 1. arithmetic 算术的；算术\n> 1. empirical  经验主义的\n> 1. novel 新颖的\n> 1. nonsensical 无意义的，荒谬的\n> 1. intermediate  中间的\n> 1. context  背景；语境\n> 1. practically  几乎，实际上\n> 1. candidate 候选人，申请者\n> 1. hierarchy 等级制度，层次\n> 1. reusable 可重复使用的\n","tags":["GAN","DCGAN"],"categories":["文献阅读"]},{"title":"文献阅读--Conditional Generative Adversarial Nets","url":"/hexo-blogs/2022/08/19/文献阅读--Conditional Generative Adversarial Nets/","content":"\n# 文献阅读：Conditional Generative Adversarial Nets\n\n> {% timeline 更新时间线, blue %}\n> <!-- timeline 2022.08.24 -->\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n生成对抗网络最近作为一种训练生成模型的新方法被引入。在这项工作中，我们介绍了生成对抗网络的条件版本，它可以通过简单地输入数据$y$来构建，我们希望对生成器和判别器都施加条件。我们展示了该模型可以生成以类标签为条件的MNIST数字。我们还说明了该模型如何用于学习多模态模型，并提供了图像标记应用的初步示例，其中我们演示了如何生成不属于训练标签的描述性标签。\n\n### 1 引言\n\n为了规避估计许多棘手概率计算问题的困难，生成对抗网络作为可用于训练生成模型的框架被引入。\n\n对抗网络的优点是不需要马尔科夫链，只使用反向传播来更新梯度，学习过程中不需要推断，并且可以很容易地将各种因素和相互作用纳入模型中。\n\n另外，正如文献[8]中所介绍的，它可以生成最先进的对数似然和真实的样本。\n\n在一个无条件的生成模型中，无法控制正在生成的数据的模式。然而，通过添加附加信息到模型，它可以指导数据生成过程。这种条件可以基于类标签、某些用于修复的数据，甚至可以基于来自不同模态的数据。\n\n在这项工作中，我们展示了如何构建条件对抗网络。对于实验结果，我们展示了两组实验。一个基于类标签的MNIST数字数据集和一个基于MIRFLickr25,000数据集的多模态学习。\n\n### 2 相关工作\n\n#### 2.1 图像标注的多模态学习\n\n尽管监督神经网络（尤其是卷积网络）最近取得了许多成功，但扩展此类模型以适应大量预测输出类别仍然具有挑战性。第二个问题是迄今为止的大部分工作都集中在学习从输入到输出的一对一映射。然而，许多有趣的问题更自然而然地被认为是一个概率性的一对多映射。例如，在图像标注时，许多不同的标签可以适用于一张给定的图像，而不同的（人类）注释者会使用不同的（但是一般是同义词或者相关的）术语来描述同一张图像。\n\n帮助解决第一个问题的一种方式是利用来自其他模态的附加信息：例如，通过使用自然语言语料库来学习几何关系在语义上有关系的标签的向量表示。在这样的空间中进行预测，我们受益于这样的事实：当预测错误时，我们仍然可以接近事实（例如，预测桌子而不是椅子），并且我们可以自然地对那些我们在训练期间从未遇到的标签做预测性的泛化。文献[3]中的工作表明，即使一个从图像特征空间到单词表示空间的简单线性映射也可以提高分类性能。\n\n解决第二个问题的一种方式是使用条件概率生成模型，将输入视为条件变量，并将一对多映射实例化为一个条件预测分布。\n\n文献[16]对这个问题采取了类似的方法，并像我们在这项工作中所做的那样，在MIR Flickr 25,000数据集上训练一个多模态深度玻尔兹曼机。\n\n此外，文献[12]中作者展示了如何训练一个有监督的多模态神经语言模型，并且他们能够为图像生成描述性语句。\n\n### 3 条件对抗网络\n\n#### 3.1 生成对抗网络\n\n近来，生成对抗网络作为一种训练生成模型的新方法被引入。他有两个对抗模型组成：一个捕获数据分布的生成模型$G$，和一个估计样本来自训练数据而不是$G$的概率的判别模型$D$。$G$和$D$都可以是一个非线性映射函数，例如多层感知器。\n\n从数据$x$上学习一个生成器分布$p_g$，生成器建立一个从预先噪声分布$p_z(z)$到数据空间的映射函数$G(z;\\theta_g)$。判别器$D(x;\\theta_d)$输出一个标量，表示$x$来自训练数据而不是$p_g$的概率。\n\n$G$和$D$同时进行训练：我们调整$G$的参数来最小化$log(1-D(G(z)))$，调整$D$的参数来最小化$logD(x)$，就如同他们在遵守价值函数$V(G,D)$的两人最小最大博弈：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z)))]  \\tag{1}\n$$\n\n#### 3.2 条件对抗网络\n\n如果生成器和判别器都以某些额外信息$y$为条件，可以将生成对抗网络扩展到一个条件模型。$y$可以是任何类型的辅助信息，例如类别标签或来自其他模态的数据。我们可以通过将$y$作为附加输入层添加到判别器和生成器中来执行调节。\n\n在生成器中，将先验噪声输入$p_z(z)$和$y$组合成联合隐藏表示，对抗训练框架在如何组合这些隐藏表示具有相当大的灵活性（1：或者现在我们只是将条件输入和先验噪声作为 MLP 的单个隐藏层的输入，但是可以想象如果使用更高阶的交互来实现复杂的生成机制，在传统的生成框架中是非常难以使用的。）。\n\n在判别器中$x$和$y$作为输入和判别函数（这种情况下再次体现为MLP）。\n\n这个二人最小最大博弈的目标函数如公式2所示：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x|y)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z|y)))]  \\tag{2}\n$$\n图1描述了一个简单的条件对抗网络架构。\n\n![image-20220823180125570](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622790.png)\n\n### 4 实验结果\n\n#### 4.1 单模态\n\n我们在基于类标签、one-hot向量编码的MNIST图像集上训练了一个条件对抗网络。\n\n在生成器网络中，从单位超立方体内提取一个100维度的噪声先验$z$，$z$和$y$都映射到具有线性修正单元（ReLU）激活的隐藏层，层大小分别为200和1000，然后被映射到第二个组合的1200维的隐藏ReLu层。然后我们有一个最终的 sigmoid 单元层作为我们的输出，用于生成 784 维 的MNIST 样本。\n\n![image-20220823183721523](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622792.png)\n\n判别器将$x$映射到一个有240个单元和5个块的maxout层，将$y$映射到一个有50个单元和5个块的maxout层。这两个隐藏层都映射到具有 240 个单元和 4 个块的联合 maxout 层，然后被馈送到 sigmoid 层。（只要有足够的能力，鉴别器的精确架构并不重要；我们发现 maxout 单位通常非常适合该任务）\n\n该模型以随机梯度下降训练，其小批量大小为100，初始学习率为 0.1，它以指数方式下降到 0.000001，衰减因子为 1.00004。动量也被使用，初始值为 0.5，增加到 0.7。概率为0.5的dropout也应用到生成器和判别器中。在验证集上最佳的对数似然估计被用来作停止点。\n\n表1展示了在MNIST数据集测试数据上的高斯Parzen窗口对数似然估计。从每10个类别中抽取1000个样本，使用Gaussian Parzen window拟合这些样本。然后使用Parzen window分布估计测试集的对数似然（如何构建这个估计的详细内容参见文献[8]）。\n\n我们提出的条件对抗网络结果与其他一些基于网络的结果相当，但优于其他几种方法——包括非条件对抗网络。我们将这些结果更多地作为概念验证而不是功效证明，并相信随着对超参数空间和架构的进一步探索，条件模型应该匹配或超过非条件结果。\n\n图2展示了一些生成样本。每一行都以一个标签为条件，每一列都是不同的生成样本。\n\n![image-20220823193835278](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622793.png)\n\n#### 4.2 多模态\n\n像Flickr这样的照片网站是图像及其相关的用户生成元数据（UGM）形式的标记数据的丰富来源——尤其是用户标签。\n\n用户生成的元数据不同于更“规范”的图像标记方案，因为它们通常更具描述性。并且在语义上更接近人类用自然语言描述图像的方式，而不仅仅是识别图像中存在的对象。UGM的另一个方面是有很多同义词，不同的用户可能使用不同的词汇描述同样的概念——因此，有一个有效的方法来规范化这些标签很重要。概念词嵌入在这里非常有用，因为相关的概念最终用相似的向量表示。\n\n在本节中，我们演示了图像的自动标记，具有多标签预测，使用条件对抗网络生成以图像特征为条件的（可能是多模态的）标签向量分布。\n\n对于图像特征，我们在具有21000个标签的完整ImageNet数据集上预训练了一个类似于文献[13]中的卷积模型。我们使用具有4096个单元的最后一个全连接层的输出作为图像表示。\n\n对于世界表示，我们首先从YFCC100M数据集元数据的用户标签、标题和描述的串联中收集文本语料库。在对文本进行预处理和清洗之后，我们训练了一个词向量大小为200的skip-gram模型。我们从词汇表中省略了出现次数少于200次的所有单词，从而得到大小为24765的字典。\n\n我们在对抗网络的过程中保持卷积网络和语言模型不变。我们将要通过这些模型进行反向传播的实验留作未来的工作。\n\n我们的实验中，使用了MIR Flickr 25,000数据集，使用我们上面提到的卷积模型和语言模型来抽取图像和标签特征。实验中会省略没有任何标签的图像，并且将注释视为额外标签。前150,000个样本作为训练集。对每个相关联的标签，多标签的图像在训练集中会被重复一次。\n\n在评估时，我们为每个图像生成 100 个样本，并使用词汇表中单词的向量表示与每个样本的余弦相似度来找到前 20 个最接近的单词。然后我们在所有100个样本中选择前10个最常用的词。表4.2展示了一些用户分配的标签和注释的示例以及生成的标签。\n\n![image-20220824154342673](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208241622794.png)\n\n最佳工作模型的生成器接收大小为100的高斯噪声作为噪声先验并且映射到维度为500的ReLU层。映射4096维的图像特征向量到2000维的ReLu隐藏层。这两个层都被映射到一个维度为200的组合表示的线性层，用来输出生成的单词向量。\n\n判别器分别由用于词向量和图像特征的500维和1200维ReLu隐藏层，作为连接层的有1000个单元和3个块的maxout层组成，最后发送到单个sigmoid单元。\n\n该模型以随机梯度下降训练，其小批量大小为100，初始学习率为 0.1，它以指数方式下降到 0.000001，衰减因子为 1.00004。动量也被使用，初始值为 0.5，增加到 0.7。概率为0.5的dropout也应用到生成器和判别器中。\n\n通过交叉验证，以及使用随机网格搜索和人工选择的混合（尽管搜索空间有限）来确定超参数和架构选择。\n\n### 5 未来工作\n\n本文展示的结果是非常初步的，但它们表明了条件对抗网络的潜力，展示了有趣并且有用的应用前景。\n\n在从现在到研讨会之间的未来探索中，我们希望展示更复杂的模型，并对他们的性能和特点作更详细和透彻的分析。\n\n此外，在当前的实验中，我们只单独使用每个标签。但是通过同时使用多个标签（有效地将生成问题作为“集合生成”问题之一），我们希望获得更好的结果。\n\n留给未来工作的另一个明显方向是构建联合训练方案来学习语言模型。文献[12] 等工作表明，我们可以学习适合特定任务的语言模型。\n\n### 致谢\n\n略。\n\n### 参看文献\n\n略。\n\n## 其他\n\n> 1. 引用：[1] Mirza M ,  Osindero S . Conditional Generative Adversarial Nets[J]. Computer Science, 2014:2672-2680.\n\n## 单词\n\n> 1. multi-modal 多模态的\n> 2. albeit 虽然，尽管\n> 3. preliminary 初步的；预备的\n> 4. scalar 标量\n> 5. thorough 透彻的，深入的\n> 6. sophisticated 见多识广的，复杂巧妙的，精密的；complicated\n> 7. respectively 分别地\n> 8. hypercube 超立方体\n> 9. state of the art 最先进的; 最新水平的\n> 10. accommodate 容纳，适应，迁就\n> 11. probabilistic 概率性的\n> 12. considerable 相当大的，相当重要的\n> 13. geometric relation 几何关系\n\n","tags":["GAN","CGAN"],"categories":["文献阅读"]},{"title":"文献阅读：《Generative Adversarial Nets》","url":"/hexo-blogs/2022/08/19/文献阅读--Generative Adversarial Nets/","content":"\n# 文献阅读：《Generative Adversarial Nets》\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.08.19 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 译文\n\n### 摘要\n\n我们通过对抗过程，提出一个预测生成式模型的新框架。我们同时训练了两个模型：一个捕获数据分布的生成模型G，一个可以预测来自训练数据而不是G的样本概率的判别模型D。G的训练过程是最大化D犯错误的概率。这个框架类似于一个极大极小的二人游戏。在任意函数G和D的空间中，存在唯一解：G恢复训练数据的分布，而D任何地方都等于1/2。在G和D都被定义为一个多层感知器的情况下，整个系统通过反向传播来训练。在训练或生成样本的过程中，不需要任何的马尔科夫链或者展开近似推理网络。通过对生成样本进行定性和定量分析，实验证明了该框架的潜力。\n\n### 1 简介\n\n深度学习的宗旨是发现丰富的分层模型，这些模型可以表示人工智能应用中遇到的各种数据的概率分布，例如自然图像、包含语音的音频波形以及自然语言语料库中的符号。目前，深度学习中涉及到判别模型并取得最显著成功的，通常是那些将高维度的，丰富的感官输入映射到一个类标签的模型。这些成功的模型主要是基于BP算法和dropout算法，使用一个分段线性单元，具有特别良好的梯度。由于难以逼近在极大似然估计及其相关策略中出现的许多棘手的概率计算，也由于在生成上下文中难以利用分段线性单元的优势，深度生成模型受到的影响较小。我们提出了一个新的生成模型估计程序来规避这些困难。\n\n在提出的对抗网络框架中，生成模型与对手对抗：一个判别模型学习确定样本来自模型分布还是数据分布。生成模型可以被认为类似于一个造假者团队，试图制造假币并在不被发现的情况下使用它，而判别模型类似于警察，试图检测假币。这场比赛的竞争促使双方改进他们的方法，直到假货与真品无法区分。\n\n这套框架可以为多种模型和优化算法生成特别的训练算法。本文中，我们探讨了生成模型通过多层感知机传递随机噪声来生成样本的特殊情况，判别模型也同样是一个多层感知机。我们将这种特殊情况称为对抗网络。在这种情况下，我们可以仅仅使用非常成功的反向传播和dropout算法来训练两个模型，并且只使用正向传播来训练生成模型的样本。而无需近似推理或者马尔科夫链。\n\n### 2 相关工作\n\n具有潜在变量的有向图模型的替代方案是具有潜在变量的无向图模型，例如受限玻尔兹曼机 (RBM) [27, 16]、深度玻尔兹曼机 (DBM) [26] 及其众多变体。此类模型中的相互作用表示为未归一化势函数的乘积，通过对随机变量的所有状态的全局求和/积分进行归一化。这个数量(配分函数)和它的梯度是棘手的，但最琐碎的情况下，他们可以由马尔可夫链蒙特卡罗(MCMC)方法估计。对于依赖于MCMC的学习算法来说，混合是一个很重要的问题。\n\n深度置信网络(DBNs)[16]是包含一个无向层和多个有向层的混合模型。虽然存在一种快速的分层近似训练准则，但DBNs存在与无向和有向模型相关的计算困难。\n\n也有人提出了不近似或不限制对数似然的替代标准，如分数匹配和噪声对比估计(NCE)。这两者都需要将学习的概率密度分析指定为一个归一化常数。请注意，在许多具有多层潜在变量（例如 DBNs 和 DBMs）的有趣生成模型中，甚至不可能推导出易于处理的非归一化概率密度。一些模型诸如去噪自动编码器 [30] 和收缩自动编码器，其学习规则与应用于 RBM 的分数匹配非常相似。在NCE中，和本文一样，使用了判别训练标准来拟合生成模型。然而，生成模型本身用于从固定噪声分布的样本中区分生成的数据，而不是拟合一个单独的判别模型。由于NCE使用一个固定的噪声分布，当模型在观察变量的一个小子集上学习到一个近似正确的分布之后，学习速度会显著减慢。\n\n最后，一些技术不涉及明确定义概率分布，而是训练生成机器从期望分布中抽取样本。这种方法的优点是可以通过反向传播来训练这些机器。该领域近期主要的工作包括生成随机网络(GSN)框架：它扩展了广义去噪自动编码器：两者都可以看作是定义一个参数化的马尔科夫链，即学习一台机器的参数，执行生成马尔科夫链的一个步骤。与GSNs相比，对抗网络框架的采样不需要马尔科夫链，由于对抗网络在生成过程中不需要反馈环，所以它们能够更好地利用分段线性单元，这提高了反向传播的性能，但在使用反馈环时存在无限制激活的问题。通过反向传播训练生成机器的最新工作包括自动编码变分贝叶斯和随机反向传播。\n\n### 3 对抗网络\n\n当模型都是多层感知机的时候，对抗网络框架最容易应用。为了学习生成器在数据$x$上的分布$p_g$，我们事先定义了一个输入噪声变量$p_z(z)$，然后用$G(z;\\theta_g)$表示将噪声变量映射到数据空间，$G$是一个可微函数，表示为一个参数为$\\theta_g$的多层感知机。我们还定义了一个多层感知机$D(x,\\theta_d)$输出一个标量。$D(x)$表示$x$来自数据集而不是$p_g$的概率。我们训练$D$来最大化将正确标签分配给训练样本和来自$G$的样本的概率。与此同时，我们训练$G$来最小化$log(1-D(G(z)))$：换句话说，$D$和$G$进行了如下具有值函数$V(G,D)$的二人极大极小博弈：\n$$\n\\underset{G}{min}\\underset{D}{max}V(D,G)=E_{x\\sim{p_{data}(x)}}[logD(x)]+E_{z\\sim{p_{z}(z)}}[log(1-D(G(z)))]. \\tag{1}\n$$\n在下一节中，我们将对对抗网络进行理论分析，主要说明当$G$和$D$分配有足够容量时，也就是在非参数限制时，训练准则允许恢复数据生成分布。如图1所示，对该方法进行了一个不太正式、更具教育性的解释。实践中，我们必须使用一个迭代的数值方法来实现这种操作。在训练的内部循环中优化$D$来完成计算是极其困难的，并且在有限的数据集上会导致过拟合。相反，我们在优化$D$的$k$个步骤和优化$G$的一个步骤之间交替进行。只要$G$变化足够慢，$D$的解就会保持在其最优解附近。这种策略类似于SML/PCD：训练从一个学习步骤到下一个学习步骤保持来自马尔可夫链的样本，以避免作为学习内部循环的一部分在马尔可夫链中消失。该过程在算法1中正式给出。\n\n在实际应用中，公式$1$可能无法为$G$提供足够的梯度来学习。在学习的早期，当$G$较差时，$D$可以很有信心地拒绝样本，因为它们与训练数据明显不同。在这种情况下，$log(1 - D(G(z)))$饱和，与其训练$G$去最小化$log(1 - D(G(z))$不如训练$G$去最大化$logD(G(z))$。这一目标函数的结果与动态的$G$和$D$相同，但在学习的早期提供了更强的梯度。\n\n![图1](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443946.png)\n\n图1：通过同时更新判别分布（$D$，蓝色，虚线）来训练生成对抗网络，以便它区分来自数据生成分布（黑色，虚线）$p_x$ 的样本和生成分布 $p_g(G)$（绿色，实线）的样本。下面的水平线是 $z$ 被采样的域，在这种情况下是均匀的。上面的水平线是 $x$ 域的一部分。向上的箭头显示了映射 $x = G(z)$ 如何将非均匀分布 $p_g$ 施加到变换后的样本上。$G$ 在$p_g$ 的高密度区域收缩并在$p_g$的低密度区域膨胀。（a）考虑一个接近收敛的对抗对：$p_g$与$p_{data}$类似，$D$是部分准确的分类器。（b）算法$D$的内部循环被训练来判别数据集的样本，收敛到$D^{*}(x)=\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)}$。（c）在对 $G$ 进行更新后，$D$ 的梯度引导 $G(z)$ 流向更有可能被分类为数据的区域。（d）在几轮训练后，如果$G$和$D$还有足够的容量，它们将因为$p_g=p_{data}$而达到两者都无法提高的地步。判别器无法区分这两种分布，即$D(x)=\\frac{1}{2}$。\n\n### 4 理论结果\n\n生成器 $G$ 隐含地将概率分布 $p_g$ 定义为当 $z∼p_z$ 时获得的样本 $G(z)$ 的分布。因此，如果给定足够的容量和训练时间，我们希望算法 1 能够收敛到一个好的 $p_{data}$ 估计器。例如，本节的结果是在非参数设置中完成的。我们通过研究概率密度函数空间中的收敛性来表示具有无限容量的模型。\n\n我们将在 4.1 节展示这个极小极大博弈对于 $p_g = p_{data}$ 有一个全局最优解。然后我们将在 4.2 节中展示算法 1 优化 $Eq1$，从而获得期望的结果。\n\n![image-20220816171632123](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191441414.png)\n\n#### 4.1 $p_g=p_{data}$的全局最优\n\n我们首先考虑任何给定生成器 $G$ 的最佳判别器 $D$。\n\n**命题1. **固定$G$，最优判别器$D$为\n$$\nD^{*}_{D}(x)=\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)} \\tag{2}\n$$\n证明：给定任何生成器 $G$，判别器 $D$ 的训练标准是最大化 $V(G, D)$\n$$\n\\begin{aligned}\nV(G,D)&=\\int_{x}p_{data}(x)log(D(x))dx+\\int_{z}p_{z}(z)log(1-D(g(z)))dz \\\\ &=\\int_{x}p_{data}(x)log(D(x))+p_{g}(x)log(1-D(x))dx  \n\\end{aligned}  \\tag{3}\n$$\n\n对任意$(a,b)\\in{R^2}\\setminus\\{0,0\\}$，函数$y\\rightarrow{alog(y)+blog(1-y)}$在$\\frac{a}{a+b}$的$[0,1]$区间内达到最大值。判别器不需要在集合$Supp(p_{data})\\cup{Supp(p_g)}$之外定义，证明结束。\n\n请注意，$D$的训练目标可以解释为：最大化对数似然来估计条件概率$p(Y=y|x)$，这里$Y$表示$x$来自于$p_{data}$（$y=1$）或者$p_g$（$y=0$）。现在，式1中的极大极小博弈可以重述为：\n$$\n\\begin{aligned}\nC(G)&=\\underset{D}{max}V(G,D) \\\\\n&=E_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{z\\sim{p_z}}[log(1-D^*_G(z))] \\\\\n&=E_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{x\\sim{p_g}}[log(1-D^*_G(x))] \\\\\n&=E_{x\\sim{p_{data}}}[log{\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)}}]+E_{x\\sim{p_g}}[log{\\frac{p_g(x)}{p_{data}(x)+p_g(x)}}]\n\\end{aligned} \\tag{4}\n$$\n**定理1.**当且仅当$p_g=p_{data}$时，虚拟训练标准$C(G)$达到全局最小值。此时，$C(G)$的值等于$-log4$。\n\n证明：对$p_g=p_{data}$，$D^*_G(x)=\\frac{1}{2}$，（参见式2）。将$D^*_G(x)=\\frac{1}{2}$代入式4，可以发现$C(G)=log{\\frac{1}{2}}+log{\\frac{1}{2}}=-log4$。仅在$p_g=p_{data}$时，$C(G)$达到最佳可能值，观察到\n$$\nE_{x\\sim{p_{data}}}[-log2]+E_{x\\sim{p_g}}[-log2]=-log4\n$$\n用$C(G)=V(D^*_G,G)$减去该式，可以得到：\n$$\nC(G)=-log(4)+KL\\bigg(p_{data}\\parallel{\\frac{p_{data}+p_g}{2}}\\bigg)+KL\\bigg(p_{g}\\parallel{\\frac{p_{data}+p_g}{2}}\\bigg) \\tag{5}\n$$\n其中$KL$是Kullback-Leibler散度。在先前的表达式中我们认识到模型分布和数据生成过程之间的Jensen–Shannon散度：\n$$\nC(G)=-log(4)+2\\cdot{JSD(p_{data}\\parallel{p_g})}  \\tag{6}\n$$\n由于两个分布之间的Jensen-Shannon散度始终非负且为零，我们已经证明$C^*=-log(4)$是$C(G)$的全局最小值，并且唯一解为$p_g=p_{data}$，也就是说，该生成模型完美复制了数据生成过程。\n\n#### 4.2 算法1的收敛\n\n**命题2. **假定$G$和$D$有足够容量，在算法1中的每一个步骤，在给定$G$的情况下允许判别器达到最优值，并更新$p_g$以改进判断依据\n$$\nE_{x\\sim{p_{data}}}[logD^*_G(x)]+E_{x\\sim{p_g}}[log(1-D^*_G(x))]\n$$\n然后$p_g$收敛到$p_{data}$。\n\n证明：如上所述的判据，考虑将$V(G,D)=U(p_g,D)$作为$p_g$的函数。注意$U(p_g,D)$在$p_g$上是凸的。凸函数在上确界的子导数包括函数在达到最大值点处的导数。换句话说，对$\\forall{\\alpha}$，如果$f(x)=sup_{\\alpha\\in{A}}f_{\\alpha}(x)$和$f_{\\alpha}(x)$在$x$上是凸的，且如果$\\beta=arg\\:sup_{\\alpha\\in{A}}f_{\\alpha}(x)$，那么$\\partial{f_{\\beta}(x)}\\in{\\partial{f}}$。这相当于在给定相应$G$ 的情况下计算最优 $D$ 处 $p_g$的梯度下降更新。如定理1所证明的，$sup_DU(p_g,D)$在$p_g$上是凸的，具有唯一全局最优值，因此，只要$p_g$有足够小的更新，$p_g$可以收敛到$p_x$，证明结束。\n\n在实践中，对抗网络通过函数 $G(z; θg )$ 表示有限的 $p_g$ 分布簇，我们优化 $θ_g$ 而不是 $p_g$ 本身。使用多层感知器来定义 $G$ 在参数空间中引入了多个临界点。无论如何，多层感知器在实践中的出色表现表明，尽管缺乏理论保证，但它们是一个合理的模型。\n\n### 5 实验\n\n我们训练了一系列数据集的对抗网络，包括MNIST，多伦多人脸数据库（TFD）和CIFAR-10。生成器混合使用整流线性激活和sigmoid激活，判别器使用maxout激活。Dropout用于训练判别器。虽然我们的理论框架允许在生成器的中间层使用dropout和其他噪声，但我们只将噪声作为生成网络最底层的输入。\n\n![image-20220818140517291](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443947.png)\n\n表1：基于 Parzen 窗口的对数似然估计。他在 MNIST 上报告的数字是测试集上样本的平均对数似然，其平均误差通过实例计算。.在 TFD 上，我们计算了每折数据集的标准误差，每折验证集选择了不同的$\\sigma$。在TFD上，$\\sigma$对每折进行交叉验证，并计算每折的平均对数似然。我们在MNIST和其他具有实值（而不是二进制）版本的数据集进行对比。\n\n我们通过将Gaussian Parzen 窗口拟合到使用 $G$ 生成的样本并报告此分布下的对数似然来估计 $p_g$ 下的测试集数据的概率。高斯分布的参数$\\sigma$通过在验证集上的交叉验证得到。Breuleux等人介绍了这一过程并用于各种生成模型，这些模型的准确性并不可控。表1展示了这些结果。他估计可能性的方法具有较高的方差，并且在高维空间中表现不佳，但它是我们所知的最佳方法。可以采样但不能估计可能性的生成模型的进步直接推动了对如何评估此类模型的进一步研究。\n\n在图2和图3中我们展示了训练后从生成器中抽取的样本。我们并没有声称这些样本比现有方法生成的样本更好，但我们相信这些样本至少与文献中更好的生成模型可以进行竞争，并突出了对抗框架的潜力。\n\n![image-20220818145150628](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443948.png)\n\n图2：来自模型的样本的可视化。最右列显示相邻样本的最接近训练示例，为了证明模型没有记住训练集。样本是公平的随机抽选，而不是精心挑选的。不像大多数其他深度生成模型，这些图像展示来自模型分布的真实样本，而不是给定隐藏单元样本的平均值。此外，这些样本是不相关的，因为采样过程不依赖于马尔可夫链混合。a) MNIST b) TFD c) CIFAR-10 （全连接模型）d) CIFAR-10 （卷积判别器和“反卷积”判别器）\n\n![image-20220818150235511](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202208191443949.png)\n\n图3：通过在完整模型的 $z$ 空间中的坐标之间进行线性插值获得的数字\n\n|            | 深度有向图模型           | 深度无向图模型                              | 生成式自动编码器                           | 对抗模型                                   |\n| ---------- | ------------------------ | ------------------------------------------- | ------------------------------------------ | ------------------------------------------ |\n| 训练       | 训练时需要推断           | 训练时需要推断。MCMC 需要近似配分函数梯度。 | 在混合和重建生成的权之间进行强制权衡       | 同步判别器和生成器。Helvetica。            |\n| 推断       | 学习近似推断             | 变分推断                                    | 基于MCMC的推断                             | 学习近似推断                               |\n| 采样       | 没有难度                 | 要求马尔科夫链                              | 要求马尔科夫链                             | 没有难度                                   |\n| 评估$p(x)$ | 棘手的，可以用 AIS 近似  | 棘手的，可以用 AIS 近似                     | 没有明确表示，可以用 Parzen 密度估计来近似 | 没有明确表示，可以用 Parzen 密度估计来近似 |\n| 模型设计   | 几乎所有模型都会遇到困难 | 需要精心设计以确保多个属性                  | 理论上允许任何可微函数                     | 理论上允许任何可微函数                     |\n\n表2：生成模型中的挑战：对涉及模型的每个主要操作的深度生成建模的不同方法遇到的困难的总结\n\n### 6 优点和缺点\n\n相对于以前的建模框架，这个新框架具有优点和缺点。缺点是对$p_g(x)$没有明确地表达，并且$D$在训练过程中必须与$G$很好地同步（特别地，在在不更新$D$的情况下，$G$不能训练太多，为了避免\"Helvetica场景\"，$G$ 将过多的 $z$ 值折叠为相同的 $x$ 值，从而有足够的多样性来建模 $p_{data}$），就像玻尔兹曼机器的负链必须在学习步骤之间保持更新一样。优点就是不需要马尔科夫链，而只用反向传播来更新梯度，在学习时不需要推断，并且可以将多种函数集合到模型中。表2总结了生成对抗模型和其他生成模型方法的对比。\n\n上述优势主要是计算上的。对抗模型也可能从生成器网络中获得一些统计优势，而不是直接使用数据样本进行更新，而只是使用流经鉴别器的梯度。这意味着输入元素不会直接复制到生成器的参数中。对抗网络的另一个优点是它们可以表示非常尖锐甚至退化的分布，而基于马尔可夫链的方法要求分布有些模糊，以便链能够在模式之间混合。\n\n### 7 结论和未来工作\n\n这个框架允许许多直接的扩展：\n\n1. 添加$c$作为输入到$G$和$D$中可以得到一个条件生成模型$p(x|c)$。\n2. 通过训练一个辅助网络来预测给定$x$的$z$，其中可以使用学习近似推断。这类似于由wake-sleep算法训练的推断网络，但其优点是可以在生成网络完成训练后为固定生成网络训练推断网络。\n3. 通过训练共享参数的一系列条件模型，可以近似地对所有条件 $p(x_S|x_\\bar{s})$ 建模，其中 $S$ 是 $x$ 的索引的子集。本质上，可以使用对抗网络来实现确定性 MP-DBM 的随机扩展。\n4. 半监督学习：当有限的标记数据可用时，来自判别器或推断网络的特征可以提高分类器的性能。\n5. 效率提升：通过划分更好的方法来协调$G$和$D$或者确立更好的分布来从训练中采样$z$，可以大大加快训练速度。\n\n本文证明了对抗性建模框架的可行性，表明这些研究方向可能是有用的。\n\n### 致谢\n\n> 略。\n\n### 参考文献\n\n> 略。\n\n## 其他\n\n> 1. 代码地址：http://www.github.com/goodfeli/adversarial\n> 2. 引用：[1] Goodfellow I ,  Pouget-Abadie J ,  Mirza M , et al. Generative Adversarial Nets[C]// Neural Information Processing Systems. MIT Press, 2014.\n\n## 单词\n\n> 1. simultaneously  at the same time  同时\n> 2. pedagogical 教育的\n> 3. sharp  尖锐的\n> 4. demonstrate  证明；演示\n> 5. blurry  模糊的\n> 6. theorem 定理\n> 7. viability 可行性\n> 8. equivalent  等效的；对等的物\n> 9. replicate 复制，重复\n> 10. conclude 结束，达成\n> 11. momentum 动量\n> 12. convergence 收敛，相交\n> 13. contract 收缩，缩小；契约，合同\n> 14. arrow 箭头\n> 15. horizontal 水平的\n> 16. saturate 浸透，饱和\n> 17. alternate 轮流，交替\n> 18. overfitting 过拟合\n> 19. prohibitive 限制性的\n> 20. finite 有限的\n> 21. discriminative  有区别的，表示差别的\n> 22. arbitrary 随意的\n> 23. perceptron 感知器\n> 24. procedure 程序；过程\n> 25. approximate 近似\n> 26. inference  n.推理\n> 27. potential 潜在的 ；潜力\n> 28. qualitative and quantitative 定性和定量\n> 29. hierarchical 分层的\n> 30. map 映射\n> 31. waveform 波形\n> 32. encounter 遭遇；邂逅\n> 33. corpora 语料库\n> 34. striking 引人注目的\n> 35. involve 涉及\n> 36. piecewise 分段的\n> 37. intractable 棘手的\n> 38. maximum likelihood estimation 最大似然估计\n> 39. sidestep  回避\n> 40. analogous 类似的\n> 41. counterfeit 伪造，假冒的\n> 42. indistinguishable 难以区分的\n> 43. restrict 限制；控制\n> 44. variant 变种，变体\n> 45. trivial 琐碎的\n> 46. criterion 标准\n> 47. incur 带来，招致\n> 48. bound 限制；受约束的；边界\n> 49. contrastive 对比的\n> 50. density  密度\n> 51. tractable 易处理的\n> 52. contractive 收缩的\n> 53. dramatically 剧烈地，戏剧性地\n> 54. explicitly 明确地\n> 55. implicitly 含蓄地，隐含地\n> 56. prominent 重要的，显著的，突出的\n> 57. stochastic 随机的\n> 58. i.e.   即，也就是\n> 59. straightforward 直截了当地；简单的\n> 60. differentiable 可微分的，可区分的\n> 61. theoretical 理论上的\n> 62. formal  正式的，合法的","tags":["GAN"],"categories":["文献阅读"]},{"title":"Python学习笔记(2)--初级编程","url":"/hexo-blogs/2022/08/19/Python学习笔记(2)--初级编程/","content":"\n# Python学习笔记(2)——初级编程\n\n<!--start: 2022.04.19-->\n\n## Python输入和输出\n\n### 键盘输入\n\n> +  [input() 函数](https://www.runoob.com/python3/python3-func-input.html)从标准输入读入一行文本，返回为 string 类型。默认的标准输入是键盘。\n\n```python\n>>> a = input(\"请输入你的名字:\")   # 里面可以包含提示信息\n请输入你的名字:Jerry\n>>> a\n'Jerry'\n\n>>> a,b,c = input('请输入三角形三边的长:').split()  # 通过split()分割字符串得到多个输入\n请输入三角形三边的长:3 4 5\n>>> a\n'3'\n>>> b\n'4'\n>>> c\n'5'\n```\n\n### 控制台输出\n\n> + Python两种输出值的方式：表达式语句和print()函数。\n> + 将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。\n> + 用 str.format() 函数来格式化输出值。\n\n```python\n>>> s = 'Hello'\n>>> s                  # 表达式语句输出：输出整个表达式\n'Hello'\n>>> print(s)           # print()函数输出：输出表达式的内容\nHello\n\n>>> x = 10 * 4; y = 200 * 200\n>>> s = 'x的值为: ' + repr(x) + ', y的值为:' + repr(y)  # repr()将值转为字符串\n>>> print(s)\nx的值为: 40, y的值为:40000\n>>> s = repr('hello\\n')   # repr()可以转义字符串中的特殊字符\n>>> print(s)\n'hello\\n'\n>>> repr((10,20,'Hello'))  # repr()的参数可以是任何对象\n\"(10, 20, 'Hello')\"\n>>> str(10)                   # str()将值转为字符串\n'10'\n>>> print(str('Hello\\n'))     # str()不可以转义字符串中的特殊字符\nHello\n>>> str((10,20,'Hello'))      # str()的参数可以是任何对象\n\"(10, 20, 'Hello')\"\n\n# 括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。\n>>> print('{}:{}'.format('2022','明天我想见到你'))\n2022:明天我想见到你\n# 括号中的数字用于指向传入对象在 format() 中的位置\n>>> print('{0}:{1}'.format('2022','明天我想见到你')) \n2022:明天我想见到你\n>>> print('{1}:{0}'.format('2022','明天我想见到你'))\n明天我想见到你:2022\n# 在 format() 中使用关键字参数\n>>> print('{year}:{text}'.format(year = '2022',text = '明天我想见到你'))  \n2022:明天我想见到你\n# 字段名后面使用冒号:跟着格式标识符——{name:.2f}。这就允许对值进行更好的格式化。 \n>>> print('常量PI保留2位小数为{pi:.2f}'.format(pi = 3.141592653))  # 格式化数字,f表示浮点数,可以使用小数点后跟位数表示保留几位小数；d表示整数\n常量PI保留2位小数为3.14\n# 字段名后面使用冒号:跟着一个整数——{name:10}。表示对从name的第一个字符开始，后面至少宽度为10。\n>>> print('我要离你远一点:{我:20}==>{你}'.format(你 = 'GoeGoodyLv', 我 = 'Jerry'))\n我要离你远一点:Jerry               ==>GoeGoodyLv\n```\n\n### 文件读写\n\n> + open() 将会返回一个 file 对象。基本语法格式为：\n>\n>   ```python\n>   open(filename, mode)\n>   ```\n>\n>   + filename：文件名。\n>   + mode：决文件打开模式。默认文件访问模式为只读(r)。建议都显式指明打开方式。\n>   \n> + 文件的相对路径为与代码文件的同级目录。\n\n#### File打开模式\n\n| 模式   | **描述**                                                     |\n| :----- | :----------------------------------------------------------- |\n| **r**  | **以只读方式打开文件。文件的指针将会放在文件的开头。文件必须存在。这是默认模式。** |\n| rb     | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。文件必须存在。 |\n| **r+** | **打开一个文件用于读写。文件指针将会放在文件的开头。文件必须存在。** |\n| rb+    | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。文件必须存在。 |\n| **w**  | **打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。** |\n| wb     | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| **w+** | **打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。** |\n| wb+    | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| **a**  | **打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。** |\n| ab     | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| **a+** | **打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。** |\n| ab+    | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204191028869.png)\n\n#### File方法\n\n1. `open()`\n   + 打开一个文件，并返回文件对象。\n   + 如果该文件无法被打开，会抛出 OSError。\n   + **使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。**\n   + 基本语法：`open(file, mode='r')`\n2. `f.read()`\n   + 读取一个文件的内容，调用 f.read(size), 这将读取大小为size的数据, 然后作为字符串或字节对象返回。\n   + size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。\n3. `f.readline()`\n   + 从文件中读取单独的一行。换行符为 '\\n'。\n   + f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。\n4. `f.readlines()`\n   + 返回该文件中包含的所有行。\n   + 如果设置可选参数 sizeint, 则读取指定长度的字节, 并且将这些字节按行分割。\n5. `f.write()`\n   + f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。\n   + 写入其他类型之前要使用str()转成字符串。\n6. `f.tell()`\n   + 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。\n7. `f.seek()`\n   + 设置文件指针的偏移量。\n   + 改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。\n   + from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。\n8. `f.flush()`\n   + 刷新缓冲区，将缓冲区中的数据立刻写入文件，同时清空缓冲区。不需要是被动的等待输出缓冲区写入。\n   + 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。\n9. `f.close()`\n   + 当处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源。\n   + 如果尝试再调用该文件，则会抛出异常。\n10. **`with`关键字**\n    + 在文件操作结束后, 它会帮我们正确的关闭文件，而不用手动关闭。\n    + `with` 语句用于异常处理，封装了 `try…except…finally` 编码范式，提高了易用性。\n    + 在处理文件对象时使用 `with` 关键字是一种很好的做法。\n    + 参考：[Python with 关键字 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python-with.html)\n\n```python\n# 写入文件\nfilename = 'd:/test.txt'\nf = open(filename,'w')   # 打开文件\nf.write(\"猪猪好棒!\\n猪猪天下第一棒!\\n\")  # 写入内容\nf.close()   #关闭文件\n\n# 读取文件\nf = open(filename,'r')\nstr = f.read()                 # 读取全部内容\nprint(str)\n\nprint(f.tell())                # 返回文件当前所处位置\nf.seek(0,0)                    # 将文件指针指向开头\nprint(f.tell())                # 返回文件当前所处位置\n\nstr = f.readline()             # 读取一行\nprint(str)\n\nf.seek(0,0)\nprint(f.readlines())\n\nf.close()\n\n# with关键字\nwith open(filename,'a+') as f:\n    f.write(\"猪猪好厉害!\\n\")\n    f.seek(0,0)\n    read_data = f.read()\n    print(read_data)\n\n\n```\n\n#### pickle模块\n\n> + Python的pickle模块实现了基本的数据序列和反序列化。\n> + 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。\n> + 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。\n> + 导入pickle模块：`import pickle`\n> + 基本接口：`pickle.dump(obj, file, [,protocol])`\n\n```python\nimport pickle\n\n# 使用pickle模块将数据对象保存到文件\ndata1 = {'a':[1,2,3,4],'b':('hello','world'),'c': None}\ndata2 = 'hello world'\n\nf = open('d:/data.pkl','wb')  # 二进制写入\n\npickle.dump(data1, f)\npickle.dump(data2, f)\nf.close()\n\n# 使用pickle模块从文件中重构python对象\npkl_file = open('d:/data.pkl', 'rb')\n\ndata3 = pickle.load(pkl_file)  # pickle.load(f)读取一行\nprint(data1)\n\ndata4 = pickle.load(pkl_file)\nprint(data2)\n\npkl_file.close()\n```\n\n## Python条件控制&循环语句\n\n### 条件控制\n\n> + <font color=#ff0000>**if, elif, else**</font>\n>\n> + ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202045696.jpeg)\n>\n> + 语句形式\n>\n>   + 每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。\n>   + 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n>\n>   ```python\n>   if condition_1:\n>       statement_block_1\n>   elif condition_2:\n>       statement_block_2\n>   else:\n>       statement_block_3\n>   ```\n>\n> + 不同数值类型的 true 和 false \n>\n> |  类型  |       False       |           True           |\n> | :----: | :---------------: | :----------------------: |\n> |  布尔  |  False(与0等价)   |      True(与1等价)       |\n> |  数值  |      0,  0.0      |        非零的数值        |\n> | 字符串 | '', \"\"(空字符串)  |        非空字符串        |\n> |  容器  | [], (), {}, set() | 至少有一个元素的容器对象 |\n> |  None  |       None        |        非None对象        |\n>\n> + 如果 if 语句中的条件过长，可以用接续符 `\\`来换行。\n\n### 循环语句\n\n> + 循环语句有 **for**和 **while**。\n>\n> + 控制结构图\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202101861.png)\n\n#### while循环\n\n+ 形式\n\n  ```python\n  while 判断条件(condition)：\n      执行语句(statements)……\n  ```\n\n+ 执行流程\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202103123.jpeg)\n\n+ 需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。\n\n+ 可以通过设置条件表达式永远不为 false 来实现无限循环。可以使用 **CTRL+C** 来退出当前的无限循环。无限循环在服务器上客户端的实时请求非常有用。\n\n+ 如果 while 后面的条件语句为 false 时，则执行 else 的语句块。\n\n  ```python\n  while <expr>:\n      <statement(s)>\n  else:\n      <additional_statement(s)>\n  ```\n\n#### for循环\n\n+ for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。\n\n+ 一般形式\n\n  ```python\n  for <variable> in <sequence>:\n      <statements>\n  else:\n      <statements>\n  ```\n\n+ 执行流程\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204202107676.jpeg)\n\n+ break 语句用于跳出当前循环体；continue语句跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n+ range()函数，允许用户在给定范围内生成一系列数字。\n\n  + 语法结构\n\n  ```python\n  # start：表示从返回序列的起始编号，默认情况下从0开始\n  # stop：表示生成最多但不包括此数字的数字\n  # step：指的是序列中每个数字之间的差异，默认值为1\n  range(start, stop, step)  # 左闭右开\n  ```\n\n  ```python\n  for i in range(1, 10, 2):\n      print(i,end = ' ')\n  \n  '''输出\n  1 3 5 7 9\n  '''\n  ```\n\n+ 循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。\n\n+ pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。pass只是为了防止语法错误。\n\n\n## Python函数\n\n> + 函数是组织好的，可重复使用的，**用来实现单一，或相关联功能的代码段。**\n> + 函数能**提高应用的模块性，和代码的重复利用率**。\n> + 除了内置函数，还可以自己创建函数——自定义函数。\n> + 函数定义完成后，可以调用执行。\n\n### 自定义函数\n\n> + 函数代码块以 **def** 关键词开头，后接函数标识符名称和圆括号 **()**。\n>\n>   ```python\n>   def 函数名（参数列表）:\n>       函数体\n>   ```\n>\n> + 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n>\n> + 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。可以通过 `函数名.__doc__` 的方式来显示函数的说明文档\n>\n> + 函数内容以冒号 **:** 起始，并且缩进。\n>\n> + **return [表达式]** 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。Python 函数可以返回多个值，多个值以元组的方式返回\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204211408876.png)\n\n### 函数参数\n\n#### 参数传递\n\n> + 在 Python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的。\n> + 在 Python 中，strings, tuples, 和 numbers 是不可更改（**immutable**）的对象，而 list,dict 等则是可以修改（**mutable**）的对象。\n>   + 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。\n>   + 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n> + python 函数的参数传递（Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。）：\n>   + **不可变类型**：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。\n>   + **可变类型**：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。\n\n#### 参数类型\n\n> + 必需参数\n> + 关键字参数\n> + 默认参数\n> + 不定长参数\n\n1. 必需参数\n   + 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n2. 关键字参数\n   + 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n   + 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\n\n3. 默认参数\n   + 调用函数时，如果没有传递参数，则会使用默认参数。\n   + 默认参数必须放在最后面。\n4. 不定长参数\n   + 加了星号 `*` 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。\n   + 加了两个星号 `**` 的参数会以字典的形式导入。\n\n```python\n\ndef func(a, b, isAdd = False):     # 这里的a,b都是必需参数;isAdd为默认参数\n    '定义一个函数,实现加减法,isAdd控制进行加法还是减法,默认为减法'   # 函数体的第一行可以写函数说明\n    if(isAdd == False):\n        return a - b\n    else:\n        return a + b\n\nres1 = func(10, 5)           # 按照函数参数顺序传入必需参数\nres2 = func(b = 10, a = 5)   # 指定参数关键字传入\nres3 = func(a = 10, b = 5, isAdd = True)  # 修改默认参数,实现加法\nprint(res1)\nprint(res2)\nprint(res3)\n\n'''输出\n5\n-5\n15\n'''\n```\n\n```python\nprint('只有一个元组形式的变长参数')\ndef func1(*var_tuples):\n    print(var_tuples)\nfunc1(1,2,3)\n\nprint('一个必需参数和一个元组形式的变长参数')\ndef func2(m, *var_tuples):\n    print(m)\n    print(var_tuples)\nfunc2(1,2,3) \n\n\nprint('只有一个字典形式的变长参数')\ndef func3(**var_dicts):\n    print(var_dicts)\nfunc3(a = 1,b = 2,c = 3)   # 由于是字典形式,不需要传入关键字(也就是key)\n\nprint('一个必需参数和一个字典形式的变长参数')\ndef func4(m, **var_dicts):\n    print(m)\n    print(var_dicts)\nfunc4(1,a = 2,b = 3) \n\n'''输出\n只有一个元组形式的变长参数\n(1, 2, 3)\n一个必需参数和一个元组形式的变长参数\n1\n(2, 3)\n只有一个字典形式的变长参数\n{'a': 1, 'b': 2, 'c': 3}\n一个必需参数和一个字典形式的变长参数\n1\n{'a': 2, 'b': 3}\n'''\n```\n\n### 匿名函数\n\n> + 所谓匿名，意即不再使用 **def** 语句这样标准的形式定义一个函数。\n>\n> + Python 使用 **lambda表达式** 来创建匿名函数。\n>\n> + lambda语法\n>\n>   ```python\n>   lambda [arg1 [,arg2,.....argn]]:expression\n>   ```\n\n```python\nsum = lambda a, b: a + b\n\nsum(3, 5)  // # 8\n```\n\n## Python模块\n\n> + 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。\n>\n> + **import语句**\n>\n>   + 语法\n>\n>   ```python\n>   import module1[, module2[,... moduleN]\n>   ```\n>\n>   + 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n>   + 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。\n>   + 调用的时候：`模块名.函数名`\n>\n> + **from … import 语句**\n>\n>   + 语法\n>\n>   ```python\n>   from modname import name1[, name2[, ... nameN]]\n>   ```\n>\n>   + 从模块中导入一个指定的部分到当前命名空间中。\n>   + 调用的时候直接使用函数名\n>\n> + **from … import * 语句**\n>\n>   + 语法\n>\n>     ```python\n>     from modname import *\n>     ```\n>\n>   + 把一个模块的所有内容全都导入到当前的命名空间。\n>\n>   + 这种声明不推荐。\n\n### __name__属性\n\n> + <font color=#ff0000>`if __name__ == '__main__'`</font>\n> + 一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用`__name__`属性来使该程序块仅在该模块自身运行时执行。\n> + 每个模块都有一个`__name__`属性，当其值是`'__main__'`时，表明该模块自身在运行，否则是被引入。`__name__` 与 `__main__` 底下是双下划线。\n\n### dir() 函数\n\n> + 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:\n>\n>   ```python\n>   >>> import math\n>   >>> dir(math)\n>   ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp']\n>   ```\n>\n> + 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称。\n\n### 包\n\n> + 包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。\n>\n> + 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。\n>\n>   目录只有包含一个叫做 `__init__.py` 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。\n>\n>   最简单的情况，放一个空的 `:file:__init__.py`就可以了。\n\n## Python错误和异常\n\n> + Python 有两种错误很容易辨认：<font color=#ff0000>**语法错误和异常**</font>。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204231549773.webp)\n\n### 语法错误\n\n> + Python 的语法错误或者称之为解析错。\n\n### 异常\n\n> + 即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。\n\n  ```python\n  >>> 10 * (1/0)             # 0 不能作为除数，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in ?\n  ZeroDivisionError: division by zero\n  >>> 4 + spam*3             # spam 未定义，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in ?\n  NameError: name 'spam' is not defined\n  >>> '2' + 2               # int 不能与 str 相加，触发异常\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n  TypeError: can only concatenate str (not \"int\") to str\n  ```\n\n#### assert（断言）\n\n+ **assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。**\n\n+ **断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况**，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。\n\n+ 语法格式：\n\n  ```python\n  assert expression[,args]   # args为可选参数\n  # 等价于\n  if not expression:\n      raise AssertionError[(args)]\n  ```\n\n```python\n>>> assert True     # 条件为 true 正常执行\n>>> assert False    # 条件为 false 触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError\n>>> assert 1==1    # 条件为 true 正常执行\n>>> assert 1==2    # 条件为 false 触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError\n\n>>> assert 1==2, '1 不等于 2'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError: 1 不等于 2\n```\n\n### 异常处理\n\n#### try/except\n\n+ 异常捕捉可以使用 `try/except` 语句。\n+ try 语句按照如下方式工作；\n  - 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。\n  - 如果没有异常发生，忽略 except 子句，try 子句执行后结束。\n  - 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。\n  - 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。\n+ 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。\n+ 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。\n+ 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。\n\n```python\n# 定义函数\ndef temp_convert(var):\n    try:\n        return int(var)\n    except (ValueError) as Argument:\n        print (\"参数没有包含数字\\n\", Argument)\n\n# 调用函数\ntemp_convert(\"xyz\");\n```\n\n#### try/except...else\n\n+ try/except语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。\n\n+ else 子句将在 try 子句没有发生任何异常的时候执行。\n\n  ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204231626296.png)\n  \n+ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。\n\n+ 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。\n\n#### try-finally语句\n\n+ try-finally 语句无论是否发生异常都将执行最后的代码。\n+ ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204240928646.png)\n\n#### 抛出异常\n\n+ Python 使用 raise 语句抛出一个指定的异常。\n\n+ 语法格式：\n\n  ```python\n  raise [Exception[,args[,traceback]]]\n  ```\n\n#### 用户自定义异常\n\n+ 可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。\n\n## Python面向对象\n\n### 简介\n\n+ **类（Class）**：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n+ **方法**：类中定义的函数。\n+ **类变量**：类变量在整个实例化得到对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n+ **数据成员**：类变量或者实例变量用于处理类以及实例对象的相关的数据。\n+ **方法重写**：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法覆盖，也称方法重写。\n+ **局部变量**：定义在方法中的变量，只作用于当前所在函数。\n+ **实例变量**：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用self修饰的变量。实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。\n+ **继承**：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。\n+ **实例化**：创建一个类的实例，类的具体对象。\n+ **对象**：通过类定义的数据结构实例，对象包括两个数据成员（类变量和实例变量）和方法。\n\n### 类\n\n+ **类对象**支持两种操作：属性引用和实例化。\n+ 类属性与方法\n  + 私有属性：`__private_attrs`：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。\n  + 私有方法：`_private_method`：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。\n+ 访问类的属性和方法：`obj.name`。\n+ 类有一个名为 `__init__()` 的特殊方法（**构造方法**），该方法在类实例化时会自动调用。\n+ 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**, 按照惯例它的名称是 self（也可以是其他，但是注意要在第一个）。\n+ **在类的内部，使用 `def` 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 `self`, 且为第一个参数，self 代表的是类的实例。**\n+ 类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。\n+ 除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量。\n+ **Python3 中类的静态方法、普通方法、类方法**\n  + **静态方法**: 用 @staticmethod 装饰的不带 self 参数的方法叫做静态方法，类的静态方法可以没有参数，可以直接使用类名调用。\n  + **普通方法**: 默认有个self参数，且只能被对象调用。\n  + **类方法**: 默认有个 cls 参数，可以被类和对象调用，需要加上 @classmethod 装饰器。\n\n```python\n# 类定义\nclass people:\n    # 以下4个是类变量，一般通过类名调用\n    planet = '地球'          # 定义公有属性\n    __ancestors = '猿'         # 定义私有属性,私有属性在类外部无法直接进行访问\n\n    # 定义构造方法\n    def __init__(self,n,a):\n        # 以下4个是实例变量\n        self.name = n      # 公有实例属性\n        self.__age = a     # 私有实例属性\n    # 定义普通方法，对象调用\n    def speak(self):\n        type = '人类' # 这是一个局部变量\n        print(f\"{self.name}说: 我是{type}，来自{people.planet}；祖先是{people.__ancestors}。我今年{self.__age}岁。\")\n\n    # 静态方法，对象和类调用，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的\n    @staticmethod\n    def introduce_static():\n        print(\"这只是一段静态方法的示例\")\n\n    # 类方法，对象和类调用，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的\n    @classmethod\n    def introduce_class(cls):\n        print(\"这只是一段类方法的示例\", cls)\n        \nperson = people('张三', 20)  # 实例化类\nprint(f\"你可以从获取我的姓名：{person.name}\") # 公有属性可以从外部访问，私有属性不能从外部访问\nperson.speak()              # 调用普通公有方法\npeople.introduce_static()   # 调用静态方法\nperson.introduce_static()   # 调用静态方法\npeople.introduce_class()    # 调用类方法\nperson.introduce_class()    # 调用类方法\n```\n\n### 继承\n\n+ 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。\n+ 继承包括单继承和多继承。\n\n```python\n# 类定义\nclass people:\n    # 以下4个是类变量，一般通过类名调用\n    planet = '地球'          # 定义公有属性\n    __ancestors = '猿'         # 定义私有属性,私有属性在类外部无法直接进行访问\n\n    # 定义构造方法\n    def __init__(self,n,a):\n        # 以下4个是实例变量\n        self.name = n      # 公有实例属性\n        self.__age = a     # 私有实例属性\n    # 定义普通方法\n    def speak(self):\n        type = '人类' # 这是一个局部变量\n        print(f\"{self.name}说: 我是{type}，来自{people.planet}；祖先是{people.__ancestors}。我今年{self.__age}岁。\")\n\n# 单继承\nclass student(people):\n    university = 'SWJTU'\n\n    def __init__(self,n,a,g):\n        # 调用父类的构造方法\n        people.__init__(self,n,a)\n        self.grade = g\n    \n    # 方法重写\n    def speak(self):\n        people.speak(self) # 可以调用父类的方法\n        print(f\"{self.name}说：我就读于{student.university}，今年{self.grade}年级。\")\n\ns = student(\"张三\",20,\"大四\")\ns.speak()\n```\n\n### 运算符重载\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204282112187.png)\n\n## 练习\n\n### 2022.04.19\n\n1. 华氏温度转换为摄氏温度。提示：华氏温度到摄氏温度的转换公式为：$C=(F - 32) \\div 1.8$。\n\n2. 输入圆的半径计算计算周长和面积。\n\n3. 输入年份判断是不是闰年。\n\n   ```python\n   year = input('请输入年份:')\n   \n   year = int(year)\n   \n   if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n       print(f'{year}是闰年')\n   else:\n       print(f'{year}不是闰年')\n   ```\n\n### 2022.04.20\n\n1. [Python3 循环语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-loop.html)最后的练习题。\n\n2. 输入成绩，判断成绩等级。注：成绩范围0-100；[85,100]为优秀，[75,85)为良好，[60,75)为合格，(0,60)为不合格。\n\n   ```python\n   score = input(\"请输入成绩:\")\n   \n   score = int(score)\n   \n   if score < 0 or score > 100:\n       print(\"成绩不符合要求\")\n   elif score >= 85 and score <= 100:\n       print(\"成绩为优秀\")\n   elif score >= 75 and score < 85:\n       print(\"成绩为良好\")\n   elif score >= 60 and score < 75:\n       print(\"成绩为合格\")\n   else:\n       print(\"成绩不合格\")\n   ```\n\n   \n\n3. 实现九九乘法表。\n\n   ```python\n   for j in range(1,10):     \n       for i in range(1,10): \n           if(i <= j):       \n               s = i * j      \n               print(f'{i} * {j} = {s}',end = '\\t')\n       print()\n   ```\n\n4. 将一个整数倒序，如234变为432，不能使用库函数。\n\n### 2022.04.21\n\n1. 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\n\n   ```python\n   str = input(\"请输入字符串:\")\n   \n   print(str)\n   \n   i = 0\n   letter = 0  # 保存中英文字母的个数\n   space = 0\n   digit = 0\n   others = 0\n   \n   for temp in str:\n       if(temp.isalpha()):\n           letter += 1\n       elif(temp.isspace()):\n           space += 1\n       elif(temp.isdigit()):\n           digit += 1\n       else:\n           others += 1\n   else:\n       print(f\"中英文字母的个数:{letter}\\n空格个数:{space}\\n数字个数:{digit}\\n其它字符个数:{others}\")\n   ```\n\n   ```python\n   str = input(\"请输入字符串:\")\n   \n   print(str)\n   i = 0\n   letter = 0  # 保存中英文字母的个数\n   space = 0\n   digit = 0\n   others = 0\n   while(i < len(str)):\n       temp = str[i]\n       if(temp.isalpha()):\n           letter += 1\n       elif(temp.isspace()):\n           space += 1\n       elif(temp.isdigit()):\n           digit += 1\n       else:\n           others += 1\n       i += 1\n   else:\n       print(f\"中英文字母的个数:{letter}\\n空格个数:{space}\\n数字个数:{digit}\\n其它字符个数:{others}\")\n   ```\n\n   \n\n2. 给定一个数字列表，对其进行升序排序（冒泡排序）。\n\n### 2022.04.22\n\n1. 1到4能组成多少个互不相同且不重复数字的三位数？分别是？\n\n   ```python\n   for i in range(1,5):  #1\n       for j in range(1,5):   \n           for n in range(1,5):\n               if i != j and i != n and j != n:\n                   num = i*100 + j * 10 + n\n                   print(num)\n   ```\n\n2. 整数的阶乘（英语：factorial）是所有小于及等于该数的正整数的积，0的阶乘为1。即：n!=1×2×3×...×n。\n\n   ```python\n   n = input(\"请输入一个整数:\")\n   n = int(n)\n   num = 1\n   if n < 0:\n       print(\"n不能为负数\")\n   elif n == 0:\n       print(f'{n}的阶乘为{num}')\n   else:\n       for i in range(1,n+1): \n           num = i * num\n       print(f'{n}的阶乘为{num}')\n   ```\n\n## Reference\n\n1. [Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n","tags":["Python","Jupter NoteBook","Anaconda"],"categories":["学习笔记"]},{"title":"Python学习笔记(1)--基础语法","url":"/hexo-blogs/2022/08/19/Python学习笔记(1)--基础语法/","content":"\n# Python学习笔记(1)——基础语法\n\n<!--start: 2022.04.17-->\n\n> 这里为Python3。笔记基于：[Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n## Python简介\n\n> + Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\n> + 目前为Python 的 3.0 版本，常被称为 Python 3000，或简称 Py3k。\n> + 跨平台。\n> + 解释性语言——无需编译。\n> + 交互式语言——直接在提示符>>>后执行代码。交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。\n> + 面向对象语言——一切皆可对象。\n\n## Python特点\n\n> + 简单易学。\n> + 免费开源。\n> + 一个广泛的标准库。\n> + 可移植。\n> + 可扩展。\n> + 可嵌入。\n> + GUI编程。\n\n## Python环境搭建\n\n> + 基于Windows系统\n\n### Anaconda安装\n\n> + Anaconda，中文大蟒蛇，是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。\n> + 官网：[Installing on Windows — Anaconda documentation](https://docs.anaconda.com/anaconda/install/windows/)。\n> + 参考\n>   + [Anaconda介绍、安装及使用教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32925500)\n>   + [基于Anaconda配置Python开发环境详解（1）anaconda配置python环境](https://blog.csdn.net/u013598963/article/details/120191604)\n>   + [基于Anaconda配置Python开发环境详解（2）conda基本命令](https://blog.csdn.net/u013598963/article/details/120240628)\n\n1. 下载安装包，图形化安装。\n\n2. 打开“Anaconda Prompt”。\n\n3. 切换conda源为国内镜像。\n\n   ```shell\n   conda config --get channels #查看conda当前源\n   ```\n\n   ```shell\n   # 切换为清华镜像，依次输入以下命令\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/\n   conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n   conda config --set show_channel_urls yes\n   ```\n\n4. 虚拟环境命令\n\n   > 安装/卸载包要切换到对应的虚拟环境下进行。\n\n   ```shell\n   # 创建虚拟环境python3，并安装python（不指定版本则安装最新版本）\n   conda create -n python3 python\n   # 激活名为python3的虚拟环境\n   conda activate python3\n   \n   # 其他命令\n   conda env list                    # 查看虚拟环境列表\n   \n   conda deactivate                  # 退出当前虚拟环境\n   conda remove -n python3 --all     # 删除虚拟环境python3\n   conda create -n python3_1 --clone python3 # 克隆虚拟环境python3到虚拟环境python3_1\n   conda list                        # 列举当前虚拟环境下安装的包\n   conda -h                          # 获取帮助\n   \n   conda install package_name        # 安装指定包\n   pip install package_name          # 当使用 conda install 无法进行安装时，可以使用pip进行安装。\n   \n   conda update package_name         # 更新指定包\n   conda update --all                # 更新全部包\n   \n   conda uninstall package_name      # 卸载指定包\n   conda remove package_name         # 也可以使用这个命令卸载\n   \n   conda search --full-name python   # 查找全名为“python”的包有哪些版本可供安装\n   ```\n\n### VS Code安装\n\n> + VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器，VSCode 开发环境非常简单易用。\n> + 官网：[Visual Studio Code - Code Editing. Redefined](https://code.visualstudio.com/)\n> + 下载软件包，一步步安装即可，安装过程注意安装路径设置、环境变量默认自动添加到系统中。参考：[VScode 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/vscode-tutorial.html)\n\n### VS Code使用\n\n1. 建立工作目录\n\n   > 1. 新建一个空文件夹VSCode_workspace，作为专门存放vscode代码文件的文件夹。\n   > 2. 在该文件夹下继续新建空文件夹Python，作为python编程的专用工作文件夹。\n   > 3. 打开VS Code，打开该文件夹。\n\n2. 安装插件“Python”（会自动安装Jupter、Pylance）。\n2. 安装ipykernel，使用**jupyter notebook**。jupyter notebook是一款开源的、在canvas上运行的python代码和展示markdown的项目。参考：[vscode写jupyter notebook - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/378378346)\n2. 在ipynb文件中编写代码。\n\n## Python基础语法\n\n+ **编码**\n\n  默认情况下，Python 3 源码文件以 **UTF-8** 编码，所有字符串都是 unicode 字符串。 \n\n+ **标识符**\n\n  + 首字母必须为**字母**或**下划线`_`**。\n  + 组成：字母、下划线、数字。\n  + 大小写敏感。\n  + Python3中，可以使用**中文**作为变量名，非 ASCII 标识符也是允许的了。\n\n+ **Python保留字**\n\n  + 保留字即关键字，我们不能把它们用作任何标识符名称。\n\n  + Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字。\n\n    ```python\n    import keyword\n    keyword.kwlist\n    ```\n\n+ **注释**\n\n  + 单行注释以`#`开头。\n\n  + 多行注释使用`'''`或`\"\"\"`。\n\n    ```python\n    # 单行注释\n    \n    '''\n    多行注释\n    '''\n    \n    \"\"\"\n    多行注释\n    \"\"\"\n    print (\"Hello, Python!\")\n    ```\n\n+ **行与缩进**\n\n  + Python使用缩进来表示代码块，而不需要像C/C++/Java那样使用大括号 **{}** 。\n\n  + 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。\n\n    ```python\n    if True:\n        print (\"Answer\")\n        print (\"True\")\n    else:\n        print (\"Answer\")\n      print (\"False\")    # 缩进不一致，会导致运行错误\n    ```\n\n+ **数字类型**\n\n  + **int**：整数。只有一种整数类型 int，表示为长整型\n  + **bool**：布尔型\n  + **float**：浮点数\n  + **complex**：复数\n\n+ **字符串**\n\n  + Python 中单引号 `'` 和双引号 `\"` 使用完全相同。\n  + 使用三引号(`'''` 或 `\"\"\"`)可以指定一个多行字符串。\n  + 转义符`\\`。\n  + 反斜杠可以用来转义，使用 `r` 可以让反斜杠不发生转义。 如 `r\"this is a line with \\n\"` 则 `\\n` 会显示，并不是换行。这里的 r 指 raw，即 raw string，会自动将反斜杠转义。\n  + 按字面意义级联字符串，如 `\"this \" \"is \" \"string\"`会被自动转换为 `this is string`。\n  + 字符串可以用 `+` 运算符连接在一起，用 `*` 运算符重复。\n  + Python 中的字符串有两种索引方式，从左往右以 `0` 开始，从右往左以 `-1` 开始。\n  + Python 中的字符串不能改变。\n  + Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n  + 字符串的截取的语法格式如下：**变量[头下标:尾下标:步长]**。\n\n  ```python\n  msg1=\"this \" \"is \" \"string\"\n  print(msg1)\n  \n  msg2=\"你\"+\"真\"+\"漂亮!\"\n  print(msg2)\n  print(msg2 * 3)\n  \n  msg3='123456789'\n  print(msg3)\n  print(msg3[0])\n  print(msg3[8:])\n  print(msg3[-1])\n  print(msg3[0:-1])\n  print(msg3[1:5:2])\n  \n  print('hello\\nPython')      # 使用反斜杠(\\)+n转义特殊字符\n  print(r'hello\\nPython')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n  \n  '''输出\n  this is string\n  你真漂亮!\n  你真漂亮!你真漂亮!你真漂亮!\n  123456789\n  1\n  9\n  9\n  12345678\n  24\n  hello\n  Python\n  hello\\nPython\n  '''\n  ```\n\n+ **空行**\n\n  + 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。\n  + 类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n  + 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n+ **同一行显示多条语句**\n\n  + Python 可以在同一行中使用多条语句，语句之间使用分号 `;` 分割。\n\n+ **多个语句构成代码组**\n\n  + 缩进相同的一组语句构成一个代码块，我们称之代码组。\n  + 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。\n  + 将首行及后面的代码组称为一个子句(clause)。\n\n+ **print输出**\n\n  + `print` 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=\"\"`\n\n    ```python\n    print(\"hello\",end=\"\")\n    print(\" world\")\n    print('hello Python')\n    ```\n\n+ **import 与 from...import**\n\n  + 在 Python 用 `import` 或者 `from...import` 来导入相应的模块。\n  + 将整个模块(somemodule)导入，格式为： `import somemodule`。\n  + 从某个模块中导入某个函数,格式为： `from somemodule import somefunction`。\n  + 从某个模块中导入多个函数,格式为： `from somemodule import firstfunc, secondfunc, thirdfunc`。\n  + 将某个模块中的全部函数导入，格式为： `from somemodule import *`。\n\n+ **变量与对象**\n\n  + 赋值操作，本质是创建引用。\n  + 变量是变量，对象是对象，当将某个对象赋值给某个变量时，可以认为是创建了变量对该对象的引用。\n  + 变量没有数据类型之说，只有对象有，即变量不是直接代表对象或对象占用的内存空间。\n  + Python中，变量无需提前声明，无需指定其数据类型，其表现完全是动态的，其所为的数据类型决定于当前该变量所引用的对象的数据类型。\n  + 所谓变量对对象的引用，本质是创建了变量指向对象内存空间的指针。\n  + 对象内存空间，一般最起码有类型和当前被引用次数这两个信息，类型记录了该对象的数据类型，被引用次数记录了该对象内存空间被变量引用的次数。\n  + 当某对象的被引用次数为0时，Python便会自动回收该对象内存空间。\n\n+ **命令行参数**\n\n  参考：[Python3 命令行参数 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-command-line-arguments.html)\n\n## Python数据类型\n\n> + Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n>\n> + 等号（=）用来给变量赋值。\n>\n> + 等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。\n>\n> + 多个变量赋值。\n>\n>   ```python\n>   a = b = c = 1\n>   \n>   a,b,c = 1,2,\"hello\"\n>   ```\n>\n> + Python3 的六个标准数据类型中：\n>\n>   - **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；\n>   - **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。\n\n### 标准数据类型\n\n#### Number（数字）\n\n> + Python3 支持 **int、float、bool、complex（复数）**。\n>\n> + 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n>\n> + 内置的 type() 函数可以用来查询变量所指的对象类型。\n>\n> + Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False\\==0会返回 True，但可以通过`is`来判断类型。\n>\n> + Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。\n>\n> + 可以通过`del`语句删除单个或多个对象。\n>\n>   ```python\n>   a,b = 10,20\n>   del a,b\n>   ```\n>\n> + 数值运算\n>\n>   ```python\n>   >>> 5 + 4  # 加法\n>   9\n>   >>> 4.3 - 2 # 减法\n>   2.3\n>   >>> 3 * 7  # 乘法\n>   21\n>   >>> 2 / 4  # 除法，得到一个浮点数\n>   0.5\n>   >>> 2 // 4 # 除法，得到一个整数\n>   0\n>   >>> 17 % 3 # 取余\n>   2\n>   >>> 2 ** 5 # 乘方\n>   32\n>   ```\n>\n> + Python可以同时为多个变量赋值，如a, b = 1, 2。\n>\n> + 一个变量可以通过赋值指向不同类型的对象。\n>\n> + **数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。**\n>\n> + 在混合计算时，Python会把整型转换成为浮点数。\n>\n> + Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\n#### String（字符串）\n\n> + Python中的字符串用单引号 **'** 或双引号 **\"** 括起来，同时使用反斜杠 `\\`转义特殊字符。\n>\n> + 索引值以 0 为开始值，-1 为从末尾的开始位置。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204171912742.png)\n>\n> + 加号 **+** 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。\n>\n> + 使用反斜杠` \\` 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 `r`，表示原始字符串。\n>\n> + 另外，反斜杠(\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 **\"\"\"...\"\"\"** 或者 **'''...'''** 跨越多行。\n>\n> + 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。\n>\n> + **与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。**\n\n#### List（列表）\n\n> + List（列表） 是 Python 中使用最频繁的数据类型。\n>\n> + 列表中元素的类型可以不相同，它支持**数字，字符串甚至可以包含列表**（所谓嵌套）。\n>\n> + 和字符串一样，列表同样可以被索引和截取（切片），列表被截取后返回一个包含所需元素的新列表。\n>\n> + **列表是写在方括号 [] 之间、用逗号分隔开的元素列表**。\n>\n> + 加号 **+** 是列表连接运算符，星号 ***** 是重复操作。\n>\n> + **与Python字符串不一样的是，列表中的元素是可以改变的。**\n>\n> + 切片。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204171931206.png)\n\n```python\nlist = ['Hello', 520, 3.14, 'Python']\nprint(list)\nprint(list[0])\nprint(list[0:4])\nprint(list * 2)\n\nlist[1:3] = [521,3.14159]\nprint(list[1:3])\n```\n\n#### Tuple（元组）\n\n> + 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。\n>\n> + 元组写在小括号 **()** 里，元素之间用逗号隔开。\n>\n> + 元组也可以被索引和切片，方法一样。\n>\n> + 注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n>\n>   ```python\n>   tup1 = ()    # 空元组\n>   tup2 = (20,) # 一个元素，需要在元素后添加逗号\n>   ```\n\n```python\ntup = (1,2,3,'Jerry')\nprint(tup)\n\ntup1 = ()    # 空元组\ntup2 = (20,) # 一个元素，需要在元素后添加逗号\nprint(tup2[0])\n```\n\n#### Set（集合）\n\n> + 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n> + 基本功能是进行成员关系测试和删除重复元素。\n> + 可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。\n\n```python\nsites = {'Google', 'Taobao', 'Google', 'Facebook', 'Zhihu', 'Baidu'}\n\nprint(sites)   # 输出集合，重复的元素被自动去掉\n\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)\nprint(b)\n\nprint(a - b)     # a 和 b 的差集\n\nprint(a | b)     # a 和 b 的并集\n\nprint(a & b)     # a 和 b 的交集\n\nprint(a ^ b)     # a 和 b 中不同时存在的元素\n\n'''输出\n{'Google', 'Facebook', 'Taobao', 'Baidu', 'Zhihu'}\n{'b', 'r', 'c', 'a', 'd'}\n{'l', 'c', 'm', 'z', 'a'}\n{'b', 'r', 'd'}\n{'l', 'b', 'r', 'c', 'm', 'z', 'a', 'd'}\n{'c', 'a'}\n{'m', 'l', 'b', 'r', 'z', 'd'}\n'''\n```\n\n\n\n#### Dictionary（字典）\n\n> + 列表是有序的对象集合，字典是无序的对象集合。\n> + 字典当中的元素是通过键来存取的，而不是通过偏移存取。\n> + **字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。**\n> + **在同一个字典中，键(key)必须是唯一的。**\n> + 键(key)必须使用不可变类型。\n\n```python\ndict1 = {\"name\":\"Jerry\",\"sex\":\"girl\",\"age\":18}            # 方式1\nprint(dict1)           # 输出完整的字典\nprint (dict1.keys())   # 输出所有键\nprint (dict1.values()) # 输出所有值\n\ndict1[\"班级\"] = \"广告一班\"                                 # 方式2\nprint(dict1[\"班级\"])\n\nprint(dict())\n\ndict2 = dict(first = 1, second = 2, third = 3)             # 方式3: 使用关键字参数创建字典\nprint(dict2)\n\ndict3 = dict([('first',1), ('second', 2), ('third', 3)])   # 方式4: 使用可迭代对象创建字典\nprint(dict3)\n\ndict4 = dict({'first':1, 'second':2, 'third':3})           # 方式5: 使用映射来创建字典\nprint(dict4)\n\n\ndict5 = dict(zip(['first','second','third'],[1,2,3]))      # 方式6: zip() 创建可迭代对象\nprint(dict5)\n\n'''输出\n{'name': 'Jerry', 'sex': 'girl', 'age': 18}\ndict_keys(['name', 'sex', 'age'])\ndict_values(['Jerry', 'girl', 18])\n广告一班\n{}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n{'first': 1, 'second': 2, 'third': 3}\n'''\n```\n\n\n\n### 数据类型转换\n\n> + 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下只需要将数据类型作为函数名即可。\n> + Python 数据类型转换可以分为两种：\n>   + 隐式类型转换——自动完成。\n>   + 显示类型转换——需要使用类型函数类转换。\n\n#### 隐式类型转换\n\n较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。\n\n#### 显示类型转换\n\n| 函数       | 描述                                                      |\n| ---------- | --------------------------------------------------------- |\n| `int(x)`   | x转为int型                                                |\n| `float(x)` | x转为float型                                              |\n| `str(x)`   | x转为字符串                                               |\n| `list(s)`  | 将序列 s 转换为一个列表，s为字符串、元组                  |\n| `tuple(s)` | 将序列 s 转换为一个元组，s 可以为字符串、列表、字典、集合 |\n| `set(s)`   | 将序列 s 转换为一个可变集合                               |\n| `dict(d)`  | 创建一个字典。d 必须是一个 (key, value)元组序列。         |\n| `hex(x)`   | 将一个整数转换为一个十六进制字符串                        |\n| `oct(x)`   | 将一个整数转换为一个八进制字符串                          |\n\n## Python推导式\n\n> + Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。\n> + Python 支持各种数据结构的推导式：列表(list)推导式，字典(dict)推导式，集合(set)推导式，元组(tuple)推导式。\n\n### 列表推导式\n\n```python\n[表达式 for 变量 in 列表] \n[out_exp_res for out_exp in input_list]\n\n或者 \n\n[表达式 for 变量 in 列表 if 条件]\n[out_exp_res for out_exp in input_list if condition]\n```\n\n- out_exp_res：列表生成元素表达式，可以是有返回值的函数。\n- for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。\n- if condition：条件语句，可以过滤列表中不符合条件的值。\n\n```python\n# 计算 50 以内可以被 4 整除的整数：\nmultiples = [i for i in range(50) if i % 4 == 0]\nprint(multiples)\n\n'''输出\n[0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48]\n'''\n```\n\n### 元组推导式\n\n```python\n(expression for item in Sequence )\n或\n(expression for item in Sequence if conditional )\n```\n\n+ 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n+ 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 **()** 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**。\n+ 元组推导式返回的结果是一个生成器对象。\n\n```python\na = (x for x in range(50) if x % 4 == 0)\nprint(tuple(a))\n\n'''输出\n(0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48)\n'''\n```\n\n### 集合推导式\n\n```python\n{ expression for item in Sequence }\n或\n{ expression for item in Sequence if conditional }\n```\n\n```python\nset1 = {i for i in (1,2,3,4,4,5,11,12,13,14) if i < 10}\nprint(set1)\n\n'''输出\n{1, 2, 3, 4, 5}\n'''\n```\n\n### 字典推导式\n\n```python\n{ key_expr: value_expr for value in collection }\n\n或\n\n{ key_expr: value_expr for value in collection if condition }\n```\n\n```python\nlistdemo = ['Google','Baidu', 'Taobao']\n# 将列表中各字符串值为键，各字符串的长度为值，组成键值对\nnewdict = {key:len(key) for key in listdemo}\nprint(newdict)\n\n'''输出\n{'Google': 6, 'Baidu': 5, 'Taobao': 6}\n'''\n```\n\n<!--end: 2022.04.17-->\n\n<!--start: 2022.04.18-->\n\n## Python解释器\n\n> + 暂不讨论。参考：[Python3 解释器 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-interpreter.html)\n\n## Python运算符\n\n+ Python中没有自增/自减运算符。\n\n### 算术运算符\n\n| 运算符 | 描述             |\n| ------ | ---------------- |\n| `+`    | 加法             |\n| `-`    | 减法             |\n| `*`    | 乘法             |\n| `/`    | 除法             |\n| `%`    | 取模             |\n| `**`   | 幂               |\n| `//`   | 取整除，向下取整 |\n\n+ **//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n\n  ```python\n  >>> 7//2\n  3\n  >>> 7.0//2\n  3.0\n  >>> 7//2.0\n  3.0\n  ```\n\n### 比较运算符\n\n+ Pyhton3 已不支持 <> 运算符，可以使用 != 代替。\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `==`   | 等于     |\n| `!=`   | 不等于   |\n| `<`    | 小于     |\n| `>`    | 大于     |\n| `<=`   | 小于等于 |\n| `>=`   | 大于等于 |\n\n### 赋值运算符\n\n| 运算符 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| `=`    | 普通赋值运算符                                               |\n| `+=`   | 加法赋值                                                     |\n| `-=`   | 减法赋值                                                     |\n| `*=`   | 乘法赋值                                                     |\n| `/=`   | 除法赋值                                                     |\n| `%=`   | 取模赋值                                                     |\n| `**=`  | 幂赋值                                                       |\n| `//=`  | 取整除赋值                                                   |\n| `:=`   | 海象运算符，可在表达式内部为变量赋值。**Python3.8 版本新增运算符**。 |\n\n### 位运算符\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `&`    | 按位与   |\n| \\|     | 按位或   |\n| `^`    | 按位异或 |\n| `~`    | 按位取反 |\n| `<<`   | 左移     |\n| `>>`   | 右移     |\n\n### 逻辑运算符\n\n| 运算符 | 描述     |\n| ------ | -------- |\n| `and`  | 布尔“与” |\n| `or`   | 布尔“或” |\n| `not`  | 布尔“非” |\n\n+ Python 中的 and 从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值；\n+ or 也是从左到有计算表达式，返回第一个为真的值；\n+ **其中数字 0 是假，其他都是真；字符 \"\" 是假，其他都是真。**\n\n### 成员运算符\n\n| 运算符   | 描述                                                    |\n| -------- | ------------------------------------------------------- |\n| `in`     | 如果在指定的序列中找到值返回 True，否则返回 False。     |\n| `not in` | 如果在指定的序列中没有找到值返回 True，否则返回 False。 |\n\n### 身份运算符\n\n+ 身份运算符用于比较两个对象的存储单元。\n\n+ `is` 与 `==` 区别：`is` 用于判断两个变量引用对象是否为同一个， `==` 用于判断引用变量的值是否相等。\n\n+ **设`a=5;b=5`。在交互式环境中，解释器会有一个<font color=#ff0000>小整数池</font>的概念，会把[-5，256]间的数预先创建好，而当a和b超过这个范围的时候，两个变量就会指向不同的对象了。**\n\n  ```python\n  >>> a=5\n  >>> b=5\n  >>> id(a);id(b)\n  2890240977328\n  2890240977328\n  >>> a=1000\n  >>> b=1000\n  >>> id(a);id(b)\n  2890278823312\n  2890278824144\n  ```\n\n+ 在一些发行版的Python IDE中，例如Pycharm、Anaconda等，会维护一个<font color=#ff0000>大整数池</font>，它的范围比原生的解释器会大很多，这是一种优化机制。\n\n| 运算符   | 描述                                        |\n| -------- | ------------------------------------------- |\n| `is`     | is 是判断两个标识符是不是引用自一个对象     |\n| `is not` | is not 是判断两个标识符是不是引用自不同对象 |\n\n### 运算符优先级\n\n| 运算符                   | 描述                                                   |\n| :----------------------- | :----------------------------------------------------- |\n| **                       | 指数 (最高优先级)                                      |\n| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |\n| * / % //                 | 乘，除，求余数和取整除                                 |\n| + -                      | 加法减法                                               |\n| >> <<                    | 右移，左移运算符                                       |\n| &                        | 位 'AND'                                               |\n| ^ \\|                     | 位运算符                                               |\n| <= < > >=                | 比较运算符                                             |\n| == !=                    | 等于运算符                                             |\n| = %= /= //= -= += *= **= | 赋值运算符                                             |\n| is is not                | 身份运算符                                             |\n| in not in                | 成员运算符                                             |\n| not and or               | 逻辑运算符                                             |\n\n## Python数字类型\n\n> + Python 数字数据类型用于存储数值。\n>\n> + 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。\n>\n> + 可以使用del语句删除一些数字对象的引用。\n>\n> + Python 支持三种不同的数值类型：\n>\n>   + **整型(int)** - 通常被称为是整型或整数，是正或负整数，不带小数点。布尔(bool)是整型的子类型。\n>\n>   + **浮点型(float)** - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）\n>\n>   + **复数( (complex))** - 复数由实数部分和虚数部分构成，可以用a + bj，或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n>\n>   + 可以使用二进制，八进制，十六进制来代表整数。\n>\n>     ```python\n>     >>> 0b1111\n>     15\n>     >>> 0o17\n>     15\n>     >>> oxf   # 使用十六进制表示时，字母要大些\n>     Traceback (most recent call last):\n>       File \"<stdin>\", line 1, in <module>\n>     NameError: name 'oxf' is not defined\n>     >>> 0xF\n>     15\n>     ```\n>\n> + 类型转换\n>\n>   - **int(x)** 将x转换为一个整数。\n>   - **float(x)** 将x转换到一个浮点数。\n>   - **complex(x)** 将x转换到一个复数，实数部分为 x，虚数部分为 0。\n>   - **complex(x, y)** 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n>\n> + 数值运算\n>\n>   + 在交互模式中，最后被输出的表达式结果被赋值给变量` _` ，该变量为只读变量（这里是”应当“，也就是没有必要最好不要改，际情况是你也可以对**_** 赋值，**_=10** 是没有毛病的，但这样的结果会导致你在之后调用 **_** 的时候全部变成了10，除非你 **del _**。）。\n>\n>     ```python\n>     >>> a=100.5\n>     >>> a\n>     100.5\n>     >>> a+_   # 变量 _ 的值为上次输出的100.5\n>     201.0\n>     >>> _ * 2 # 变量 _ 的值为上次输出的201.0\n>     402.0\n>     ```\n\n### 数学常量\n\n| 常量 | 描述                                  |\n| :--- | :------------------------------------ |\n| pi   | 数学常量 pi（圆周率，一般以π来表示）  |\n| e    | 数学常量 e，e即自然常数（自然常数）。 |\n\n+ 需要导入math模块。\n\n```python\n>>> import math\n>>> math.pi\n3.141592653589793\n>>> math.e\n2.718281828459045\n```\n\n### 数学函数\n\n+ <font color=#ff0000>**除非对精确度没什么要求，否则尽量避开用round()函数。**</font>\n+ round()函数使用的事实上不是简单的四舍五入。而是**“4舍6入5看齐,奇进偶不进”**。\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [abs(x)](https://www.runoob.com/python3/python3-func-number-abs.html) | 内置函数，返回x的绝对值，对数字类型都有效                    |\n| [math.ceil(x)](https://www.runoob.com/python3/python3-func-number-ceil.html) | math模块中的函数，向上取整                                   |\n| [math.exp(x)](https://www.runoob.com/python3/python3-func-number-exp.html) | 返回e的x次幂($e^x$)                                          |\n| [math.fabs(x)](https://www.runoob.com/python3/python3-func-number-fabs.html) | 返回x的绝对值，在math模块中定义，只对浮点型跟整型数值有效    |\n| [math.floor(x)](https://www.runoob.com/python3/python3-func-number-floor.html) | 向下取整，如math.floor(4.9)返回 4                            |\n| [math.log(x)](https://www.runoob.com/python3/python3-func-number-log.html) | 返回以e为底的x的对数，如math.log(math.e)返回1.0              |\n| [math.log10(x)](https://www.runoob.com/python3/python3-func-number-log10.html) | 返回以10为基数的x的对数，如math.log10(100)返回 2.0           |\n| [max(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-max.html) | 返回给定参数的最大值，参数可以为序列。                       |\n| [min(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-min.html) | 返回给定参数的最小值，参数可以为序列。                       |\n| [math.modf(x)](https://www.runoob.com/python3/python3-func-number-modf.html) | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |\n| [math.pow(x, y)](https://www.runoob.com/python3/python3-func-number-pow.html) | x**y 运算后的值。                                            |\n| [round(x [,n])](https://www.runoob.com/python3/python3-func-number-round.html) | 返回浮点数 x 的“4舍6入5看齐,奇进偶不进”值，如给出 n 值，则代表舍入到小数点后的位数。**其实准确的说是保留值将保留到离上一位更近的一端。** |\n| [math.sqrt(x)](https://www.runoob.com/python3/python3-func-number-sqrt.html) | 返回数字x的平方根。                                          |\n\n```python\n# math.modf(x)返回的是一个小数部分和整数部分组成的元组\n>>> import math\n>>> math.modf(100.12)\n(0.12000000000000455, 100.0)\n\n# 按我们的想法返回结果应该是 2.68，可结果却是 2.67\n# 这跟浮点数的精度有关。在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。\n# 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。\n# 那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。\n# 因此除非对精确度没什么要求，否则尽量避开用round()函数。\n>>> round(2.675,2)   \n2.67\n```\n\n### 随机数函数\n\n+ 需要导入random模块`import random`\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [random.choice(seq)](https://www.runoob.com/python3/python3-func-number-choice.html) | 从序列的元素中随机挑选一个元素，seq可以是一个列表，元组或字符串 |\n| [random.randrange ([start,\\] stop [,step])](https://www.runoob.com/python3/python3-func-number-randrange.html) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |\n| [random.random()](https://www.runoob.com/python3/python3-func-number-random.html) | 随机生成一个实数，它在[0,1)范围内。                          |\n| [random.seed([x])](https://www.runoob.com/python3/python3-func-number-seed.html) | 改变随机数生成器的种子seed。                                 |\n| [random.shuffle(lst)](https://www.runoob.com/python3/python3-func-number-shuffle.html) | 将序列的所有元素随机排序(打乱)                               |\n| [random.uniform(x, y)](https://www.runoob.com/python3/python3-func-number-uniform.html) | 随机生成一个实数，它在[x,y]范围内。                          |\n\n```python\n>>> import random\n>>> random.random()*10\n3.8944816055307485\n>>> random.choice(range(100))\n9\n>>> random.choice(range(100))\n67\n>>> random.uniform(1,50)\n31.493576711508624\n```\n\n### 三角函数\n\n+ 需要导入math模块`import math`。\n\n| 函数                                                         | 描述                                                       |\n| :----------------------------------------------------------- | :--------------------------------------------------------- |\n| [acos(x)](https://www.runoob.com/python3/python3-func-number-acos.html) | 返回x的反余弦弧度值。x是[-1,1]之间的数值，超出范围会出错。 |\n| [asin(x)](https://www.runoob.com/python3/python3-func-number-asin.html) | 返回x的反正弦弧度值。x是[-1,1]之间的数值，超出范围会出错。 |\n| [atan(x)](https://www.runoob.com/python3/python3-func-number-atan.html) | 返回x的反正切弧度值。                                      |\n| [atan2(y, x)](https://www.runoob.com/python3/python3-func-number-atan2.html) | 返回给定的 X 及 Y 坐标值的反正切值。                       |\n| **[cos(x)](https://www.runoob.com/python3/python3-func-number-cos.html)** | **返回x的弧度的余弦值。**                                  |\n| [hypot(x, y)](https://www.runoob.com/python3/python3-func-number-hypot.html) | 返回欧几里德范数 sqrt(x*x + y*y)。                         |\n| **[sin(x)](https://www.runoob.com/python3/python3-func-number-sin.html)** | **返回的x弧度的正弦值。**                                  |\n| **[tan(x)](https://www.runoob.com/python3/python3-func-number-tan.html)** | **返回x弧度的正切值。**                                    |\n| **[degrees(x)](https://www.runoob.com/python3/python3-func-number-degrees.html)** | **将弧度转换为角度，如degrees(math.pi/2) ， 返回90.0**     |\n| **[radians(x)](https://www.runoob.com/python3/python3-func-number-radians.html)** | **将角度转换为弧度**                                       |\n\n## Python字符串\n\n+ 在Python3中，所有的字符串都是Unicode字符串。\n\n### 转义字符\n\n+ 在需要在字符中使用特殊字符时，python 用反斜杠 `\\` 转义字符。\n\n| 转义字符      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| `\\`(在行尾时) | 续行符                                                       |\n| `\\\\`          | 反斜杠符号                                                   |\n| `\\'`          | 单引号                                                       |\n| `\\\"`          | 双引号                                                       |\n| `\\a`          | 响铃                                                         |\n| `\\b`          | 退格(Backspace)                                              |\n| `\\000`        | 空                                                           |\n| **`\\n`**      | **换行**                                                     |\n| `\\v`          | 纵向制表符                                                   |\n| `\\t`          | 横向制表符                                                   |\n| `\\r`          | 回车，将 **\\r** 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 **\\r** 后面的内容完全替换完成。 |\n| `\\f`          | 换页                                                         |\n| `\\yyy`        | 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。           |\n| `\\xyy`        | 十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行    |\n| `\\other`      | 其它的字符以普通格式输出                                     |\n\n```python\n>>> print('\\a')\n\n>>> print('\\'')\n'\n>>> print('hello \\n world')\nhello\n world\n>>> print('hello \\t world')\nhello    world\n>>> print('hello world\\r world')\n worldworld\n```\n\n### 字符串运算符\n\n| 操作符 | 描述                                                         |\n| :----- | :----------------------------------------------------------- |\n| +      | 字符串连接                                                   |\n| *      | 重复输出字符串                                               |\n| []     | 通过索引获取字符串中字符                                     |\n| [ : ]  | 截取字符串中的一部分，遵循**左闭右开**原则，str[0:2] 是不包含第 3 个字符的。 |\n| in     | 成员运算符 - 如果字符串中包含给定的字符返回 True             |\n| not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True           |\n| r/R    | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 **r**（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 |\n| %      | 格式字符串，同C 语言一样的语法                               |\n\n### 字符串格式化\n\n| 符  号 | 描述                                 |\n| :----- | :----------------------------------- |\n| %c     | 格式化字符及其ASCII码                |\n| %s     | 格式化字符串                         |\n| %d     | 格式化整数                           |\n| %u     | 格式化无符号整型                     |\n| %o     | 格式化无符号八进制数                 |\n| %x     | 格式化无符号十六进制数               |\n| %X     | 格式化无符号十六进制数（大写）       |\n| %f     | 格式化浮点数字，可指定小数点后的精度 |\n| %e     | 用科学计数法格式化浮点数             |\n| %E     | 作用同%e，用科学计数法格式化浮点数   |\n| %g     | %f和%e的简写                         |\n| %G     | %f 和 %E 的简写                      |\n| %p     | 用十六进制数格式化变量的地址         |\n\n+ Python3.6之后新增了<font color=#ff0000>**f-string**</font>，称为**字面量格式化字符串**，是新的格式化字符串的语法。\n\n  + **f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。**\n  + 用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。\n\n  ```python\n  >>> name = 'jerry'\n  >>> print('hello %s'%name)  # %格式化\n  hello jerry\n  >>> print(f'hello {name}')  # f格式化\n  hello jerry\n  >>> print(f'{1+5}')\n  6\n  ```\n\n### 三引号\n\n+ 允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。\n\n### 字符串内建函数\n\n1. `capitalize()`：将字符串的第一个字母变成大写，其他字母变小写。\n   + 首字符会转换成大写，其余字符会转换成小写。\n   + 首字符如果是非字母，首字母不会转换成大写，会转换成小写。\n\n```python\n>>> str = 'hello World'\n>>> print(str)\nhello World\n>>> print(str.capitalize())\nHello world\n```\n\n2. `center(width,fillchar)`：返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。\n   + **如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充。**\n   + **fillchar 只能是单个字符**。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.center(4))   # width 小于字符串宽度,直接返回\nsouthwest jiaotong university\n>>> print(str.center(40))  # fillchar 默认是空格\n     southwest jiaotong university\n>>> print(str.center(40,'*'))\n*****southwest jiaotong university******\n```\n\n3. `count(sub,start=0,end=len(str))`：返回 sub在 str 里面出现的次数，如果 start 或者 end 指定则返回指定范围内 sub 出现的次数。\n   + sub -- 搜索的子字符串。\n   + start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。\n   + end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.count('o'))\n3\n>>> print(str.count('o',0,10))\n1\n>>> print(str.count('ou'))\n1\n```\n\n2. `endswith(suffix,beg=0,end=len(str))`：检查字符串是否以 suffix结束，如果beg 或者 end 指定则检查指定的范围内是否以 suffix结束，如果是，返回 True,否则返回 False。\n   + suffix -- 该参数可以是一个字符串或者是一个元素。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.endswith('!'))\nFalse\n>>> print(str.endswith('y'))\nTrue\n```\n\n3. `find(sub,beg=0,end=len(str))`：检测 sub是否包含在字符串str中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.find('sou'))\n0\n>>> print(str.find('un'))\n19\n>>> print(str.find('uo'))\n-1\n>>> print(str.find('u'))\n2\n>>> print(str.rfind('u'))  # rfind() 从右边开始查找\n19\n```\n\n4. `index(sub,beg=0,end=len(str))`：跟find()方法一样，只不过如果str不在字符串中会报一个异常。这里同样有`rindex()`。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> print(str.index('sou'))\n0\n>>> print(str.index('un'))\n19\n>>> print(str.index('uo'))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: substring not found\n```\n\n5. 判断字符串包含的具体内容\n\n   + `isalnum()`：检测字符串是否由**字母或汉字或数字**组成。如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。\n\n   ```python\n   >>> str1 = 'whoamI'\n   >>> str2 = 'who am I 2022'\n   >>> print(str1.isalnum())\n   True\n   >>> print(str2.isalnum())\n   False\n   >>> str3 = 'whoam我2022'\n   >>> print(str3.isalnum())\n   True\n   ```\n\n   + `isalpha()`：检测字符串是否只由**字母或汉字**组成。如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。\n\n   ```python\n   >>> str1 = '我是谁'\n   >>> str2 = '我是2022'\n   >>> print(str1.isalpha());print(str2.isalpha())\n   True\n   False\n   ```\n\n   + `isdigit()`：检测字符串是否**由数字[0-9]**组成。如果字符串只包含数字则返回 True 否则返回 False。\n\n   + `isdecimal()`：检查字符串是否**只包含十进制字符**。\n\n   + `isnumeric()`：检测字符串是否只由数字字符组成。如果字符串中只包含数字字符，则返回 True，否则返回 False。\n\n     + 数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。\n     + s.isdigit、isdecimal 和 s.isnumeric 区别\n\n     > **isdigit()**\n     >\n     > **True**: Unicode数字，byte数字（单字节），全角数字（双字节）\n     >\n     > **False**: 汉字数字，罗马数字，小数\n     >\n     > **Error**: 无\n     >\n     > **isdecimal()**\n     >\n     > **True**: Unicode数字，，全角数字（双字节）\n     >\n     > **False**: 罗马数字，汉字数字，小数\n     >\n     > **Error**: byte数字（单字节）\n     >\n     > **isnumeric()**\n     >\n     > **True**: Unicode 数字，全角数字（双字节），汉字数字\n     >\n     > **False**: 小数，罗马数字\n     >\n     > **Error**: byte数字（单字节）\n\n   ```python\n   >>> num = '1'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   True\n   True\n   True\n   >>> num = 'IV'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   False\n   False\n   False\n   >>> num = '拾四'\n   >>> print(num.isdigit());print(num.isdecimal());print(num.isnumeric())\n   False\n   False\n   True\n   ```\n\n   + `islower()`：检测字符串**不包含大写字母（至少包含一个小写字母）**。如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。\n\n   ```python\n   >>> str1 = '2022';str2 = '我是dvvf';str3 = 'Hello'\n   >>> print(str1.islower());print(str2.islower());print(str3.islower())\n   False  # 纯数字，返回False\n   True   # 含有字母且不包含大写字母\n   False\n   >>> str4 = '我是';print(str4.islower()) # 不包含字母，返回False\n   False\n   >>> str5 = '2022dc';print(str5.islower())\n   True\n   ```\n\n   + `isupper()`：检测字符串**不包含小写字母（至少包含一个大写字母）**。如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。\n\n   ```python\n   >>> str1 = '2022';str2 = '我是dvvf';str3 = 'Hello'\n   >>> print(str1.isupper());print(str2.isupper());print(str3.isupper())\n   False\n   False\n   False\n   >>> print('HELLO'.isupper())\n   True\n   ```\n\n   + `isspace()`：检测字符串是否只由空白字符组成。如果字符串中只包含空白，则返回 True，否则返回 False。\n     + 空白符包含：空格、制表符(\\t)、换行(\\n)、回车(\\r）等。\n     + 空串不算空白符。\n\n   ```python\n   >>> print('\\t\\r\\n '.isspace())\n   True\n   >>> print(''.isspace())\n   False\n   ```\n\n   + `istitle()`：检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。如果字符串是标题化的(见 title())则返回 True，否则返回 False。\n\n   ```python\n   >>> print('Hello World!'.istitle());print('Hello world!'.istitle())\n   True\n   False\n   ```\n\n6. `join(seq)`：以指定字符串作为分隔符，将 seq 中所有的元素(**字符串表示**)合并为一个新的字符串。\n\n```python\n>>> seq = ['h','e','l','l','o']\n>>> s = ''\n>>> print(s.join(seq))\nhello\n>>> print('-'.join(seq))\nh-e-l-l-o\n```\n\n7. `len(str)`：返回对象（字符、列表、元组等）长度或项目个数。\n\n```python\n>>> len('hello')\n5\n>>> len([1,2,3,4,'hello'])\n5\n>>> len((1,2,3,4,'hello'))\n5\n```\n\n8. `lower()`和`upper()`：转换字符串中大写字符为小写；小写为大写。\n\n```python\n>>> str = 'Hello'\n>>> str.lower();str.upper()\n'hello'\n'HELLO'\n```\n\n9. `swapcase()`：将字符串中大写转换为小写，小写转换为大写\n\n```python\n>>> str = 'Southwest Jiaotong University'\n>>> str.swapcase()\n'sOUTHWEST jIAOTONG uNIVERSITY'\n```\n\n10. `max(str)`和`min(str)`：返回字符串 str 中最大的字符；最小的字符。max(str)、min(str) 方法不只判断字母，会判断字符串中的所有字符，按照字符在 unicode 中的编码值来决定大小。\n\n```python\n>>> str = 'Hello'\n>>> max(str);min(str)\n'o'\n'H'\n```\n\n11. `replace(old,new[,max])`：把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。\n\n```python\n>>> old = 'hello'*3;new = 'HELLO'\n>>> old.replace('hello',new)\n'HELLOHELLOHELLO'\n>>> old.replace('hello',new,2)\n'HELLOHELLOhello'\n```\n\n12. `split(splitStr,num=str.count(str))`：指定分隔符splitStr对字符串str进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。\n\n+ str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。\n+ num -- 分割次数。默认为 -1, 即分隔所有。\n+ 返回分割后的字符串列表。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> str.split()\n['southwest', 'jiaotong', 'university']\n>>> str.split('i',1)\n['southwest j', 'aotong university']\n```\n\n13. `title()`：所有单词都是以大写开始，其余字母均为小写（标题化字符串）。\n\n```python\n>>> str = 'southwest jiaotong university'\n>>> str.title()\n'Southwest Jiaotong University'\n```\n\n## Python列表\n\n> + 序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。\n>\n> + 列表都可以进行的操作包括索引，切片，加，乘，检查成员。\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323062.png)\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323482.png)\n>\n>   ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182323075.png)\n>\n> + 通过`append()`添加元素，通过`del`语句删除元素。\n>\n> + 可以拼接`+`和重复`*`。\n>\n> + 可以嵌套。\n\n### 列表函数\n\n| 函数                                                         | 描述               |\n| :----------------------------------------------------------- | :----------------- |\n| [len(list)](https://www.runoob.com/python3/python3-att-list-len.html) | 列表元素个数       |\n| [max(list)](https://www.runoob.com/python3/python3-att-list-max.html) | 返回列表元素最大值 |\n| [min(list)](https://www.runoob.com/python3/python3-att-list-min.html) | 返回列表元素最小值 |\n| [list(seq)](https://www.runoob.com/python3/python3-att-list-list.html) | 将元组转换为列表   |\n\n### 列表方法\n\n| 序号                                                         | 方法                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [list.append(obj)](https://www.runoob.com/python3/python3-att-list-append.html) | 在列表末尾添加新的对象                                       |\n| [list.count(obj)](https://www.runoob.com/python3/python3-att-list-count.html) | 统计某个元素在列表中出现的次数                               |\n| [list.extend(seq)](https://www.runoob.com/python3/python3-att-list-extend.html) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |\n| [list.index(obj)](https://www.runoob.com/python3/python3-att-list-index.html) | 从列表中找出某个值第一个匹配项的索引位置                     |\n| [list.insert(index, obj)](https://www.runoob.com/python3/python3-att-list-insert.html) | 将对象插入列表                                               |\n| [list.pop([index=-1])](https://www.runoob.com/python3/python3-att-list-pop.html) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |\n| [list.remove(obj)](https://www.runoob.com/python3/python3-att-list-remove.html) | 移除列表中某个值的第一个匹配项                               |\n| [list.reverse()](https://www.runoob.com/python3/python3-att-list-reverse.html) | 反向列表中元素                                               |\n| [list.sort( key=None, reverse=False)](https://www.runoob.com/python3/python3-att-list-sort.html) | 对原列表进行排序                                             |\n| [list.clear()](https://www.runoob.com/python3/python3-att-list-clear.html) | 清空列表                                                     |\n| [list.copy()](https://www.runoob.com/python3/python3-att-list-copy.html) | 复制列表                                                     |\n\n## Python元组\n\n> + Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n> + 元组使用小括号 **( )**，列表使用方括号 **[ ]**。\n\n## Python字典\n\n> + 字典是另一种可变容器模型，且可存储任意类型对象。\n> + **注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict。**\n> + ![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204182351656.png)\n> + 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字。\n\n### 字典函数\n\n| 函数             | 描述                                               |\n| :--------------- | :------------------------------------------------- |\n| `len(dict) `     | 计算字典元素个数，即键的总数。                     |\n| `str(dict)`      | 输出字典，可以打印的字符串表示。                   |\n| `type(variable)` | 返回输入的变量类型，如果变量是字典就返回字典类型。 |\n\n### 字典方法\n\n| 序号 | 函数及描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [dict.clear()](https://www.runoob.com/python3/python3-att-dictionary-clear.html) 删除字典内所有元素 |\n| 2    | [dict.copy()](https://www.runoob.com/python3/python3-att-dictionary-copy.html) 返回一个字典的浅复制 |\n| 3    | [dict.fromkeys()](https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html) 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |\n| 4    | [dict.get(key, default=None)](https://www.runoob.com/python3/python3-att-dictionary-get.html) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 |\n| 5    | [key in dict](https://www.runoob.com/python3/python3-att-dictionary-in.html) 如果键在字典dict里返回true，否则返回false |\n| 6    | [dict.items()](https://www.runoob.com/python3/python3-att-dictionary-items.html) 以列表返回一个视图对象 |\n| 7    | [dict.keys()](https://www.runoob.com/python3/python3-att-dictionary-keys.html) 返回一个视图对象 |\n| 8    | [dict.setdefault(key, default=None)](https://www.runoob.com/python3/python3-att-dictionary-setdefault.html) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |\n| 9    | [dict.update(dict2)](https://www.runoob.com/python3/python3-att-dictionary-update.html) 把字典dict2的键/值对更新到dict里 |\n| 10   | [dict.values()](https://www.runoob.com/python3/python3-att-dictionary-values.html) 返回一个视图对象 |\n| 11   | [pop(key[,default])](https://www.runoob.com/python3/python3-att-dictionary-pop.html) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |\n| 12   | [popitem()](https://www.runoob.com/python3/python3-att-dictionary-popitem.html) 返回并删除字典中的最后一对键和值。 |\n\n## Python集合\n\n> + 集合（set）是一个无序的不重复元素序列。\n> + 可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。\n\n### 集合内置方法\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [add()](https://www.runoob.com/python3/ref-set-add.html)     | 为集合添加元素                                               |\n| [clear()](https://www.runoob.com/python3/ref-set-clear.html) | 移除集合中的所有元素                                         |\n| [copy()](https://www.runoob.com/python3/ref-set-copy.html)   | 拷贝一个集合                                                 |\n| [difference()](https://www.runoob.com/python3/ref-set-difference.html) | 返回多个集合的差集                                           |\n| [difference_update()](https://www.runoob.com/python3/ref-set-difference_update.html) | 移除集合中的元素，该元素在指定的集合也存在。                 |\n| [discard()](https://www.runoob.com/python3/ref-set-discard.html) | 删除集合中指定的元素                                         |\n| [intersection()](https://www.runoob.com/python3/ref-set-intersection.html) | 返回集合的交集                                               |\n| [intersection_update()](https://www.runoob.com/python3/ref-set-intersection_update.html) | 返回集合的交集。                                             |\n| [isdisjoint()](https://www.runoob.com/python3/ref-set-isdisjoint.html) | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 |\n| [issubset()](https://www.runoob.com/python3/ref-set-issubset.html) | 判断指定集合是否为该方法参数集合的子集。                     |\n| [issuperset()](https://www.runoob.com/python3/ref-set-issuperset.html) | 判断该方法的参数集合是否为指定集合的子集                     |\n| [pop()](https://www.runoob.com/python3/ref-set-pop.html)     | 随机移除元素                                                 |\n| [remove()](https://www.runoob.com/python3/ref-set-remove.html) | 移除指定元素                                                 |\n| [symmetric_difference()](https://www.runoob.com/python3/ref-set-symmetric_difference.html) | 返回两个集合中不重复的元素集合。                             |\n| [symmetric_difference_update()](https://www.runoob.com/python3/ref-set-symmetric_difference_update.html) | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |\n| [union()](https://www.runoob.com/python3/ref-set-union.html) | 返回两个集合的并集                                           |\n| [update()](https://www.runoob.com/python3/ref-set-update.html) | 给集合添加元素                                               |\n\n<!--start: 2022.04.18-->\n\n## Reference\n\n1. [Python3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-tutorial.html)\n\n","tags":["Python","Jupter NoteBook","Anaconda"],"categories":["学习笔记"]},{"title":"PicGo+Gitee搭建图床","url":"/hexo-blogs/2022/08/19/PicGo+Gitee搭建图床/","content":"\n\n\n# ~~PicGo+Gitee搭建图床~~\n\n> 这里主要用于Typora上传图片。**2022.5.23：Gitee已经废了，现在用阿里云OSS，还是自己控制的图床安心！**\n\n## 1. 在Gitee创建图床仓库\n\n> 仓库需要设置成公开，否则无法查看图片。\n\n## 2. 生成私人令牌\n\n> 设置->私人令牌->生成心令牌\n\n![image-20220312190756949](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312190756949.png)\n\n> 输入密码后保存生成的令牌。\n\n## 3. 下载PicGo并安装\n\n[PicGo](https://picgo.github.io/PicGo-Doc/zh/)\n\n## 4. 安装插件`github-plus`\n\n> 支持设置图床到gitee。\n\n![image-20220312185418404](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312185418404.png)\n\n## 5. 配置PicGo\n\n![image-20220312191408653](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312191408653.png)\n\n> 可设置为默认图床。\n\n## 7. 配置Typora\n\n> 打开Typora，文件->偏好设置->图像\n\n![image-20220312194344043](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203121943121.png)\n\n","tags":["Gitee","PicGo"],"categories":["教程"]},{"title":"C语言踩坑记录","url":"/hexo-blogs/2022/08/19/C语言踩坑记录/","content":"\n# C语言踩坑记录\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2022-04-14 -->\n> 第一次提交：指针使用错误；内存泄漏\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 不同类型的指针不能进行强转\n\n> 错误实例：`int*`转成`double*`。\n\n```c\n#include <stdio.h>\n\nvoid display(double *array, int length)\n{\n    for (int i = 0; i < length; i++)\n    {\n        printf(\"%f \", array[i]);\n    }\n    printf(\"\\n\");\n}\nint main()\n{\n    int array[] = {1, 2, 3, 4, 5, 6, 7};\n    //error: expected 'double *' but argument is of type 'int *'\n    display(array, 7);\n\n    return 0;\n}\n```\n\n## 内存分配与释放\n\n### 错误实例\n\n> + **只管申请分配内存，没有释放，造成内存泄漏！**\n> + **只管申请分配内存（就默认申请分配成功），没有考虑对内存分配失败的异常进行处理！**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5;\n    int col = 10;\n    \n    //只申请分配了内存，没有释放\n    arrays = (int **)malloc(sizeof(int *) * row);\n    for (int i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        for (int j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\n### 正确实例\n\n> + **分配了就要释放。**\n> + **既然是申请，就要处理申请失败的异常情况。**\n\n```c\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-14\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-14\n * @Description: C语言内存分配与释放\n */\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5, col = 10;\n    int i, j;\n\n    //分配内存\n    arrays = (int **)malloc(sizeof(int *) * row);\n    if (arrays == NULL) //内存分配失败直接返回\n    {\n        printf(\"memory allocation failure!\\n\");\n        return -1;\n    }\n    for (i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        if (arrays[i] == NULL) //内存分配失败直接返回\n        {\n            printf(\"memory allocation failure!\\n\");\n            return -1;\n        }\n        for (j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //释放内存\n    for (i = 0; i < row; i++)\n    {\n        free(arrays[i]);\n    }\n    free(arrays);\n\n    return 0;\n}\n\n```\n\n> + 一定确保所有的内存都进行了释放。\n\n```c\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-14\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-14\n * @Description: C语言内存分配与释放\n */\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int **arrays = NULL;\n    int row = 5, col = 10;\n    int i, j;\n\n    //分配内存\n    arrays = (int **)malloc(sizeof(int *) * row);\n    if (arrays == NULL) //内存分配失败直接返回\n    {\n        printf(\"memory allocation failure!\\n\");\n        return -1;\n    }\n    for (i = 0; i < row; i++)\n    {\n        arrays[i] = (int *)malloc(sizeof(int) * col);\n        if (arrays[i] == NULL) //内存分配失败直接返回\n        {\n            printf(\"memory allocation failure!\\n\");\n            return -1;\n        }\n        for (j = 0; j < col; j++)\n        {\n            arrays[i][j] = i + j;\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //假设需要将二维数组的第一行删除\n    free(arrays[0]);              //重要:先将第一行的内存释放\n    for (i = 0; i < row - 1; i++) //将每行依次往前移\n    {\n        arrays[i] = arrays[i + 1]; //这里是将arrays[i]指向 arrays[i + 1]所指向的地址\n    }\n    row--;\n\n    printf(\"row 1 is deleted,arrays:\\n\");\n    for (i = 0; i < row; i++)\n    {\n        for (j = 0; j < col; j++)\n        {\n            printf(\"%d \", arrays[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    //释放内存\n    for (i = 0; i < row; i++)\n    {\n        free(arrays[i]);\n    }\n    free(arrays);\n\n    return 0;\n}\n\n```\n\n","tags":["C","踩坑记录"],"categories":["bug日常"]},{"title":"Hexo+Gitee搭建个人博客","url":"/hexo-blogs/2022/08/19/Hexo+Gitee搭建个人博客/","content":"\n# Hexo+Gitee搭建个人博客\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.03.29 -->\n>\n> 更新：侧边栏添加一言API\n> <!-- endtimeline -->\n>\n> <!-- timeline 2022.03.14 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n<!--start: 2022.03.12-->\n\n## 工具准备\n\n### Gitee：国内的github\n\n> 1. 拥有gitee账号。\n> 2. 在本地已配置过用户名和密码。\n> 3. 进行实名认证（开通Pages服务要求）。\n\n### git：开源的分布式版本控制系统。\n\n> 略。\n\n### Typora：markdown文本编辑器\n\n> 略。\n\n### node.js：运行在服务端的 JavaScript\n\n#### node.js更新\n\n1. 已安装`node.js`，进行更新到最新稳定版。\n\n2. window下下载最新版本覆盖安装。[Node.js (nodejs.org)](https://nodejs.org/zh-cn/)\n\n3. 查看版本。\n\n   ```shell\n   #检查 node.js\n   node -v\n   #检查 npm\n   npm -v\n   ```\n\n#### cnpm安装\n\n1. cnpm为cnpm在国内的镜像。\n\n2. 安装命令。\n\n   ```shell\n   npm install -g cnpm --registry=https://registry.npm.taobao.org\n   ```\n\n3. 检查 cnpm 是否安装成功：`cnpm -v`。\n\n### hexo：快速、简洁且高效的博客框架\n\n1. [Hexo](https://hexo.io/zh-cn/)\n2. 打开命令行，输入以下命令。\n\n```shell\ncnpm install -g hexo-cli\n```\n\nwindow下可能出现：\n\n```shell\nError: EPERM: operation not permitted, mkdir 'C:\\Program Files\\nodejs\\node_modules\\hexo-cli_tmp'\n```\n\n原因是**node目录权限不够**。这是需要授予node目录**完全控制**权限。\n\n1. 查看是否安装成功。\n\n   ```shell\n   hexo -v\n   ```\n\n## 博客安装\n\n### hexo安装\n\n[建站 | Hexo](https://hexo.io/zh-cn/docs/setup)\n\n1. 本地建立文件夹。\n\n![image-20220312124109724](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124109724.png)\n\n2. 进入这个文件夹，右键打开 Git Bash Here。\n\n3. 输入以下命令**初始化博客**，等待下载完成。**这里也需要注意，需要拥有对文件夹的完全控制权限。**\n\n   ```shell\n   hexo init\n   ```\n\n   ![image-20220312124405530](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124405530.png)\n\n   > 然后输入命令: npm install\n\n4. 运行博客。\n\n   ```shell\n   hexo s\n   ```\n\n   ![image-20220312124956438](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312124956438.png)\n\n5. 在浏览器输入localhost:4000查看。\n\n6. hexo常用命令，在建立的博客根目录git Bash下运行。\n\n   ```shell\n   # 本地启动博客\n   hexo s\n   #ctrl+c 停止\n   \n   # 新建博客文章\n   hexo new \"标题\"\n   \n   # 清除博客缓存\n   #一般在切换博客主题，或者博客效果与预期不一致时执行该命令\n   hexo clean\n   \n   # md 文件生成静态页面\n   #一般在使用 hexo clean 命令后使用\n   hexo g\n   \n   ```\n\n### 主题配置\n\n> 这里极力推荐[Butterfly - A Simple and Card UI Design theme for Hexo](https://butterfly.js.org/)。安装和配置过程都有详细教程！\n\n### 博客配置\n\n> .config.yml下配置。\n\n1. 网站参数配置\n\n> 参考 [配置 | Hexo](https://hexo.io/zh-cn/docs/configuration)\n\n![image-20220314143021617](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203141430702.png)\n\n2. 网址参数配置\n\n> 参见《博客部署》设置远程仓库。\n\n## 博客部署\n\n### 登录码云，新建仓库\n\n> 仓库名与本地博客文件夹名保持一致。\n\n### 安装git插件\n\n> 在博客根目录下右键 GitBash 打开，输入以下内容，等待下载完成。\n\n```shell\ncnpm install --save hexo-deployer-git\n```\n\n![image-20220312130217832](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312130217832.png)\n\n### 设置远程仓库\n\n1. **打开 `_config.yml`。**\n\n   ![image-20220312130849683](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312130849683.png)\n\n   2. **设置`URL`**\n\n      ![image-20220312131855803](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312131855803.png)\n\n   3. **设置仓库地址**\n\n      > 这里使用的是https方式，每次上传需要输入用户名和密码。因此也推荐SSH方式。\n      \n      ![image-20220312132339987](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312132339987.png)\n\n### 部署到远端\n\n> 在博客根目录下右键 GitBash 打开，输入命令。\n>\n> 过程中需要输入码云的用户名和密码。\n\n```shell\nhexo d\n```\n\n![image-20220312133603132](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/image-20220312133603132.png)\n\n### 开启码云的静态页面服务\n\n> 进入码云新建的仓库，开启 `Gitee Pages`服务。\n\n> 注：开启该服务需要实名认证。因此可以提前一天提交实名认证申请。\n\n![image-20220314092949975](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140929168.png)\n\n> 等待部署\n\n![image-20220314095042212](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140950279.png)\n\n## 博客流程\n\n### 写博客\n\n> 1. 博客根目录下，打开git Bash。\n> 2. 执行 `hexo new \"title\"`，title为md文件名。这种创建方式会使用</scaffolds/post.md>下的模板来创建，可以设置一些默认的Front-matter。\n> 3. 使用 typora 编辑并保存。\n>    + 关于**Front-matter**。参见[Butterfly 安裝文檔(二) 主題頁面 | Butterfly](https://butterfly.js.org/posts/dc584b87/)。\n>    + 关于上传图片.参见博客-[PicGo+Gitee搭建图床 | JoeGoodyLv](https://guojin_lv.gitee.io/hexo-blogs/2022/03/12/PicGo+Gitee搭建图床/)。\n\n### 清除缓存&更新渲染\n\n> 1. 执行 `hexo clean`清除缓存。\n> 2. 执行`hexo g`重新渲染静态界面\n> 2. `hexo s` 打开本地界面\n\n### 推送到码云\n\n> 执行`hexo d`。\n\n### 更新码云的静态界面\n\n![image-20220314095654318](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203140956387.png)\n\n","tags":["Gitee","Hexo"],"categories":["教程"]},{"url":"/hexo-blogs/2022/08/19/C++学习笔记(1)/","content":"title: C++学习笔记(1)\ndescription: 学习笔记之《21天学通C++(第8版)》Siddhartha Rao著。\ncategories: 学习笔记\ncover: https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg\ntags: \n\n- C-plus-plus\n- STL\n\n# C++学习笔记(1)\n\n> 《21天学通C++(第8版)》Siddhartha Rao著\n\n<!--start: 2022.03.06-->\n\n## auto\n\n1. **auto**自动推断类型（C++11新增）\n\n   ```cpp\n   //使用auto必须进行初始化\n   auto largeNumber = 25000000000000; //编译器根据初始值来确定合适的值，这里应该为long long\n   ```\n\n2. auto迭代\n\n   ```cpp\n   int a[] = {1,2,3,4,5};\n   for(auto temp : a)\n   {\n      cout<<temp<<endl;\n   }\n   \n   //auto& 可以修改数组a的值\n   for(auto& temp : a)\n   {\n       temp++;\n       cout<<temp<<endl;\n   }\n   ```\n\n   \n\n## const; constexpr\n\n1. 如果变量的值不应该被改变，就应该将其声明为常量。\n\n   ```cpp\n   const double PI = 3.1415926;\n   \n   constexpr double GetPi(){ return 22.0/7;} //使用constexpr声明常量表达式\n   \n   enum CardinalDirections\n   {\n       North,\n       South,\n       East,\n       West\n   };\n   \n   //不要使用#define定义常量，该方法已被摒弃\n   ```\n\n**不要使用#define定义常量，该方法已被摒弃。**\n\n## 动态数组\n\nstd::vector\n\n## C++字符串\n\n1. 避免C风格字符串：以'\\0'作为终止空字符。\n2. 使用std:string，包含`#include<string>`\n\n## 内联函数\n\n1. 当**函数非常简单，且需要降低开销**的时候，可以声明为内联函数。\n\n## 指针\n\n1. 指针是存储内存地址的变量。\n\n   ```cpp\n   int *p = NULL;//初始化，未初始化的指针包含的值是垃圾值（随机的），可能导致问题（非法访问）。\n   ```\n\n2. 使用引用运算符`&`获取变量的地址。\n\n3. 解除引用运算符`*`访问指向地址所存储的值。\n\n4. const修饰指针\n\n   + 修饰 **指针包含的地址为常量**，无法修改，但可修改指针指向的数据。\n\n     ```cpp\n     int daysInMonth = 30;\n     int* const pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//OK!\n     int daysInLUnarMonth = 28;\n     \n     pDaysMonth = &daysInLUnarMonth;//Not OK!\n     ```\n\n     \n\n   + 修饰 **指针指向的数据为常量**，不能修改，但可以修改指针包含的地址。\n\n     ```cpp\n     int daysInMonth = 30;\n     const int* pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//Not OK!\n     int daysInLUnarMonth = 28;\n     \n     pDaysMonth = &daysInLUnarMonth;//OK!\n     \n     int* newMonth = pDaysMonth;//Not OK!\n     ```\n\n   + 修饰 **指针包含的地址以及它指向的值都是常量**，不能修改。\n\n     ```cpp\n     int daysInMonth = 30;\n     const int* const pdaysMonth = &daysInMonth;\n     *pDaysMonth = 31;//Not OK!\n     int daysInLUnarMonth = 28;\n     pDaysMonth = &daysInLUnarMonth;//Not OK!\n     ```\n\n5. 数组可赋给指针。\n\n6. 使用指针常见错误：\n\n   + 内存泄漏\n   + 指针指向无用的内存单元：未初始化\n\n## new(std::nothrow)\n\n1. **new**(std::**nothrow**) 顾名思义，即不抛出异常，**当**new**一个对象失败时，默认设置该对象为NULL**，这样可以方便的通过if(p ** NULL) 来判断**new**操作是否成功。\n2. 普通的**new**操作，如果分配内存失败则会抛出异常，虽然后面一般也会写上if(p ** NULL) 但是实际上是自欺欺人，因为如果分配成功，p肯定不为NULL；而如果分配失败，则程序会抛出异常，if语句根本执行不到。\n3. 因此，建议在c++代码中，凡是涉及到**new**操作，都采用**new**(std::**nothrow**)，然后if(p**NULL)的方式进行判断\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint* points = new(nothrow) int[10];\n\tif(points)\n\t{\n\t\tcout<<\"Memory allocation successed. Ending program\"<<endl;\n\t\tdelete[] points;\n\t}\t\n\telse{\n\t\tcout<<\"Memory allocation failed. Ending program\"<<endl;\n\t}\n   return 0;\n}\n```\n\n## 引用\n\n1. 引用是相应变量的别名。\n\n   ```cpp\n   int flag = 30;\n   int& temp = flag;\n   ```\n\n2. const修饰引用：禁止通过引用修改它所指向变量的值。\n\n3. **引用**向函数传递参数**的优点之一：可避免将形参赋值给形参，从而极大提高性能。\n\n   ```cpp\n   #include <iostream>\n   using namespace std;\n   \n   //如果函数接收非常大的对象，则按值传递的开销将非常大，通过使用引用，可极大地提高函数调用的效率。别忘了将const用于引用参数，除非函数需要将结果储存于参数中。\n   void GetSquare(const int& number, int& result)\n   {\n   \tresult = number*number;\n   }\n   \n   int main()\n   {\n   \tint number = 0;\n   \tcin >> number;\n   \t\n   \tint square = 0;\n   \t\n   \tGetSquare(number,square);\n   \t\n   \tcout<<number<<\"^2 = \"<<square<<endl;\n   \t\n      return 0;\n   }\n   ```\n\n\n<!--end: 2022.03.06-->\n\n<!--start: 2022.03.07-->\n\n## 类和对象\n\n### 拷贝构造函数\n\n```markdown\n什么是浅拷贝？只有普通变量初始化的拷贝构造函数就浅拷贝。咋算普通变量？如int,char, string…不涉及指针变量。可以直接使用默认拷贝构造函数。\n\n什么是深拷贝？不用默认拷贝构造函数，自己显式定义一个拷贝构造函数，并且在其内部再次分配动态内存，这就是深拷贝。总的来说，就是类中涉及到指针变量，需要在拷贝构造函数内部申请一遍。\n\n使用浅拷贝还是深拷贝，最直接判断方式是看一下类中有没有指针变量。\n\n```\n\n1. **浅拷贝**：如果类中含有指针变量，导致多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 深浅拷贝操作\n\nclass Person\n{\npublic:\n    // 无参构造函数\n    Person()\n    {\n        cout << \"Person的构造函数调用\" << endl;\n    }\n    // 有参构造函数\n    Person(int a, int h)\n    {\n        m_Age = a;\n        m_Height = new int(h);\n        cout << \"Person的有参构造函数调用\" << endl;\n    }\n    // 析构造函数\n    ~Person()\n    {\n        // 将堆区开辟的空间释放掉\n        if(m_Height != NULL)\n        {\n            delete m_Height;\n            m_Height = NULL;    // 防止野指针出现\n        }\n        cout << \"Person的析构造函数调用\" << endl;\n    }\n\n    // 自己实现拷贝构造函数，解决浅拷贝带来的问题\n    //务必将接受源对象的参数声明为const引用\n    Person(const Person &p)\n    {\n        cout << \"Person拷贝造函数调用\" << endl;\n        m_Age = p.m_Age;\n        // m_Height = p.m_Height;   // 编译器默认实现就是这行代码(浅拷贝)\n        // 深拷贝操作\n        m_Height = new int(*p.m_Height);\n    }\n\n    int m_Age;  // 年龄\n    int *m_Height; // 身高\n};\n\nvoid test01()\n{\n    Person p1(18, 160);\n    cout << \"Person的年龄：\" << p1.m_Age << \"身高为：\" << *p1.m_Height << endl;\n\n    Person p2(p1);  // 执行来浅拷贝操作（调用默认的拷贝函数）\n    cout << \"P2的年龄：\" << p1.m_Age << \"身高为：\" << *p2.m_Height << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    /* code */\n    test01();\n\n    return 0;\n}\n```\n\n![](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202205231058265.jpg)\n\n### 单例类\n\n[28.C++- 单例类模板(详解) - 诺谦 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lifexy/p/8810877.html)\n\n### explicit\n\n1. explicit关键字的作用就是防止类构造函数的隐式自动转换.\n2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.\n3. explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。\n4. **google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。**所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。\n5. effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。\n\n## 继承（inheritance）\n\n1. is-a：公有继承\n\n   子类、子类的对象可以访问基类的public成员。\n\n2. has-a：\n\n   + 保护继承\n\n     子类可以访问基类的public和protect方法，但子类的对象不能访问基类的public成员。\n\n   + 私有继承\n\n     子类、子类的对象不能访问基类的public成员。\n\n3. 使用final禁止继承（C++11）\n\n## 多态（polymorphism）\n\n### 使用虚函数实现多态\n\n1. 对于将被派生类覆盖的基类方法，务必将其声明为虚函数。\n\n2. **对基类析构函数，务必提供一个虚析构函数。**\n\n### 纯虚函数\n\n+ 纯虚函数导致类变成抽象基类，且在派生类中必须提供虚函数的实现。\n+ 抽象基类无法被实例化。\n\n```cpp\n//抽象基类（ABC）\nclass AbstractBase\n{\npublic:\n    virtual void DoSomeThing() = 0; //纯虚函数\n};\n//上述声明告诉编译器，AbstractBase的派生类必须实现方法DoSomeThing()；\nclass Derived: public AbstractBase\n{\npublic:\n    void DoSomeThing()\n    {\n        cout<<\"Implemented virtual function\"<<endl;\n    }\n};\n```\n\n### 虚继承\n\n1. 如果派生类可能被用作基类，派生它 最好使用关键字virtual：\n\n   ```cpp\n   class Derived1 : public virtual Base\n   {\n       \n   };\n   class Derived2 : public virtual Base\n   {\n       \n   };\n   //并且使用关键字final禁止将SubDerived作为基类\n   class SubDerived final: public Derived1, public Derived2\n   {\n       \n   };\n   ```\n\n   在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性。这种二义性被称为**菱形问题**（Diamond Problem）。\n\n### override(C++11)\n\n在派生类中声明要覆盖基类函数的函数时，务必使用override。\n\noverride提供了一种强大的途径，让程序员明确地表达对基类的虚函数进行覆盖的意图，进而让编译器做如下检查：\n\n+ 基类函数是否是虚函数？\n+ 基类中相应虚函数的特征标识是否与派生类中被声明为override的函数完全相同？\n\n```cpp\nclass Base ｛\nvirtual void f();\n};\n\nclass Derived : public Base {\nvoid f() override; // 表示派生类重写基类虚函数f\nvoid F() override;//错误：函数F没有重写基类任何虚函数\n};\n```\n\n+ overide作用：在派生类中提醒自己要重写这个同参数函数，不写则报错。\n\n## 运算符\n\n1. 理论上来说，前缀运算符优于后缀运算符。`++value优于value++`。\n2. 对于有原始指针的类，务必实现拷贝构造函数和重载赋值运算符。 \n\n### 运算符重载\n\n```cpp\nreturn_type operator operator_symbol(...parameter list...)\n```\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass Box\n{\n    double length;  //长度\n    double width;   //宽度\n    double height;  //高度\npublic:\n    Box(){}\n    Box(double length,double width, double height):length(length),width(width),height(height){}\n    ~Box(){}\n    void print(void)\n    {\n        cout<<length<<\",\"<<width<<\",\"<<height<<endl;\n    }\n    \n    //重载 + 运算符，  实现Box相加\n    Box operator + (const Box& b)\n    {\n        Box box;\n        box.length = this->length + b.length;\n        box.width = this->width + b.width;\n        box.height = this->height + b.height;\n        return box;\n    }\n    \n    //重载前缀运算符 ++\n    Box operator ++ ()\n    {\n        ++this->length;\n        ++this->width;\n        ++this->height;\n        return *this;\n    }\n    \n    //重载后缀运算符 --\n    //注意，int 在 括号内是为了向编译器说明这是一个后缀形式，而不是表示整数。只是为了区分前置后置\n    Box operator -- (int)  //加上int \n    {\n        //保存原始值\n        Box temp = *this; //隐式调用转换函数\n        //Box temp(*this); //调用默认拷贝构造函数\n        //Box temp(length,width,height);\n        --this->length;\n        --this->width;\n        --this->height;\n        return temp; //返回原始值\n    }\n    \n    /*在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。习惯上人们是使用 cin>> 和 cout<< 的，得使用友元函数来重载运算符，如果使用成员函数来重载会出现 d1<<cout; 这种不自然的代码。\n    */\n    //相当于在整个全局声明了一个重载运算符。当重载的运算符函数是全局函数时，需要在类中将该函数声明为友元\n    //重载 >>\n    friend istream& operator >> (istream& input, Box& b)\n    {\n        input >> b.length >> b.width >> b.height;\n        return input;\n    }\n    \n    //重载 <<\n    friend ostream& operator << (ostream& output,const Box& b)\n    {\n        output<<b.length<<\",\"<<b.width<<\",\"<<b.height;\n        return output;\n    }\n};\n\nint main()\n{\n    Box box1(5.0,6.0,7.0);\n    Box box2(8.0,9.0,10.0);\n    Box box3 = box1 + box2;\n    box3.print();  //13,15,17\n    \n    Box ox4 = ++box3;\n    box4.print(); //14,16,18\n    \n    Box box5 = box3--;\n    box5.print(); //14,16,18\n    \n    box3.print(); //13,15,17\n    \n    Box box6;\n    cin >> box6;\n    cout <<box6<<endl;\n    return 0;\n}\n```\n\n## C++类型转换运算符\n\n`destination_type result = cast_operator<destination_type> (object_to_cast)`\n\n### static_cast\n\n+ 用于在相关类型的指针之间转换。\n\n```cpp\nDerived objDerived1 = new Derived();\nBase* objBase = &objDerived1;  //OK！向上转换，无需显式转换\n\nDerived* objDerived2 = objBase;//Error! 向下转换，需要显式转换\n\n//OK!\nDerived* objDerived2 = static_cast<Derived*>objBase; \n```\n\n```cpp\n//static_cast只验证指针类型是否相关，而不执行任何运行阶段的检查。\nBase* objBase = new Base();\nDerived* objDer = static_cast<Derived*>objBase;//Not Error！但有可能导致意外结果。\n```\n\n+ 将原本隐式的标准数据类型的类型转换 转换为  显式。\n\n### dynamic_cast\n\n+ 与static_cast相反，dynamic_cast在运行阶段执行转换，可检查dynamic_cast操作的结果，以判断类型转换是否成功。\n\n  ```cpp\n  Base* objBase = new Derived();\n  \n  Derived* objDer = dynamic_cast<Derived*>(objBase);\n  \n  //务必检查dynamic_cast的返回值，看它是否有效。如果返回值为NULL，说明转换失败。\n  if(objDer)\n  {\n      objDer->CallDerivedFunction();\n  }\n  ```\n\n  \n\n+ 这种在运行阶段识别对象类型的机制称为 **运行阶段类型识别**（runtime type identification, **RTTI**）\n\n### reinterpret_cast\n\n+ 强制转换。\n+ 应尽量避免使用reinterpret_cast。\n\n### const_cast\n\n+ 让程序员能够关闭对象的访问限制符const。\n\n  ```cpp\n  \n  //DisplayMembers（）本应该为const的，但没有这样定义。并且类SomeClass属于第三方库，无法对其进行修改。\n  void DisplayAllData(const SomClass& object)  //显然 这里使用const是应该的\n  {\n      object.DisplayMembers();//编译错误\n      //原因：使用const引用调用non-const的成员。\n  }\n  \n  void DisplayAllData(const SomClass& object)\n  {\n      SomeClass& refData = const_cast<SomeClass&>(object);\n      object.DisplayMembers();//OK!\n  }\n  ```\n\n+ 非必要不使用const_cast来调用非const函数。这样导致的结果不可预料！\n\n### 除dynamic_cast外的类型转换都是可以避免的；应尽量避免使用类型转换。\n\n<!--end: 2022.03.07-->\n\n<!--start: 2022.03.09-->\n\n## 宏\n\n### 使用#define定义常量\n\n+ 预处理只是进行死板的文本替换，而不检查替换是否正确。\n\n```cpp\n#define PI 3.1415926 //再预处理器看来，无法确定其数据类型\n\n//定义常量时，更好的方法是使用const\nconst double PI = 3.1415926;\ntypedef double MY_DOUBLE; //#define MY_DOUBLE double\n```\n\n### 使用宏避免多次包含\n\n+ 预处理器编译指令： `#ifndef`  `#endif`\n\n  ```cpp\n  #ifndef _HEAD_H_\n  #define _HRAD_H_\n  \n  //head.h的内容\n  \n  #endif   //end of head.h\n  ```\n\n### 使用#define编写宏函数\n\n+ 注意使用括号保证优先级\n\n### 使用assert宏验证表达式\n\n+ 需包含`#include<assert.h>`。\n+ assert用来调试，对输入的参数进行验证。\n+ assert()在发布模式下不可用。\n+ **推荐在代码中大量使用assert()，虽然在发行版本被禁用，但对提高代码质量很有帮助。**\n\n### 尽量不要自己编写宏函数；使用const常量而不是宏常量。宏不是类型安全的。\n\n## 模板\n\n+ 模板无疑是C++语言中最强大的特性之一。模板是类型安全的。\n+ 在编译器看来，仅当模板被使用时，其代码才存在。\n+ 对模板来说，实例化是指使用一个或多个模板参数来创建特定的类型。\n\n### 模板声明 template  \n\n```cpp\ntemplate<typename objType>\n```\n\n### 模板函数\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n//模板函数\ntemplate<typename objType>\nconst objType& GetMax(const objType& value1, const objType& value2)\n{\n    return value1 > value2 ? value1 : value2;\n}\n\nint main()\n{\n    int num1 = 25, num2 = 40;\n    //int maxVal = GetMax<int>(num1,num2); //模板函数可以不显式指定类型，但模板类必须显式指定。\n    int maxVal = GetMax(num1,num2);\n    cout<<maxVal<<endl;\n    \n    return 0;\n}\n```\n\n### 模板类\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n//模板类\ntemplate<typename T1, typename T2 = T1> //T2的类型默认为T1\n//template<typename T1 = int, typename T2 = string> //声明默认参数的模板\nclass MyTemplate\n{\n    T1 member1;\n    T2 member2;\npublic:\n    MyTemplate(const T1& t1, const T2& t2):member1(t1),member2(t2){}\n    const T1 getObj1() const{return member1;}  //返回值为const ; this指针为const\n    T2 getObj2(){return member2;}\n    //...\n};\n\n//使用\nint main()\n{\n    MyTemplate<int ,double> temp1(10,19.5);\n    MyTemplate<int ,string> temp2(10,\"hello world!\");\n    cout<<temp1.getObj1()<<endl;\n    cout<<temp2.getObj2()<<endl;\n    return 0;\n}\n\n```\n\n### 参数数量可变的模板(C++11)\n\n[泛化之美--C++11可变模版参数的妙用 - qicosmos(江南) - 博客园 (cnblogs.com)](https://www.cnblogs.com/qicosmos/p/4325949.html)\n\n```cpp\n//这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入了typename这个关键字，它的作用同class一样表明后面的符号为一个类型\n//template <class... T>   \ntemplate<typename... T>\nvoid f(T... args);\n\nsizeof...(args)  //sizeof...()打印可变参的个数\n```\n\n上面的可变模版参数的定义当中，**省略号的作用**有两个：\n\n1. 声明一个**参数包**T... args，这个参数包中可以包含0到任意个模板参数；\n2. 在模板定义的右边，可以将参数包展开成一个一个独立的参数。\n\n**我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数。**\n\n展开可变模版参数函数的方法一般有两种：一种是**通过递归函数来展开参数包**，另外一种是**通过逗号表达式来展开参数包**。\n\n1. **递归函数方式展开参数包**\n\n   ```cpp\n   \n   #include <iostream>\n   using namespace std;\n   \n   //通过递归函数展开参数包，需要提供一个参数包展开的函数和一个重载的递归终止函数，递归终止函数正是用来终止递归的。\n   //递归终止函数\n   template <typename T>\n   void print(T head)\n   {\n      cout << \"parameter \" << head << endl;\n   }\n   //展开函数\n   template <typename T, typename ...Args>\n   void print(T head, Args... rest)\n   {\n      cout << \"parameter \" << head << endl;\n      print(rest...);\n   }\n   \n   int main(void)\n   {\n      print(1,2,3,4);\n      return 0;\n   }\n   \n   ```\n\n2. **逗号表达式展开参数包**\n\n   ```cpp\n   #include <iostream>\n   using namespace std;\n   \n   //这种方式需要借助逗号表达式和初始化列表\n   template <typename T>\n   void printarg(T t)\n   {\n      cout << t << endl;\n   }\n   \n   template <typename ...Args>\n   void expand(Args... args)\n   {\n      int arr[] = {(printarg(args), 0)...};\n   }\n   \n   int main(void)\n   {\n      expand(1,2,3,4);\n      return 0;\n   }\n   ```\n\n\n### static_assert(C++11)\n\n1. 执行编译阶段断言：禁止不希望的模板实例化。\n\n   ```cpp\n   //禁止针对int实例化模板\n   static_assert(sizeof(T) != sizeof(int),\"No in please!\");  //不满足条件禁止编译\n   ```\n\n## 标准模板库\n\n### STL容器\n\n容器是用于存储数据的STL类。\n\n#### 顺序容器\n\n顾名思义，顺序容器按顺序存储数据，如数组和列表。插入速度快，查找满。\n\n+ `std::vector`：常规动态数组。\n+ `std::deque`：动态数组，但允许在开头插入或删除。\n+ `std::list`：双向链表。\n+ `std::forward_list`：单向链表。\n\n#### 关联容器\n\n按指定的顺序存储数据。插入慢，查找快。\n\n+ `std::set`：集合\n+ `std::unordered_set`：\n+ `std::map`：键-值对。\n+ `std::unordered_map`：\n+ `std::multiset`：类似set，不要求值唯一的，可存储多个值相同的项。\n+ `std::unordered_multiset`：\n+ `std::multimap`：类似map，不要求键是唯一的。\n+ `std::unordered_multimap`：\n\n#### 容器适配器（Container Adapter）\n\n+ `std::stack`：栈\n+ `std::queue`：队列\n+ `std::priority_queue`：\n\n### STL迭代器\n\n### STL算法\n\n### STL字符串类\n\n+ `std::string`：简单字符串\n+ `std::wstring`：宽字符串\n\n<!--end: 2022.03.09-->\n\n<!--start: 2022.03.10-->\n\n## STL string类\n\n+ #include<string>\n+ std::string 具体化的是std::basic_string模板类\n\n### 实例化string\n\n```cpp\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvoid print(const string& str,const string& s)\n{\n    cout<<s<<\": \"<<str<<endl;\n}\n\nint main()\n{\n    string str0;        //生成空字符串str\n    string str1 = \"Hello String!\";\n    const char* Cstr = \"Hello Char*\";\n    string str2(str1,6);  //从\"索引为5\"的位置开始拷贝\n    string str3(Cstr,5);  //将C字符串前5个字符作为字符串s的初值。\n\tstring str4(\"Hello String!\",5);\n    string str5(10,'a');  //生成一个字符串，包含n个c字符\n    string str6(str1,0,5);//将字符串str内“始于index且长度顶多n”的部分作为字符串的初值\n    string str7(str5.begin(),str5.begin()+5);\n\t\n\tprint(str0,\"str0\");\n    print(str1,\"str1\");\n    print(str2,\"str2\");\n    print(str3,\"str3\");\n    print(str4,\"str4\");\n    print(str5,\"str5\");\n\tprint(str6,\"str6\");\n    print(str7,\"str7\");\n    \n\t/*输出\n\tstr0: \n\tstr1: Hello String!\n\tstr2: String!\n\tstr3: Hello\n\tstr4: Hello\n\tstr5: aaaaaaaaaa\n\tstr6: Hello\n\tstr7: aaaaa\n\t*/\n    return 0;\n}\n```\n\n### string增删改查\n\n```cpp\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n//遍历获取元素\nvoid display()\n{\n    //size(),length()  //返回字符数量\n    string str(\"hello world!\");\n    //size_t 作为unsigned int 和unsigned long 的别名,编译器根据不同的系统类型替换标准类型,旨在增强移植性\n    for(size_t i = 0; i < str.length(); ++i)\n    {\n        cout<<\"str[\"<<i<<\"]: \"<<str[i]<<endl;\n    }\n    cout<<endl;\n    \n    //逆序迭代器方式\n    for(auto t = str.rbegin(); t != str.rend(); ++t)\n    {\n        cout<<*t<<\",\";\n    }\n    cout<<endl;\n    \n    cout<<str.c_str()<<endl;//将内容以C_string返回\n}\n\n//拼接字符串\nvoid append()\n{\n    //+=,append()\n    //push_back() //在尾部添加字符\n    string str1(\"Hello World!\");\n    string str2(\"Hello Programer!\");\n    \n    str1 += str2;  //+=\n    cout<<\" str1 += str2, str1: \"<<str1<<endl; \n    \n    str1.append(str2); //append()\n    cout<<\" str1.append(str2)2, str1: \"<<str1<<endl;\n    \n    str2.push_back('?');\n    cout<<\" str2.push_back('?'), str2: \"<<str2<<endl;  //push_back()在末尾添加字符\n}\n\n//查找字符(串)\nvoid find()\n{\n    string s(\"dog bird chicken bird cat\");\n    \n    cout <<\ts.find(\"bird\") << endl;  //查找子串s,返回找到的位置索引，\n\tcout << (int)s.find(\"pig\") << endl;   //-1表示查找不到子串\n\n\tcout << s.rfind(\"bird\") << endl; //反向查找子串s，返回找到的位置索引，\n\tcout << s.rfind('i') << endl;    \n\n\tcout << s.find_first_of(\"13r98\") << endl; //查找第个属于某子串的字符\n\tcout << s.find_first_not_of(\"dog bird 2006\") << endl;//查找第一个不属于某字符串的字符\n    \n}\n//删除\nvoid erase()\n{\n    string s(\"123456789abcd!\");\n    //iterator erase(iterator p);//删除字符串中p所指的字符\n    s.erase(s.begin());\n    cout << s << endl;  //out: 23456789abcd!\n    //iterator erase(iterator first, iterator last);//删除字符串中迭代器区间[first,last)上所有字符\n    s.erase(s.begin()+2,s.begin()+3);\n    cout << s << endl; //out: 2356789abcd!\n    //string& erase(size_t pos = 0, size_t len = npos);//删除字符串中从索引位置pos开始的len个字符\n    s.erase(0,2);\n    cout << s << endl; //out: 56789abcd!\n    //void clear();//删除字符串中所有字符\n    s.clear();\n    cout << s << endl;\n}\n\n//比较\nvoid compare()\n{\n    string s1(\"abcdef\"), s2(\"abc\");\n    \n    //相等返回0，大于返回 正数，小于返回  负数\n    cout << s1.compare(\"abcdef\") << endl;  //相等,打印0\n\tcout << s1.compare(s2) << endl;   //s1 > s2,打印 >0\n\tcout << s1.compare(\"abyz\") << endl; //s1 < \"abyz\",打印 <0\n\tcout << s1.compare(0,3,s2) << endl; //s1的前3个字符**s2,打印0\n}\n\n//反转算法\n//需要 头文件是#include <algorithm>\nvoid reverse()\n{\n    string str(\"hello string!\");\n    cout<<\"str: \"<<str<<endl;\n    reverse(str.begin(),str.end());\n    cout<<\"reverse str: \"<<str<<endl;\n}\n\nint main()\n{\n    //display();\n    //append();\n    //erase();\n    find();\n    compare();\n    reverse();\n    \n    return 0;\n}\n```\n\n## STL vector类\n\n+ 需包含头文件`#include <vector>`\n\n### 实例化vector\n\n```cpp\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<int> intArray;  //默认构造\n    \n    vector<float> floatArray{20.4, 15.9}; //初始化两个元素的值\n    \n    vector<int> intArray2(10); //初始化包含10个元素\n    \n    vector<int> intArray3(10, 1);//初始化包含10个元素,且值都为1\n    \n    vector<int> intArray4(intArray3); //使用一个实例初始化\n    return 0;\n}\n```\n\n### vector增删改查\n\n```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n//遍历\nvoid  traverse()\n{\n    vector<int> temp{10,12,14,16};\n    \n    for(auto t : temp)\n    {\n        cout<<t<<\" \";\n    }\n    cout<<endl;\n    \n    cout<<\"temp[3]: \"<<temp[3]<<endl; //注意 索引不能越界\n    cout<<\"temp[2]: \"<<temp.at(2)<<endl; //at()在运行阶段执行检查  更安全\n}\nvoid  traverse(const vector<int>& temp)\n{\n    cout<<\"size = \"<<temp.size()<<\": \";\n    for(auto t : temp)\n    {\n        cout<<t<<\" \";\n    }\n    cout<<endl;\n}\n//插入、删除\nvoid insert()\n{\n    vector<int> integers;\n    \n    //push_back()在末尾添加元素,首选\n    integers.push_back(1);\n    integers.push_back(2);\n    traverse(integers);\n    \n    //insert()在指定位置插入元素,效率低\n    integers.insert(integers.begin()+1, 25); //在第一个元素后面插入25\n    integers.insert(integers.end(),2,45);  //在数组末尾插入2个元素,值都为45\n    traverse(integers);\n    \n    vector<int> temp = {15,16};\n    integers.insert(integers.begin(), temp.begin(), temp.end());//插入temp的值到数组开头\n    traverse(integers);\n    \n    //pop_back()从末尾删除元素\n    integers.pop_back();\n    traverse(integers);\n    \n    //清空元素\n    integers.clear();\n    traverse(integers);\n    \n    //判空\n    if(integers.empty())\n    {\n        cout<<\"The container is now empty!\"<<endl;\n    }\n}\n\n\nint main()\n{\n    traverse();\n    insert();\n    \n    return 0;\n    \n}\n```\n\n+ size()：实际存储的元素数；capacity()：总的容量。  数组的大小 $<=$ 容量。（如果数组进行了插入，vector需要重新分配内部缓冲区，**重新分配的逻辑实现是智能的：提前分配更多的容量**）。\n+ 重新分配内部缓冲区时，需要复制容器中包含的对象，这可能降低性能。\n\n### STL deque类\n\n+ 需包含`#include <deque>`\n+ 具有vector的所有性质。\n+ 使用`push_front`和`pop_front`在开头插入/删除元素。\n\n## STL list类\n\n+ 需包含`#include<list>`。\n+ 双向链表。\n+ 迭代器可以`++`或者`--`。\n+ 虽然STL提供了sort()和remove()两种算法，但是list也提供了这两种算法。这些算法的成员函数版本**确保元素的相对位置发生变化后指向元素的迭代器仍然有效。**\n\n### 实例化list\n\n```cpp\n#include<list>\n#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n    list<int> linkInts0;   //初始化空链表\n    \n    list<int> linkInts1(10); //初始化包含10个元素的list\n    \n    list<int> linkInts2(10,99);//包含10个元素，均为99\n    \n    list<int> linkInts3(linkInts2);//复制构造\n    \n    vector<int> vecInts(10,200);\n    list<int> linkInts4(vecInts.begin(),vecInts.end());//从vector对象中复制\n    \n    return 0;\n}\n```\n\n### list增删改查\n\n```cpp\n#include<list>\n#include<iostream>\n\nusing namespace std;\n\n\n//遍历\ntemplate<typename T>\nvoid display(const T& container)\n{\n    for(auto element = container.cbegin(); element != container.cend(); ++element)\n    {\n        cout<<*element<<\" \";\n    }\n    cout<<endl;\n   \n}\n//插入\nvoid insert()\n{\n    list<int> listInts;\n    \n    listInts.push_back(10);\n    listInts.push_back(20);\n    listInts.push_front(0);\n    display(listInts);\n    \n    //iterator insert(iterator pos, const T& x)\n    /*\n    既然是链表，其迭代器就无法进行加减运算，但可以自增自减\n    */\n    //listInts.insert(listInts.begin()+1, 5);// error: no match for ‘operator+’ (operand types are ‘std::_Fwd_list_iterator<int>’ and ‘int’)\n    listInts.insert(++listInts.begin(), 5); //(插入位置，值)\n    display(listInts);\n    //void insert(iterator pos, sizer_type n, const T& x)\n    listInts.insert(listInts.end(), 2, 0); //(插入位置，插入个数，值)\n    display(listInts);\n    /*template<class InputIterator>\n     void insert(iterator pos, InputIterator f, InputIterator l);\n    */\n    list<int> listInts1;\n    listInts1.insert(listInts1.begin(), listInts.begin(), listInts.end());\n    display(listInts1);\n}\n//删除\nvoid erase()\n{\n    list<int> listInts{0,10,20,30,40};\n    \n    listInts.erase(listInts.begin()); //删除\n    display(listInts);\n    \n    listInts.clear(); //清空\n}\n//反转、排序\nbool Sort_Desc(const int& t1, const int& t2)  //二元谓词，告诉sort如何解释小于。\n{\n    return (t1 > t2); \n}\nvoid sort()\n{\n    list<int> listInts{-20,20,10,100,40};\n    //反转\n    listInts.reverse();\n    display(listInts);\n    \n    //排序\n    //默认排序\n    listInts.sort();\n    display(listInts);\n    \n    //高级排序\n    listInts.sort(Sort_Desc);  //降序\n    display(listInts);\n}\n\nint main()\n{\n    sort();\n    return 0;\n}\n```\n\n+ 对包含对象的list进行排序\n  + 在list包含的对象所属类中，实现运算符<；\n  + 提供一个排序二元谓词。\n\n### STL forward_list(C++11)\n\n+ 单向链表\n+ 与list类似\n+ 插入元素不能使用`push_back`；而只能使用`push_front`。\n+ 对迭代器只能使用`++`，不能使用`--`。\n+ 相比list，占用的内存稍少，因为只需指向下一个元素，而无需指向上一个元素。\n\n<!--end: 2022.03.10-->\n\n<!--start: 2022.03.11-->\n\n## STL 集合类\n\n### set和multiset\n\n+ set存储唯一值，multiset可存储重复值。\n+ 需包含头文件`#include<set>`。\n+ 插入时就对元素进行排序（默认升序）。\n+ <font color=#ff0000>对频繁需要查找的应用程序来说，set和multiset很有优势。因为其内容是经过排序的（当然，插入时进行排序是需要额外开销的），查找速度更快。</font>时间复杂度为$ log(n)$。\n+ **如果用set等容器来存储自定义类的对象，务必要实现运算符`<`（排序谓词）和`**`（用于`std::find()`函数）。**\n\n#### 实例化\n\n```cpp\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n//创建二元排序谓词，可在类中定义一个operator()\ntemplate<typename T>\nstruce SortDescending   //降序\n{\n    bool operator()(const T& t1, const T& t2) const\n    {\n        return (t1 > t2);\n    }\n};\n\nint main()\n{\n    set<int> setInts1;\n    multiset<int> multisetInts1{10,20}; //使用默认的排序谓词：std::less<T>\n    multiset<int, less<int>> multisetInts2{30,10,20}; //升序：std::less<T>\n     multiset<int, greater<int>> multisetInts2{30,10,20}; //降序：std::greater<T>\n    set<int>::const_iterator element1;\n    multiset<int>::iterator element2;\n    \n    set<int, SortDescending<int>> setInts2;\n    \n    return 0;\n}\n```\n\n#### 增删查\n\n```cpp\n#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid display(const T& temp)\n{\n    for(auto element = temp.cbegin(); element != temp.cend(); ++element)\n    {\n        cout<<*element<<\" \";\n    }\n    cout<<endl;\n}\n\n//插入\nvoid insert()\n{\n    set<int> setInts{100,10,20,-20};\n    multiset<int> multisetInts{100,10,20,-20};\n    display(setInts);\n    display(multisetInts);\n    \n    setInts.insert(50);\n    setInts.insert(50);\n    multisetInts.insert(50);\n    multisetInts.insert(50);\n    display(setInts);\n    display(multisetInts);\n    //multisetInts.count(x)返回存储了值为x的元素个数\n    cout<<multisetInts.count(50)<<endl;\n    /*输出\n    -20 10 20 100 \n\t-20 10 20 100 \n\t-20 10 20 50 100 \n\t-20 10 20 50 50 100 \n\t2\n    */\n}\n\n//查找\nvoid find()\n{\n    set<string> setInts{\"100a\",\"10a\",\"20a\",\"-20a\"};\n  \n    auto elementFound = setInts.find(\"-20a\");\n    if(elementFound != setInts.cend())\n    {\n        cout<<*elementFound<<endl;\n    }\n    else\n    {\n\t\tcout<<\"Not Found\"<<endl;\n\t}\n}\n\n//删除\nvoid erase()\n{\n    multiset<int, greater<int>> multisetInts{43,75,75,12,-18};  //std::greater<T>降序排列的二元谓词\n    display(multisetInts);\n    \n    //根据值来删除\n    multisetInts.erase(75);  //删除值为78的所有元素\n    display(multisetInts);\n    \n    //根据迭代器来删除\n    auto elementFound = multisetInts.find(43);\n    if(elementFound != multisetInts.cend())\n    {\n         multisetInts.erase(elementFound);\n    }\n    display(multisetInts);\n    \n    multisetInts.clear();//清空\n}\n\n//set不能进行修改值\n\nint main()\n{\n    erase();\n    return 0;\n}\n```\n\n### unordered_set和unordered_multiset(C++11)\n\n+ 需包含头文件`#include <unordered_set>`。\n\n+ 基于散列的`set`。因此基本操作相同。\n\n+ `unordered_set`的一个重要特征是：<font color =#000fff >有一个负责确定排序顺序的散列函数。</font>\n\n  ```cpp\n  unordered_set<int> usetInt;\n  unordered_set<int>::hasher HFn = usetInt.hash_function();\n  ```\n\n+ <font color=#000fff>要决定选择使用`std::unordered_set`还是`std::set`，最好是在模拟环境中测试这两种容器的性能。</font>\n\n## STL 映射类\n\n### map和multimap\n\n+ 键值对容器。\n+ 需包含头文件`#include <map>`。\n+ `map`键值唯一，`multimap`键值可重复。\n+ 内部结构类似二叉树，在插入时排序，不能修改元素。\n+ multimap 不支持下标运算符，因为键并不能确定一个唯一元素。\n\n#### 实例化\n\n```cpp\nmap<keyType, valueType, Predicate = std::less<keyType>> mapObj;  //默认升序\nmultimap<keyType, valueType, Predicate = std::less<keyType>> multimapObj;\n```\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    map<int, string> map1;\n    map<int, string> map2(map1);\n    return 0;\n}\n```\n\n#### 增删查\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid display(const T& temp)\n{\n    for(auto element = temp.cbegin(); element != temp.cend(); ++element)\n    {\n        //first: 表示键  second: 表示值\n        cout<<element->first<<\"->\"<<element->second<<endl;\n    }\n    cout<<endl;\n}\n//插入\nvoid insert()\n{\n    map<int, string> map1({{0,\"zero\"}});\n    \n    map1.insert(make_pair(1,\"First\")); //使用make_pair()\n    display(map1);\n    map1.insert(pair<int, string>(2, \"Second\"));  //使用std::pair\n    display(map1);\n    \n    map1[10] = \"Ten\"; //使用数组语法：[]里面的是键。不同于map，multimap不能使用中括号[]法插入\n    display(map1);\n    \n    //上述方式同样适用multimap\n    multimap<int, string> multimap1(map1.cbegin(),map1.cend());\n    display(multimap1);\n    //multimap 不支持下标运算符，因为键并不能确定一个唯一元素。\n    //multimap1[10] = \"Double Ten\";//不同于map，multimap不能使用中括号[]法插入\n    multimap1.insert(pair<int, string>(10,\"Double Ten\"));\n    display(multimap1);\n    cout<<multimap1.count(10)<<endl; //返回指定键10有多少个元素\n    \n}\n\n//查找\nvoid find()\n{\n    map<int, string> map1({{0,\"zero\"},{1,\"first\"},{3,\"third\"}});\n    auto pairFound = map1.find(1);\n    //首先检查迭代器确保find()已成功\n    if(pairFound != map1.cend())\n    {\n        cout<<pairFound->first<<\"->\"<<pairFound->second<<endl;\n    }\n    else{\n        cout<<\"Not Found!\"<<endl;\n    }\n}\n\n//删除\nvoid erase()\n{\n    multimap<int, string> multimap1({{0,\"zero\"},{1,\"first\"},{1,\" double first\"},{3,\"third\"}});\n    display(multimap1);\n    \n    auto num = multimap1.erase(1);  //返回删除的元素数目  删除键为1的所有元素\n    display(multimap1);\n    \n    //根据迭代器来删除\n    auto elementFound = multimap1.find(0);\n    if(elementFound != multimap1.cend())\n    {\n         multimap1.erase(elementFound);\n    }\n    display(multimap1);\n    \n    multimap1.clear();//清空\n}\nint main()\n{\n    find();\n    return 0;\n}\n```\n\n### unordered_map和unordered_multimap(C++11)\n\n+ 基于散列表的map容器。\n+ 需包含头文件`#include <unordered_map>`。\n+ 在不发生冲突的情况下，平均插入/删除时间是固定的，查找时间也是固定的，不受包含元素数目的影响。\n\n## 函数对象\n\n<!--书上内容较少，没啥好看的-->\n\n> 函数对象（functor）：从概念上说，函数对象是用作函数的对象；但从实现上说，函数对象是实现了operator()的类的对象。\n\n### 一元函数\n\n> **一元函数**：接收一个参数的函数。如果其返回一个布尔值，则该函数称为**谓词**。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\n/*\n *一元函数\n */\ntemplate<typename T>\nvoid FuncDisplay(const T& element)\n{\n    cout << element <<' ';\n}\n\n//一元函数的另一种表现形式,即其包含在类或结构的operator()中\ntemplate<typename T>\nstruct StructDisplay   //这里用结构struct;如果用类class,需要指定为public。\n{\n    int count;\n    \n    StructDisplay():count(0){}\n    \n    void operator()(const T& element)\n    {\n        ++count;\n        cout << element <<' ';\n    }\n};\n\n//使用全局函数\nvoid ByFunc()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n    //STL for_each()\n    for_each(vecInts.begin(),vecInts.end(), FuncDisplay<int>);\n    \n}\n//使用结构: 由于可以包含成员，这就可以用来保存状态。\nvoid ByStruct()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n    \n    StructDisplay<int> result;\n    result = for_each(vecInts.begin(),vecInts.end(), StructDisplay<int>());\n    cout<<endl<<\"Functor invoked \"<<result.count<<\" times\"<<endl;\n    \n}  \n//使用lambda表达式\nvoid ByLambda()\n{\n    vector<int> vecInts{22,2017,-20,100,250,630};\n\n    for_each(vecInts.begin(),vecInts.end(),\n             [](int& element)\n             {\n                 cout<<element<<' ';\n             });\n}\nint main()\n{\n    ByFunc();\n\tcout<<endl<<endl;\n\tByStruct();\n    cout<<endl;\n    ByLambda();\n    return 0;\n}\n```\n\n\n\n### 二元函数\n\n> **二元函数**：接收两个参数的函数。如果其返回一个布尔值，则该函数称为**二元谓词**。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n\n//二元谓词\nclass StructDisplay   \n{\npublic：\n    //该二元谓词 将两个字符串转换为小写，再对其进行比较。用于字符串进行不区分大小写的排序。\n    bool operator()(const string& str1, const string& str2) const\n    {\n        string str1LowerCase;\n        str1LowerCase.resize(str1.size());\n        transform(str1.begin(), str1.end(), str1LowerCase.begin(), ::tolower);\n    \n        string str2LowerCase;\n        str2LowerCase.resize(str2.size());\n        transform(str2.begin(), str2.end(), str2LowerCase.begin(), ::tolower);\n    \n        return (str1LowerCase < str2LowerCase);\n    }\n};\n```\n\n## lambda表达式（C++11新增）\n\n> lambda表达式是一种定义匿名函数对象的简洁方式。\n\n### 定义lambda表达式\n\n> + 以方括号[]打头。（告诉编译器，接下来是一个lambda表达式）\n> + 方括号后面是一个参数列表，该参数列表与不使用lambda表达式时提供给operator()的参数列表相同。\n\n### 一元函数对应的lambda表达式\n\n```cpp\n[](Type paramName){//lambda expression}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//在算法for_each()中使用lambda表达式\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  for_each(nums.cbegin(), nums.cend(),\n           [](auto& element) { cout << element << \",\"; });\n  cout << endl;\n  return 0;\n}\n```\n\n### 一元谓词对应的lambda表达式\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//[](int& element){return ((element%2)==0);}//在element为偶数时\n//find_if()中使用，找到数组中的第一个偶数\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  auto evenNum = find_if(nums.cbegin(), nums.cend(),\n                         [](const int& element) { return ((element % 2) == 0); });\n  if (evenNum != nums.cend()) {\n    cout << *evenNum << endl;\n  }\n  return 0;\n}\n```\n\n> <font color=#ff0000>**务必使用const来限定输入参数，在输入参数为引用参数时尤其如此。这样可避免无意间修改容器中元素的值。**</font>\n\n### 通过捕获列表接受状态变量的lambda表达式\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//指定除数\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n  int divisor = 50;\n  auto evenNum = find_if(\n      nums.cbegin(), nums.cend(),\n      [divisor](const int& element) { return ((element % divisor) == 0); });\n  if (evenNum != nums.cend()) {\n    cout << *evenNum << endl;\n  }\n  return 0;\n}\n```\n\n> 一系列以状态变量的方式传递的参数（`[...]`）也被称为**lambda表达式的捕获列表**（capture list）。\n\n### lambda表达式的通用语法\n\n```cpp\n//接收多个状态变量的lambda表达式\n[stateVar1, stateVar2](Type& param){}\n//添加关键字mutable，可在lambda表达式中修改状态变量的值\n//修改只在lambda表达式内生效\n[stateVar1, stateVar2](Type& param) mutable{}\n//要保证修改的值在其外部也有效，需要按引用传递\n[stateVar1, &stateVar2](Type& param){}\n//向编译器明确指定返回类型，使用 ->\n//如果lambda表达式包含多行代码，就必须显式指定返回类型。\n[stateVar1, stateVar2](Type1& param1, Type2& param2)->ReturnType {return (value);}\n```\n\n### 二元函数对应的lambda表达式\n\n二元函数接收两个参数，还可返回一个值\n\n```cpp\n[...](Type1& param1, Type2& param2){}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//使用lambda表达式在std::transform()中实现元素相乘\nint main() {\n  vector<int> nums1{101, -4, 500, 21, 42, -1, -50};\n  vector<int> nums2{101, -4, 500, 21, 42, -1, -50};\n  vector<int> result;\n  result.resize(nums2.size());\n\n  transform(nums1.cbegin(), nums1.cend(), nums2.cbegin(), result.begin(),\n            [](int a, int b) { return a * b; });\n\n  for_each(nums1.cbegin(), nums1.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  for_each(nums2.cbegin(), nums2.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  for_each(result.cbegin(), result.cend(),\n           [](auto element) { cout << element << \",\"; });\n  cout << endl;\n  return 0;\n}\n```\n\n> 注：\n>\n> + **lambda表达式总是以[]或[...]打头。**\n> + **除非用mutable进行指定，否则不能修改捕获列表中指定的状态变量。**\n> + **当lambda表达式的语句块（{}）包含多条语句时，需要显式地指定返回类型。**\n> + **lambda表达式地使用旨在简洁高效。因此当其语句块较为复杂或者涉及重用时，应该转为使用函数对象。**\n\n## STL算法\n\n> + 头文件：`#include<algorithm>`\n\n### STL算法的分类\n\n> 分为两大类：**变序算法**和**非变序算法**。\n\n#### 非变序算法\n\n> 不改变容器中元素的顺序和内容的算法称为非变序算法。\n\n主要有：\n\n1. 计数算法 \n   + `count()`  \n   +  `count_if()` \n\n2. 搜索算法\n   + `search()`\n   + `search_n()`  \n   + `find()`\n   + `find_if()`\n   + `find_end()`      \n   + `find_first_of()` \n   + `adjacent_find()`\n\n3. 比较算法\n   + `equal()`\n   + `mismatch()` \n   + `lexicographical_compare()`\n\n#### 变序算法\n\n> 改变容器中元素的顺序或内容的算法称为变序算法。\n\n主要有：\n\n1. 初始化算法\n   + fill()\n   + fill_n()\n   + generate()\n   + generate_n()\n2. 修改算法\n   + for_each()\n   + transform()\n3. 复制算法\n   + copy()\n   + copy_backward()\n4. 删除算法\n   + remove()\n   + remove_if()\n   + remove_copy()\n   + remove_copy_if()\n   + unique()\n   + unique_copy()\n5. 替换算法\n   + replace()\n   + replace_if()\n6. 排序算法\n   + sort()\n   + stable_sort()\n   + partial_sort()\n   + partial_sort_copy()\n7. 分区算法\n   + partition()\n   + stable_partition()\n8. 可用于有序容器的算法\n   + binary_search()\n   + lower_bound()\n   + upper_bound()\n\n### 使用STL算法\n\n> 注：\n>\n> <font color=#ff0000>**如果STL算法返回的是一个迭代器，务必要对其进行检查，以保证其有效性。**</font>\n\n#### find() & find_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//函数对象:如果是奇数,返回true\ntemplate <typename T>\nbool specify_condition(const T& number) {\n  return ((number % 2) != 0);\n}\n\nint main() {\n  vector<int> nums{101, -4, 500, 21, 42, -1, -50};\n\n  //使用find()找到特定的值\n  int numToFind = 21;\n  auto element = find(nums.cbegin(), nums.cend(), numToFind);\n  if (element != nums.cend()) {\n    cout << \"vector容器中找到了值:\" << *element << endl;\n  } else {\n    cout << \"vector容器中找不到值:\" << numToFind << endl;\n  }\n\n  //使用find_if()找到满足指定条件的第一个值\n  auto element1 = find_if(nums.cbegin(), nums.cend(), specify_condition<int>);\n  if (element1 != nums.cend()) {\n    cout << \"vector容器中找到了满足特定条件的第一个值:\" << *element1 << endl;\n  } else {\n    cout << \"vector容器中找不到满足特定条件的值:\" << numToFind << endl;\n  }\n  return 0;\n}\n\n/*输出\nvector容器中找到了值:21\nvector容器中找到了满足特定条件的第一个值:101\n*/\n```\n\n#### count() & count_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//函数对象:如果是奇数,返回true\ntemplate <typename T>\nbool specify_condition(const T& number) {\n  return ((number % 2) != 0);\n}\n\nint main() {\n  vector<int> nums{101, -1, 500, 21, 42, -1, -50};\n\n  //使用count()对特定的值计数，返回计数值\n  int numToFind = -1;\n  size_t num = count(nums.cbegin(), nums.cend(), numToFind);\n  cout << \"vector容器中找到了值\" << numToFind << \"共\" << num << \"个\" << endl;\n\n  //使用count_if()对满足指定条件的值计数，返回计数值\n  num = count_if(nums.cbegin(), nums.cend(), specify_condition<int>);\n  cout << \"vector容器中找到了满足特定条件的值\"\n       << \"共\" << num << \"个\" << endl;\n  return 0;\n}\n\n/**输出\nvector容器中找到了值-1共2个\nvector容器中找到了满足特定条件的值共4个\n*/\n```\n\n#### fill() & fill_n()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid display(const T& number) {\n  cout << number << \",\";\n}\nint main() {\n  vector<int> nums(5);\n\n  //使用fill()填充指定范围内的元素为指定值\n  //输入:起始位置;终止位置;指定的值\n  fill(nums.begin(), nums.begin() + 2, 10); //这里不能使用常量迭代器,因为要修改容器中元素的值\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  //使用fill_n()填充指定个数的元素为指定值\n  //输入：起始位置；指定个数；指定的值\n  fill_n(nums.begin() + 2, 3, 9);\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  return 0;\n}\n\n/**输出\n10,10,0,0,0,\n10,10,9,9,9,\n*/\n```\n\n#### generate() & generate_n()\n\n```cpp\n#include <algorithm>\n#include <ctime>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid display(const T& number) {\n  cout << number << \",\";\n}\n\nint main() {\n  vector<int> nums(5);\n\n  srand(time(NULL));\n\n  //使用fill()填充指定范围内的元素为一元函数返回的值\n  //输入:起始位置;终止位置;指定条件\n  generate(nums.begin(), nums.begin() + 2, rand);  // rand为随机数生成器\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  //使用fill_n()填充指定个数的元素为一元函数返回的值\n  //输入:起始位置;指定个数;指定条件\n  generate_n(nums.begin() + 2, 5, rand);\n  for_each(nums.cbegin(), nums.cend(), display<int>);\n  cout << endl;\n  return 0;\n}\n\n/**输出\n19362,17346,0,0,0,\n19362,17346,11224,31780,17349,\n*/\n```\n\n#### for_each()\n\n> 对指定范围内的每个元素执行指定的一元函数对象\n\n#### transform()\n\n> + 和for_each()很像,都对源范围内的每个元素调用指定的函数对象,包括两个版本。\n> + **第一个版本接收一元函数，常用于字符串转换大小写（使用toupper()或tolower()）。**\n> + **第二个版本接收二元函数，让transform()能够处理一对来自两个不同范围的元素(用于加减乘除)。**\n\n```cpp\n#include <algorithm>\n#include <deque>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n  string str(\"This is a test string!\");\n  string strToUpper;\n  strToUpper.resize(str.size());\n  //将字符串转换为大写\n  //输入:原字符串起始位置;原字符串终止位置;目标字符串起始位置;一元函数对象\n  transform(str.cbegin(), str.cend(), strToUpper.begin(), ::toupper);\n  cout << strToUpper << endl;\n\n  vector<int> nums1{1, 2, 3, 4, 5, 6};\n  vector<int> nums2(nums1.size(), 10);\n  deque<int> productInList(nums1.size());\n  //将两个等大小的vector元素对应相乘\n  //容器1起始位置;容器1终止位置;容器2起始位置;目标容器起始位置;二元函数对象\n  transform(nums1.cbegin(), nums1.cend(), nums2.cbegin(), productInList.begin(),\n            [](int a, int b) { return a * b; });\n\n  for (size_t i = 0; i < nums1.size(); i++) {\n    cout << i << \"\\t\" << nums1[i] << \" * \" << nums2[i] << \" = \"\n         << productInList[i] << endl;\n  }\n  return 0;\n}\n\n/**输出\nTHIS IS A TEST STRING!\n0\t1 * 10 = 10\n1\t2 * 10 = 20\n2\t3 * 10 = 30\n3\t4 * 10 = 40\n4\t5 * 10 = 50\n5\t6 * 10 = 60\n*/\n```\n\n> 上述例子，通过两个vector容器相加赋给到deque容器中。表明：通过使用迭代器，可将容器及其实现同STL算法分离（STL算法无需知道容器的具体细节）。\n\n#### copy() & copy_if() & remove() & remove_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T& container) {\n  for (auto element = container.cbegin(); element != container.cend();\n       ++element) {\n    cout << *element << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  list<int> numsList1{10, 2020, 0, 2017, -15, -14, 0, 58, 1};\n  list<int> numsList2(numsList1.size(), 21);\n  Display(numsList1);\n  Display(numsList2);\n  vector<int> numsVector(numsList1.size() * 2);//设置为上述容器的2倍\n  //将numsList2的值复制到numsVector中，返回一个迭代器\n  auto lastElement =\n      copy(numsList2.cbegin(), numsList2.cend(), numsVector.begin());\n  //将numsList1中的偶数值复制到numsVector中，从上面返回的位置开始复制。\n  copy_if(numsList1.cbegin(), numsList1.cend(), lastElement,\n          [](int element) { return ((element % 2) == 0); });\n  Display(numsVector);\n    \n  //删除numsVector中的0\n  auto newEnd = remove(numsVector.begin(), numsVector.end(), 0);\n  numsVector.erase(newEnd, numsVector.end()); //调整容器大小\n  Display(numsVector);\n  //删除numsVector中的奇数\n  newEnd = remove_if(numsVector.begin(), numsVector.end(),\n                     [](int element) { return ((element % 2) == 1); });\n  numsVector.erase(newEnd, numsVector.end());\n  Display(numsVector);\n\n  return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -14 0 58 1 \n21 21 21 21 21 21 21 21 21 \n21 21 21 21 21 21 21 21 21 10 2020 0 -14 0 58 0 0 0 \n21 21 21 21 21 21 21 21 21 10 2020 -14 58 \n10 2020 -14 58 \n*/\n```\n\n#### replace() & replace_if()\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    list<int> numsList1{10, 2020, 0, 2017, -15, -14, 0, 58, 1};\n    list<int> numsList2{10, 11, 20, 21, 30, 31};\n    Display(numsList1);\n    Display(numsList2);\n    cout << endl;\n    //replace()根据比较运算符==的返回值来替换元素\n    //输入:集合的起始位置;集合的终止位置;要替换的值;替换成的值\n    replace(numsList1.begin(), numsList1.end(), 0, -1);\n    Display(numsList1);\n    \n    //replace_if()接收一个一元谓词,替换满足其条件的值\n    //输入:集合的起始位置;集合的终止位置;一元谓词;替换成的值\n    replace_if(\n        numsList2.begin(), numsList2.end(), [](int a)\n        { return (a % 2) == 0; },\n        -1);\n    Display(numsList2);\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -14 0 58 1 \n10 11 20 21 30 31 \n\n10 2020 -1 2017 -15 -14 -1 58 1 \n-1 11 -1 21 -1 31 \n*/\n```\n\n#### sort() & resize() & binary_search()\n\n1. sort()：排序\n\n> + stable_sort()与sort()一样，只不过它是稳定的，这相对于sort()就降低了性能，使用时需要权衡考虑。\n> + sort()不要用于list容器。sort()接受的输入迭代器是随机访问迭代器，但是双向list链表容器的访问方式是双向迭代器，因此，不能使用STL本身的排序算法sort()。可使用list自己的成员方法sort()。\n\n```cpp\n//默认使用std::less<>,即默认为升序排序\nsort(nums.begin(),nums.end());\n//可以使用二元谓词指定排序方式\nsort(nums.begin(),nums.end(),[](int a, int b){return (a > b);});//实现降序排序\n```\n\n2. unique()：删除相邻重复元素\n\n> + **只能删除相邻的重复元素**。\n> + 因此为了达到去重的效果，应该先进行排序，再使用unique()。\n\n```cpp\nauto newEnd = unique(nums.begin(),nums.end());\nnums.erase(newEnd,nums.end()); //to resize\n```\n\n3. binary_search()\n\n> binary_search()它只能用于**有序的容器**，实现快速查找。（如果用于未经排序的容器，结果不可知。）\n\n```cpp\nbool elementFound = binary_search(nums.cbegin(),nums.cend(),2001);\nif(elementFound)\n{\n    cout<<\"Element found in the vector!\"<<endl;\n}\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> numsList1{10, 2020, 0, 2017, -15, -15, 0, 58, 10};\n    Display(numsList1);\n    cout << endl;\n\n    //升序排序\n    sort(numsList1.begin(), numsList1.end());\n    Display(numsList1);\n    cout << endl;\n    \n    //快速查找\n    bool elementFound = binary_search(numsList1.cbegin(), numsList1.cend(), 2011);\n    if (elementFound)\n    {\n        cout << \"Element was found in the vector!\" << endl;\n    }\n    else\n    {\n        cout << \"Element not found!\" << endl;\n    }\n    cout << endl;\n    \n    //去重\n    auto newEnd = unique(numsList1.begin(), numsList1.end());\n    numsList1.erase(newEnd, numsList1.end());\n    Display(numsList1);\n\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -15 -15 0 58 10 \n\n-15 -15 0 0 10 10 58 2017 2020 \n\nElement not found!\n\n-15 0 10 58 2017 2020 \n*/\n```\n\n#### partition()\n\n> + partition()将范围分区，不稳定的。\n>\n>   ```cpp\n>   //输入：容器起始位置；容器终止位置；一元谓词\n>   partition(numsList1.begin(), numsList1.end(),[](int a){return a<0;});\n>   ```\n>\n> + stable_partition()是稳定的。但为了保证相对顺序不变，性能有所降低。\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nvoid Display(const T &container)\n{\n    for (auto element = container.cbegin(); element != container.cend();\n         ++element)\n    {\n        cout << *element << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> numsList1{10, 2020, 0, 2017, -14, -15, 0, -58, 10};\n    vector<int> numsList2(numsList1);\n    Display(numsList1);\n    cout << endl;\n\n    //非稳定分区\n    //分为负数和非负数\n    partition(numsList1.begin(), numsList1.end(), [](int b)\n              { return b < 0; });\n    Display(numsList1);\n    cout << endl;\n\n    //稳定分区\n    stable_partition(numsList2.begin(), numsList2.end(), [](int b)\n                     { return b < 0; });\n    Display(numsList2);\n    cout << endl;\n    return 0;\n}\n\n/**输出\n10 2020 0 2017 -14 -15 0 -58 10 \n\n-58 -15 -14 2017 0 2020 0 10 10 \n\n-14 -15 -58 10 2020 0 2017 0 10 \n*/\n```\n\n#### lower_bound() & upper_bound()\n\n> + 向有序容器中插入元素\n\n```cpp\n//都返回一个迭代器，分别指向在不破坏现有顺序的情况下，元素可插入到有序容器中的最前位置和最后位置。\nauto minInsertPos = lower_bound(nums.begin(),nums.end(),21);\nauto maxInsertPos = upper_bound(nums.begin(),nums.end(),21);\n```\n\n### 总结\n\n> 1. **使用`remove()`，`remove_if()`，`unique()`算法删除元素后，务必使用容器的成员方法erase()调整容器的大小。**\n> 2. **使用`unique()`算法，务必在使用前进行排序，保证重复元素彼此相邻。**\n> 3. **使用`find()`，`find_if()`，`search()`，`search_n`算法返回的迭代器之前，务必将其与容器的`end()`进行比较，保证有效。**\n> 4. **仅当元素的相对顺序重要时，才使用`stable_sort()`，`stable_partition()`。**\n> 5. **`binary_search()`只能用于有序容器。**\n> 6. **对于有序容器，需要进行插入时，应使用`lower_bound()`，`upper_bound()`，保证插入后容器仍然是有序的。**\n\n## 自适应容器：栈和队列\n\n### 栈\n\n> + LIFO(后入先出)，从栈顶删除/插入元素。“后来居上”\n>\n> + 泛型容器`std::stack`\n>\n> + 头文件`#include<stack>`\n>\n> + stack内部是默认yongstd::deque来实现的。\n>\n>   ```cpp\n>   template<\n>      class elementType,\n>      class Container=deque<Type>\n>   >class stack;\n>   ```\n>\n> + stack改变了其内部实现容器的行为，通过限制元素插入或者删除的方式实现其功能，从而提供严格遵守栈机制的行为特征。\n\n#### std::stack实例化\n\n```cpp\n#include <stack>\n#include <vector>\nint main()\n{\n    using namespace std;\n    //实例化整型栈\n    stack<int> numsInStack;\n    //在内部改用std::vector来存储数据，默认是std::deque\n    stack<double, vector<double>> doubleStackedInVec;\n    //拷贝构造\n    stack<int> numsInStackCopy(numsInStack);\n}\n```\n\n#### std::stack的成员函数\n\n```cpp\npush() //在栈顶插入元素\npop()  //删除栈顶元素\nempty()//检查栈是否为空并返回true/false\nsize() //返回栈的大小\ntop()  //获取指向栈顶元素的引用\n```\n\n### 队列\n\n> + FIFO(先入先出)，在末尾插入元素，在开头删除元素。\n>\n> + `std::queue`\n>\n> + 头文件`#include<queue>`\n>\n> + 定义\n>\n>   ```cpp\n>   template<\n>      class elementType,\n>      class Container=deque<Type>\n>   >class queue;\n>   ```\n\n#### std::queue实例化\n\n```cpp\n#include <queue>\n#include <list>\n\nvoid main()\n{\n    std::queue<double> doubleInQueue;\n    \n    std::queue<double,list<double>> doubleInQueueInList;\n    \n    std::queue<double> doubleInQueueCopy(doubleInQueue);\n}\n```\n\n#### std::queue的成员函数\n\n```cpp\npush()   //在队尾插入元素\npop()    //在队头删除元素\nfront()  //返回指向队头元素的引用\nback()   //返回指向队尾元素的引用\nempty()  //检查队列是否为空，返回true/false\nsize()   //返回队列中的元素数\n```\n\n### 优先级队列\n\n> + `STL::priority_queue`\n> + 头文件`#include<queue>`\n>\n> + 与`queue`的区别在于：优先级最高的元素位于队首，且只能在队首执行操作。\n>\n> + 定义：\n>\n>   ```cpp\n>   template<\n>      class elementType,   //指定元素类型\n>      class Container=vector<Type>,  //指定内部的存储容器\n>      class Compare=less<typename Container::value_type>  //指定二元谓词，默认使用std::less\n>   >class priority_queue;\n>   ```\n>\n>   \n\n#### std::priority_queue实例化\n\n```cpp\n#include <queue>\n#include <list>\n#include <functional>  //为了使用std::greate<>r\n\nvoid main()\n{\n    std::priority_queue<double> doubleInPQ;\n    \n    //std::greater使得最小的元素位于队首\n    std::queue<int,deque<int>,std::greater<int>> doubleInQueueInList;\n    \n    std::queue<double> doubleInPQCopy(doubleInPQ);\n}\n```\n\n#### std::priority_queue的成员函数\n\n```cpp\npush()   //插入一个元素\npop()    //删除队首元素\ntop()    //返回队首元素的引用\nempty()  //检查队列是否为空，返回true/false\nsize()   //返回队列中的元素数\n```\n\n## STL位标志\n\n### bitset类\n\n> + `std::bitset`\n> + 头文件`#include<bitset>`\n> + 用于处理以位和位标志表示的信息。它不是容器类（因为不能调整长度）。它针对处理长度在编译阶段已知的位序列进行了优化。\n> + 元素只能为0、1。\n\n#### std::bitset实例化\n\n```cpp\n//初始化位数为4，值为0000\nbitset<4> fourBits;\n//用字符串字面量的位序列初始化\nbitset<5> fiveBits(\"10101\");\n//拷贝构造\nbitset<5> fiveBitsCopy(fiveBits);\n//用十进制初始化,11111111（C++14新增）还可使用0b11111111\nbitset<8> eightBits(255);\n```\n\n> **位数在编译阶段已指定，不能动态改变。**\n\n#### std::bitset运算符\n\n```cpp\n#include <bitset>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    bitset<4> Bits1(7);\n    bitset<4> Bits2(8);\n\n    /*运算符*/\n    //<< : 输出\n    cout << \"Bits1:\" << Bits1 << endl;\n    cout << \"Bits2:\" << Bits2 << endl;\n    //按位与&\n    bitset<4> result(Bits1 & Bits2);\n    cout << \"Bits1 & Bits2:\" << result << endl;\n    //按位或|\n    result = Bits1 | Bits2;\n    cout << \"Bits1 | Bits2:\" << result << endl;\n    //按位异或^\n    result = Bits1 ^ Bits2;\n    cout << \"Bits1 ^ Bits2:\" << result << endl;\n    //按位取反~\n    result = ~Bits1;\n    cout << \"~Bits1:\" << result << endl;\n    //按位右移>>=\n    Bits1 >>= 2;\n    cout << \"Bits1>>=2:\" << Bits1 << endl;\n    //按位左移<<=\n    Bits1 <<= 2;\n    cout << \"Bits1<<=2:\" << Bits1 << endl;\n    //通过下标访问\n    Bits1[1] = 0;\n    cout << \"Bits[1]:\" << Bits1[1] << endl;\n\n    return 0;\n}\n\n/**输出\nBits1:0111\nBits2:1000\nBits1 & Bits2:0000\nBits1 | Bits2:1111\nBits1 ^ Bits2:1111\n~Bits1:1000\nBits1>>=2:0001\nBits1<<=2:0100\nBits[1]:0\n*/\n```\n\n#### std::bitset成员方法\n\n```cpp\nset();      //序列中的所有位设置为1\nset(N, 0);  //设置第N+1位为0\nreset();    //重置为0\nreset(N);   //第N+1为重置为0\nflip();     //所有位取反\nsize();     //返回位数\ncount();    //返回值为1的位数\n```\n\n```cpp\n#include <bitset>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    bitset<4> Bits;\n    cout << \"Bits:\" << Bits << endl;\n\n    Bits.set();\n    cout << \"Bits:\" << Bits << endl;\n    Bits.set(3, 0);\n    cout << \"Bits:\" << Bits << endl;\n    Bits.reset(0);\n    cout << \"Bits:\" << Bits << endl;\n    Bits.flip();\n    cout << \"Bits:\" << Bits << endl;\n    cout << \"Bits.count():\" << Bits.count() << endl;\n    cout << \"Bits.size():\" << Bits.size() << endl;\n    Bits.reset();\n    cout << \"Bits:\" << Bits << endl;\n\n    return 0;\n}\n\n/**输出\nBits:0000\nBits:1111\nBits:0111\nBits:0110\nBits:1001\nBits.count():2\nBits.size():4\nBits:0000\n*/\n```\n\n### vector<bool\\>\n\n> + 克服bitset类不能动态调整长度的缺点。可动态调整长度。\n> + 作为对`std::vector`的部分具体化，用于存储布尔数据。\n> + 头文件`#include<vector>`。\n\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid display(vector<bool> bools)\n{\n    for (size_t i = 0; i < bools.size(); i++)\n    {\n        cout << bools[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    //默认初始化为0\n    vector<bool> boolFlags1(4);\n    display(boolFlags1);\n    //构造包含10个元素,值为1(true)\n    vector<bool> boolFlags2(4, 1);\n    display(boolFlags2);\n    //列表初始化\n    vector<bool> boolFlags3{true, false, false, true};\n    display(boolFlags3);\n    //插入元素\n    boolFlags3.push_back(true);\n    display(boolFlags3);\n    //取反\n    boolFlags3.flip();\n    display(boolFlags3);\n    return 0;\n}\n\n/**输出\n0 0 0 0 \n1 1 1 1\n1 0 0 1\n1 0 0 1 1\n0 1 1 0 0\n*/\n```\n\n## 智能指针\n\n> + 简单来说，C++智能指针是包含重载运算符的类，其行为像常规指针，但智能指针能够及时、妥善地销毁动态分配的数据，并实现了明确的对象生命周期，因此更有价值。\n>\n> + 常规指针存在的问题：动态分配的对象没有正确地释放导致<font color=#ff0000>**内存泄漏**</font>。\n> + 智能指针类重载了解除引用运算符(*)和成员选择运算符(_>)，让程序员可以像使用常规指针那样使用它们。\n\n### 智能指针类型\n\n> 智能指针的分类实际上就是内存资源管理策略的分类，可分为：\n>\n> + 深拷贝\n> + 写时拷贝（Copy on Write, COW）\n> + 引用计数\n> + 引用链接\n> + 破坏性拷贝\n\n#### 深拷贝\n\n> + 在实现深拷贝的智能指针中，每个智能指针实例都保存一个它管理的对象的完整副本。\n> + 性能有所欠缺。\n\n#### 写时拷贝机制\n\n> + COW试图对深拷贝智能指针的性能进行优化。它共享指针，直到首次写入对象。\n\n#### 引用计数智能指针\n\n> + 引用计数是一种记录对象的用户数量的机制。当计数降低到0时，便将对象释放。\n> + 这种智能指针被复制时，需要将对象的引用计数加1。有两种常用方法来跟踪计数：\n>   + 在对象中维护引用计数。（修改对象以维护和递增引用计数，并将其提供给管理对象的智能指针。）\n>   + 引用计数由共享对象中的指针类维护。（智能指针类将计数保存在自由存储区，拷贝是拷贝构造函数将这个值加1。）\n> + 使用引用计数机制，只应通过智能指针来处理对象。\n> + 如果两个对象分别存储指向对方的指针，这两个对象永远不会被释放，因为他们的生命周期依赖性导致其引用计数最少为1。\n\n#### 引用链接智能指针\n\n> + 它不主动维护对象的引用计数，而只需知道计数什么时候变为0，以便能够释放对象。\n> + 其实现基于双向链表，通过拷贝智能指针来创建新智能指针时，新指针将被插入到链表中。\n> + 与引用计数一样，也存在生命周期依赖性导致的问题。\n\n#### 破坏性拷贝\n\n> + 在智能指针被拷贝时，将对象的所有权转交给目标指针并重置原来的指针。\n> + 因为它可确保任何时刻只有一个活动指针指向对象。因此，它非常适合从函数返回指针以及需要利用其“破坏性”的情形。\n\n### std::unique_str\n\n> + C++11新增，同时摒弃auto_str（一种基于破坏性复制的智能指针）。\n> + 头文件`#include<memeory>`。\n> + 它的拷贝构造函数和赋值运算符是私有的，因此不能复制它，即不能进行值传递，只能按引用传递。\n\n## 文件和流\n\n(图源网络[C++流(读写文件)__Space_的博客](https://blog.csdn.net/qq_45140193/article/details/119789181))\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204120852048.png)\n\n### C++流类和流对象\n\n(图源网络[C++流(读写文件)__Space_的博客](https://blog.csdn.net/qq_45140193/article/details/119789181))\n\n![img](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204120854656.png)\n\n> + cin遇到空格停止，这时应当使用getline()。\n\n| 类/对象          | 用途                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| cout             | 标准输出流                                                   |\n| cin              | 标准输入流                                                   |\n| cerr             | 用于显示错误信息的标准输出流                                 |\n| fstream          | 用于操作文件的输入输出流，继承了ofstream和ifstream           |\n| ofstream         | 用于操作文件的输出流类，即用于写入文件                       |\n| ifstream         | 用于操作文件的输入流类，即用于读取文件                       |\n| stringstream     | 用于操作字符串的输入输出流，继承了istringstream和ostringstream，通常用于在字符串和其他类型之间进行转换 |\n|                  |                                                              |\n| 输出控制符       |                                                              |\n| endl             | 插入一个换行符                                               |\n| ends             | 插入一个空字符                                               |\n| 基数控制符       |                                                              |\n| dec              | 让流以十进制方式解释输入或显示输出                           |\n| hex              | 让流以十六进制方式解释输入或显示输出                         |\n| oct              | 让流以八进制方式解释输入或显示输出                           |\n| 浮点数表示控制符 |                                                              |\n| fixed            | 让流以定点表示法显示数据                                     |\n| scientific       | 让流以科学表示法显示数据                                     |\n| <iomanip\\>控制符 |                                                              |\n| setprecision     | 设置小数精度                                                 |\n| setw             | 设置字段宽度                                                 |\n| setfill          | 设置填充字符                                                 |\n| setbase          | 设置基数，等效于dec/hex/oct                                  |\n| setiosflag       | 通过类型为std::ios_base::fmtflags的掩码输入参数设置标志      |\n| resetiosflag     | 将std::ios_base::fmtflags参数指定的标志重置为默认值          |\n\n### 文件流的操作模式\n\n| 模式标志    | 描述                                                   |\n| :---------- | :----------------------------------------------------- |\n| ios::app    | 附加到现有文件末尾，而不是覆盖。                       |\n| ios::ate    | 文件打开后定位到文件末尾。                             |\n| ios::in     | 以只读方式打开文件                                     |\n| ios::out    | 以只写方式打开文件                                     |\n| ios::trunc  | 如果该文件已经存在，则将其覆盖，这是ofstream默认设置。 |\n| ios::binary | 创建二进制文件                                         |\n\n### 文件流的状态检查\n\n| 状态      | 描述                                    |\n| --------- | --------------------------------------- |\n| is_open() | 文件流是否打开成功                      |\n| eof()     | 流是否结束                              |\n| fail()    | 流的failbit或者badbit被置位时, 返回true |\n| bad()     | 流的badbit置位时, 返回true              |\n| good()    | 流处于有效状态时, 返回true              |\n| clear()   | 流的所有状态都被复位                    |\n\n### 文件流的定位\n\n#### seekg\n\n> + 关于 istream\n> + 用于设置输入流的位置\n>\n> ```cpp\n> //参数1：偏移量  参数2：相对位置\n> //对于参数2：beg 相对于开始位置；cur 相对于当前位置；end 相对于结束位置\n> seekg(off_type offset, ios::seekdir origin);\n> //seekg(50,infile.beg);//表示定位到从文件开始的第50个字符后\n> //seekg(-50,infile.end);//表示定位到最后50个字符\n> //seekg(0,infile.end);//定位到文件末尾\n> ```\n\n#### tellg\n\n> + 返回该输入流的当前位置（距离文件的起始位置的偏移量）。\n>\n> ```cpp\n> //获取文件的长度\n> infile.seekg(0,infile.end);\n> int len = infile.tellg();\n> ```\n\n\n\n#### seekp\n\n> + 关于 ostream\n> + 设置输出流的位置\n> + 参数同seekg\n\n### cin & cout\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int input = 10;\n    cout << \"input an integer:\";\n    cin >> input;\n    cout << \"integer in Octal:\" << oct << input << endl;\n    cout << \"integer in Hexadecimal:\" << hex << input << endl;\n\n    double PI = 3.1415926;\n    cout << \"PI = \" << PI << endl;\n    cout << \"PI = \" << setprecision(7) << PI << endl;\n    cout << \"PI = \" << scientific << PI << endl;\n    cout << \"PI = \" << fixed << PI << endl;\n\n    string str = \"Hello World!\";\n    cout << str << endl;\n    //设置字段宽度\n    cout << setw(20) << str << endl;\n    // setfill()设置用什么字符来填充空白区域\n    cout << setw(20) << setfill('*') << str << endl;\n\n    // cin遇到空格停止插入,要读取整行,需要使用getline()\n    cout << \"input a string by getline():\";\n    getline(cin, str);\n    cout << str << endl;\n    return 0;\n}\n```\n\n### std::fstream\n\n> + 头文件`#include<fstream>`\n\n#### 打开文件\n\n> + 使用`open()`函数。\n> + 使用构造函数。\n> + 使用`is_open()`检测`open()`是否成功。\n\n#### 关闭文件\n\n> + 文件打开后必须关闭，`close()`。\n\n\n\n### 文本文件读取/写入\n\n> 直接使用运算符`<<`，`>>`。\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nvoid outputData()\n{\n    string name(\"I am a small bird!\");\n    int age = 30;\n    //如果不包含路径,则表示在当前工作目录(和cpp文件的同级目录)\n    string filename = \"user.txt\";\n\n    // ofstream的默认打开方式是,截断式写入 ios::out|ios::trunc\n    // fstream的默认打开方式是, ios::out\n    //建议指定打开方式\n    //文件不存在则创建\n    ofstream outfile;\n    // outfile.open(filename);\n    outfile.open(filename, ios::out | ios::trunc);\n    \n    //判断文件打开成功\n    if (outfile.is_open())\n    {\n        outfile << \"name: \" << name << endl\n                << \"age: \" << age << endl;\n\n        outfile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nvoid inputData()\n{\n    string name;\n    string line;\n    int age;\n    //使用构造函数打开文件\n    string filename = \"user.txt\";\n    ifstream infile(filename, ios::in);\n\n    if (infile.is_open())\n    {\n        while (1)\n        {\n            getline(infile, line);\n            if (infile.eof())\n            {\n                break;\n            }\n            cout << line << endl;\n        }\n\n        infile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nint main()\n{\n    outputData();\n    inputData();\n    return 0;\n}\n```\n\n### 二进制文件读取/写入\n\n> + 使用`write()`，`read()`。\n> + 将要读写的数据转换为C风格的字符（串）进行输入/输出。\n> + **指定了打开模式ios::binary，文件才能以二进制的方式操作，否则将以ASCII方式(文本文件)打开。**\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\n//这里可以看到:使用二进制读写文件,需要将数据转换为C风格的字符或字符串\nvoid outputBinaryData()\n{\n    string name(\"I am a small bird!\");\n    int age = 30;\n    string filename = \"user.dat\";\n\n    ofstream outfile;\n    outfile.open(filename, ios::out | ios::trunc | ios::binary);\n\n    if (outfile.is_open())\n    {\n        outfile.write((char *)&age, sizeof(int));\n        outfile.write(name.c_str(), sizeof(char) * (name.size()));\n\n        outfile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nvoid inputBinaryData()\n{\n    char line[256] = {0};\n    int age;\n    //指定了打开模式ios::binary,文件才能以二进制的方式操作,否则将以ASCII方式(文本文件)打开\n    string filename = \"user.dat\";\n    ifstream infile(filename, ios::in | ios::binary);\n\n    if (infile.is_open())\n    {\n        infile.read((char *)&age, sizeof(int));\n        infile.read(line, sizeof(char) * 256);\n\n        cout << \"age:\" << age << endl;\n        cout << \"line:\" << line << endl;\n\n        infile.close();\n    }\n    else\n    {\n        cout << \"File open failed!\" << endl;\n    }\n}\n\nint main()\n{\n    outputBinaryData();\n    inputBinaryData();\n    return 0;\n}\n```\n\n### std::stringstream进行字符串转换\n\n> + 头文件`#include <sstream>`\n\n```cpp\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main()\n{\n    int input = 10;\n    int copy = 0;\n    string inputAsStr;\n    stringstream converterStream1;\n    converterStream1 << input;\n    converterStream1 >> inputAsStr;\n    stringstream converterStream2;\n    converterStream2 << inputAsStr;\n    converterStream2 >> copy;\n\n    // Integer <convert> String\n    cout << \"Integer Input = \" << input << endl;\n    cout << \"String gained from integer = \" << inputAsStr << endl;\n    cout << \"Integer gained from String, copy = \" << copy << endl;\n    return 0;\n}\n\n/**输出\nInteger Input = 10\nString gained from integer = 10\nInteger gained from String, copy = 10\n*/\n```\n\n### 总结\n\n> + **只想读取文件时，务必使用`ifstream`。**\n> + **只想写入文件时，务必使用`ofstream`。**\n> + **打开文件时，务必使用`is_open`判断打开成功。**\n> + **打开文件后，务必使用`close()`进行关闭。**\n> + **使用`cin>>`进行输入字符串时，遇到空格停止，此时应使用`getline()`。**\n\n<!--end in 2022.04.11-->\n\n## 异常处理\n\n### 异常\n\n> + 异常会打断应用程序的正常流程。\n> + 异常处理就是应对打断程序流程的特殊情形。\n> + 异常可能是外部因素导致的，如系统没有足够的内存；也可能是应用程序内部因素导致的，如除数为0。\n\n### 使用try-catch捕获异常\n\n1. 可使用`catch(...)`处理所有异常。参数`...`意味着catch块捕获所有的异常。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    try\n    {\n        int input = -1;\n\n        int *array = new int[input];\n        delete[] array;\n    }\n    catch (...)\n    {\n        cout << \"Exception occurred!\" << endl;\n    }\n    return 0;\n}\n```\n\n2. 捕获特定类型的异常。\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    try\n    {\n        int input = -1;\n\n        int *array = new int[input];\n        delete[] array;\n    }\n    catch (std::bad_alloc &exp) //捕获并处理内存分配异常\n    {\n        std::cout << \"Exception encountered: \" << exp.what() << std::endl;\n    }\n    catch (...) //捕获除了上述异常的其他所有异常\n    {\n        std::cout << \"Exception encountered!\" << std::endl;\n    }\n    return 0;\n}\n```\n\n3. 使用`throw`引发自定义异常\n\n### std::exception类\n\n> + `std::exception`异常基类，头文件`#include<exception>`。\n> + 重要的异常类（都是从std::exception派生而来）\n>   + `bad_alloc`：使用`new`请求申请内存失败时引发。\n>   + `bad_cast`：试图使用`dynamic_cast`转换错误类型时引发。\n>   + `ios_base::failure`：由`iostream`库中的函数和方法引发。\n> + `std::exception`定义了虚方法`what()`，它详细描述了导致异常的原因。\n> + 可以使用`catch(const std::exception& exp)`捕获所有以它作为基类的异常。\n> + 可以从`std::exception`派生出自定义异常类。\n\n## 编写实践\n\n> + 给变量指定有意义的名称。\n> + 对于int，float等变量，务必进行初始化。\n> + 务必将指针初始化为NULL或有效的地址。\n> + 使用数组时，务必不要访问越界！\n> + 不要使用C风格的字符串缓冲区（char*）及其相关函数和方法，而是使用std::string！\n> + 仅当确定要包含的元素数时才使用静态数组，否则，应使用动态数组。\n> + 如果类包含原始指针成员，务必考虑编写复制构造函数和重载赋值运算符。\n> + 正确的使用const。\n> + 尽可能避免使用原始指针，而使用智能指针。\n> + 务必使用模板而不是宏。\n> + 如果lambda表达式过于复杂或者有重用需求，务必将其转为函数对象。\n> + 务必捕获并处理所有可能引发的异常，如内存分配失败等。\n> + 绝不要在析构函数中引发异常。\n\n<!--总结：离谱整整拖了一个月才把这本书看完，中间拖了有好几天没有看，中途还因为图书超期了，先把书还了再重新借回来。不过，总算是看完了（走出了C++的第一步，之前本科学的感觉学了个寂寞）。-->\n\n<!--Completed by GuoJin Lv, 2022.04.13-->\n\n"},{"title":"A5算法","url":"/hexo-blogs/2022/04/07/A5算法/","content":"\n## A5算法\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.04.07 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n+ A5是用于数据加密的。为了保护隐私，GSM网络上的所有空中传输都用称为A5的流密码进行加密。该算法有四个变体。\n+ A5/0是一种无操作密码，不对数据进行加密。\n+ A5/1是标准版本，是在20世纪80年代中期几个北约国家对该算法的强度发生争议后指定的。\n+ A5/2是一个弱化的版本，它被选择来处理对强密码的出口限制问题。\n+ A5/3是后来为3G网络（UMTS-GSM的继承者）添加的，是一种基于时钟密码的全新算法。\n\n### 算法步骤\n\n<img src=\"https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204020903100.png\" alt=\"A5/1\" style=\"zoom:150%;\" />\n\n1. A5/1算法使用3个**线性反馈移位寄存器，简称为LFSR**。三个寄存器的级数分别为19位、22位、23位。\n\n2. 每个回合步骤可以拆分为：反馈多项式（Feedback Polynomial），位移，取KEY，。\n\n   + <font color=#ff0000>**反馈多项式（Feedback Polynomial）**</font>\n\n     > LFSR进行位移的前置操作，具体可以分成两步：判定是否需要进行位移，判定新的充填的值。\n     >\n     > + **判定是否需要进行位移**\n     >\n     > > 这里使用的是**择多原则**，三个寄存器中选择三个钟控信号，级数19寄存器中的第8位，级数22寄存器、级数23寄存器中皆为第10位，两种二进制0、1，必定有0或1数量居多，居多的寄存器需要进行位移操作。\n     >\n     > + **判定新的充填的值**\n     >\n     > > 这里就需要使用**反馈多项式**。见上图。XOR后得到的值是填充到第0位的值。\n\n   + <font color=#ff0000>**位移**</font>\n\n     > 三个寄存器，由上一步的判定后进行位移（从低位到高位的左移），空出第0位用于填充反馈多项式得到的值。\n     >\n   + <font color=#ff0000>**取KEY**</font>\n\n     > 取三个寄存器的最后一位，也就是19位、22位、23位，进行XOR操作，得到的结果为这一轮Key的一位。\n\n### C++代码\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n/*定义三个LFSR*/\n//级数为19的R1\nvoid R1(bool r1[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r1[18] ^ r1[4] ^ r1[1] ^ r1[0];\n  bool temp = r1[18] ^ r1[17] ^ r1[16] ^ r1[13];\n  //低位像高位左移一位\n  for (size_t i = 18; i > 0; i--)\n  {\n    r1[i] = r1[i - 1];\n  }\n  //第0位填充temp\n  r1[0] = temp;\n}\n//级数为22的R2\nvoid R2(bool r2[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r2[21] ^ r2[0];\n  bool temp = r2[21] ^ r2[20];\n  //低位像高位左移一位\n  for (size_t i = 21; i > 0; i--)\n  {\n    r2[i] = r2[i - 1];\n  }\n  //第0位填充temp\n  r2[0] = temp;\n}\n//级数为23的R3\nvoid R3(bool r3[])\n{\n  //反馈多项式XOR得到的值\n  // bool temp = r3[22] ^ r3[15] ^ r3[1] ^ r3[0];\n  bool temp = r3[22] ^ r3[21] ^ r3[20] ^ r3[7];\n  //低位像高位左移一位\n  for (size_t i = 22; i > 0; i--)\n  {\n    r3[i] = r3[i - 1];\n  }\n  //第0位填充temp\n  r3[0] = temp;\n}\n/**\n * @description: 生成密钥流\n * @param {int} n 需要生成的密钥数\n * @return {*}\n */\nbool *generate_key_stream(size_t n, bool r1[], bool r2[], bool r3[])\n{\n  bool *key_stream = (bool *)malloc(n * sizeof(bool));\n\n  for (size_t i = 0; i < n; i++)\n  {\n    bool m = (r1[8] + r2[10] + r3[10] >= 2) ? 1 : 0;\n    if (r1[8] == m)\n    {\n      R1(r1);\n    }\n    if (r2[10] == m)\n    {\n      R2(r2);\n    }\n    if (r3[10] == m)\n    {\n      R3(r3);\n    }\n    bool key = r1[18] ^ r2[21] ^ r3[22];\n    key_stream[i] = key;\n  }\n\n  return key_stream;\n}\n\nvoid print_data(bool r[], int length)\n{\n  for (int i = 0; i < length; i++)\n  {\n    if (i != length - 1)\n    {\n      cout << r[i] << \",\";\n    }\n    else\n    {\n      cout << r[i];\n    }\n  }\n  cout << endl;\n}\n\nint main()\n{\n  bool r1[19] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n  bool r2[22] = {1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1};\n  bool r3[23] = {1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};\n\n  size_t num = 64; //需要获取的密钥流位数\n\n  print_data(r1, 19);\n  print_data(r2, 22);\n  print_data(r2, 23);\n  cout << endl;\n\n  bool *key_stream = generate_key_stream(num, r1, r2, r3);\n\n  print_data(key_stream, num);\n\n  cout << endl;\n  print_data(r1, 19);\n  print_data(r2, 22);\n  print_data(r2, 23);\n\n  return 0;\n}\n```\n\n### 疑问\n\n1. 关于图中的Characteristic Polynomial的具体用处?\n","tags":["C-plus-plus","A5/1"],"categories":["课程作业"]},{"title":"LSTM算法的C语言实现","url":"/hexo-blogs/2022/04/07/LSTM算法的C语言实现/","content":"\n# LSTM算法的C语言实现\n\n> {% timeline 更新时间线, blue %}\n>\n> <!-- timeline 2022-04-11 -->\n> 更新：参考《LSTM还没“死”！》\n> <!-- endtimeline -->\n>\n> <!-- timeline 2022-04-07 -->\n> 第一次提交<!--某师兄的毕设相关，因为曾经有过相关基础，被导师叫来帮师兄打工。-->\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## LSTM简介\n\n> + LSTM(<font color=#ff0000>Long Short-Term Memory Networks,长短时记忆网络</font>)，由Hochreiter和Schmidhuber于1997年提出，目的是解决一般循环神经网络中存在的梯度爆炸（输入信息激活后权重过小）及梯度消失（例如sigmoid、tanh的激活值在输入很大时其梯度趋于零）问题，主要通过引入门和Cell状态的概念来实现梯度的调整，已被大量应用于时间序列预测等深度学习领域。\n>\n> +　早在1997年，LSTM在论文 《LONG SHORT-TERM MEMORY 》中被提出，直到2014年才进入高速发展阶段。它们属于循环神经网络家族- RNN，以及门控循环单元GRU。\n> +　LSTM有两个缺点：首先LSTM不容易在训练过程中并行化；其次由于它们具有周期性，它们可以建模的序列长度是有限制的。\n\n## LSTM算法流程\n\nLSTM采用了门控输出的方式，即<font color=#ff0000>**三门（输入门、遗忘门、输出门）两态（Cell State长时、Hidden State短时）**</font>。结构图如下所示（图源[Understanding LSTM Networks](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)）。作为机器学习算法的一种，LSTM 的预测过程也分为正向传播和反向传播两个过程。\n\n![LSTM结构示意图](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202205300922952.png)\n\n### 正向传播过程\n\n#### 隐藏层\n\n如上图所示，一个LSTM单元应当包含的权值参数有：\n$$\nW_{fh},W_{fx},b_{f},W_{ih},W_{ix},b_{i},W_{ch},W_{cx},b_{c},W_{oh},W_{ox},b_{o}\n$$\n\n> + $W_{fh}$：遗忘门与短时记忆的权值向量。\n> + $W_{fx}$：遗忘门与特征输入的权值向量。\n> + $b_{f}$：遗忘门的偏置。\n> + $W_{ih}$：输入门与短时记忆的权值向量。\n> + $W_{ix}$：输入门与特征输入的权值向量。\n> + $b_{i}$：输入门的偏置\n> + $W_{ch}$：产生新记忆信息部分与短时记忆的权值向量。\n> + $W_{cx}$：产生新记忆信息部分与特征输入的权值向量。\n> + $b_{c}$：产生新记忆信息部分的偏置\n> + $W_{oh}$：输出门与短时记忆的权值向量。\n> + $W_{ox}$：输出门与特征输入的权值向量。\n> + $b_{0}$：输出门的偏置\n\n> 设：\n>\n> + 序列总长度为：$n$，$t=1,2,...,n-1,n$。\n> + $t$时刻的特征输入向量：$x_{t}$。\n> + $t-1$时刻的短时记忆（$t-1$时刻LSTM单元的输出值）：$h_{t-1}$。\n> + sigmoid激活函数：$\\sigma(x)=\\frac{1}{1+e^{-x}}$。\n> + tanh激活函数：$tanh(x)$。\n> + 对于第一个时刻$t=1$，前一个时刻的$h_{0}=0$，$C_{0}=0$。\n\n##### 遗忘门\n\n遗忘门接收$h_{t-1}$和$x_{t}$，得到要舍弃的信息$f_{t}$，公式为：\n$$\nF_{t}=W_{fh}h_{t-1}+W_{fx}x_{t}+b_{f} \\tag{1}\n$$\n\n\n$$\nf_{t}=\\sigma(F_{t}) \\tag{2}\n$$\n\n##### 输入门\n\n输入门可分为两个部分：输入门部分和产生新记忆信息部分。\n\n+ 接收$h_{t-1}$和$x_{t}$，得到要更新的信息$i_{t}$，公式为：\n\n\n$$\nI_{t}=W_{ih}h_{t-1}+W_{ix}x_{t}+b_{i} \\tag{3}\n$$\n\n\n$$\ni_{t}=\\sigma(I_{t}) \\tag{4}\n$$\n\n+ 以及得到新的记忆信息$\\widetilde{c}_{t}$（这里的$\\widetilde{c}_{t}$代表的是图中的$\\widetilde{C}_{t}$），公式为：\n\n\n$$\n\\widetilde{C}_{t}=W_{ch}h_{t-1}+W_{cx}x_{t}+b_{c} \\tag{5}\n$$\n\n\n$$\n\\widetilde{c}_{t}=\\tanh(\\widetilde{C}_{t}) \\tag{6}\n$$\n\n##### 长时记忆部分\n\n由遗忘门和记忆门的信息可以得到$t$时刻的（长时记忆）状态值，公式为：\n$$\n{C}_{t}={C}_{t-1}f_{t}+i_{t}\\widetilde{c}_{t} \\tag{7}\n$$\n\n##### 输出门\n\n输出门接收$h_{t-1}$和$x_{t}$，得到要输出的信息（这是一个中间版本）$o_{t}$，公式为：\n\n$$\nO_{t}=W_{oh}h_{t-1}+W_{ox}x_{t}+b_{o} \\tag{8}\n$$\n\n\n$$\no_{t}=\\sigma(O_{t}) \\tag{9}\n$$\n\n##### 短时记忆部分\n\n并再根据长时记忆值得到最终LSTM单元的输出值（短时记忆），公式为：\n$$\nh_{t}=tanh(C_{t})\\ast o_{t} \\tag{10}\n$$\n\n#### 输出层\n\n如果LSTM隐层与输出层之间是全连接的，并且采用sigmoid激活函数，得到预测输出$\\hat{y}_{t}$，那么公式为：\n$$\n\\hat{Y}_{t}=W_{out}h_{t}+b_{out} \\tag{11}\n$$\n\n\n$$\n\\hat{y}_{t}=\\sigma(\\hat{Y}_{t}) \\tag{12}\n$$\n\n#### 损失函数\n\n损失函数用来评价模型的预测值和真实值不一样的程度。这里使用**MSE**(Mean Square Error, 均方差)来进行评估评估实际输出与期望输出的误差。MSE的公式为：（$\\hat{y}_{t}$为预测值，$y_{t}$标签值，$n$为序列长度）\n$$\nE=\\frac{1}{n}\\sum_{t=1}^{n}(\\hat{y}_t-y_{t})^{2} \\tag{13}\n$$\n\n### 反向传播过程\n\n反向传播就是根据正向传播的误差来求梯度，然后根据梯度调整原来的权重。\n\n> + sigmoid函数的导数为：${\\sigma}'(x)=\\sigma(x) \\ast (1-\\sigma(x))$。\n> + tanh函数的导数为：${tanh}'(x)=1-tanh^{2}(x)$。\n> + 使用$grad(x)$来代表误差$E$关于$x$的梯度。\n> + 对于最后一个时刻$t=n$，需要参与计算的$C_{n+1}$，$f_{n+1}$，$i_{n+1}$，$\\hat{c}_{n+1}$，$o_{n+1}$都为0。\n\n#### 关于输出层的梯度\n\n对预测值的梯度计算：\n$$\ngrad(\\hat{y}_{t})=\\frac{\\partial{E}}{\\partial{\\hat{y}_{t}}}=\\frac{2}{n}(\\hat{y}_{t}-y_{t}) \\tag{14}\n$$\n\n$$\ngrad(\\hat{Y}_{t})=\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=\\frac{\\partial{\\hat{y}}_{t}}{\\partial{\\hat{Y}}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{y}}_{t}}={\\sigma}'(x)\\ast grad(\\hat{y}_{t}) \\tag{15}\n$$\n\n对隐层与输出层之间的连接权值的梯度计算：\n$$\ngrad(W_{out})=\\frac{\\partial{E}}{\\partial{W}_{out}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{W}_{out}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=h_{t}\\ast grad(\\hat{Y}_{t}) \\tag{16}\n$$\n\n$$\ngrad(b_{out})=\\frac{\\partial{E}}{\\partial{b}_{out}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{b}_{out}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=grad(\\hat{Y}_{t}) \\tag{17}\n$$\n\n#### 隐层（LSTM单元）——关于短时记忆的梯度\n\n​\t\t**对于$h_t$，由公式$(1)$、$(3)$、$(5)$、$(8)$、$(11)$可知，由于其既是当前时刻输出层的输入，又参与了下一个时刻LSTM单元的输入**，因此下列计算得到的梯度只是$grad(h_{t})$的一部分，其余部分见公式$(34)$、$(38)$、$(42)$、 $(46)$。最后的$grad(h_{t})$见公式$(47)$。\n$$\ngrad(h^{1}_{t})=\\frac{\\partial{E}}{\\partial{h}_{t}}=\\frac{\\partial{\\hat{Y}}_{t}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\hat{Y}}_{t}}=W_{out}\\ast grad(\\hat{Y}_{t}) \\tag{18}\n$$\n\n#### 隐层（LSTM单元）——关于长时记忆的梯度\n\n由公式$(7)$、$(10)$可知，$C_{t}$的梯度计算既参与计算下一个时刻的$C_{t+1}$，也参与当前时刻的$h_{t}$的计算。因此由公式$(19)$、$(21)$得到$grad(C_{t})$见公式$(22)$。\n$$\ngrad(C^{1}_{t})=\\frac{\\partial{E}}{\\partial{C_{t}}}=\\frac{\\partial{h}_{t}}{\\partial{C}_{t}}\\ast\\frac{\\partial{E}}{\\partial{h}_{t}}={tanh}'(C_{t})\\ast o_{t}\\ast grad(h_{t}) \\tag{19}\n$$\n\n$$\ngrad(C^{1}_{t-1})=\\frac{\\partial{E}}{\\partial{C_{t-1}}}=\\frac{\\partial{C}_{t}}{\\partial{C}_{t-1}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=f_{t}\\ast grad(C_{t}) \\tag{20}\n$$\n\n$$\ngrad(C^{2}_{t})=\\frac{\\partial{E}}{\\partial{C_{t}}}=\\frac{\\partial{C}_{t+1}}{\\partial{C}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t+1}}=f_{t+1}\\ast grad(C_{t+1}) \\tag{21}\n$$\n\n$$\ngrad(C_{t})=grad(C^{1}_{t})+grad(C^{2}_{t})={tanh}'(C_{t})\\ast o_{t}\\ast grad(h_{t})+f_{t+1}\\ast grad(C_{t+1}) \\tag{22}\n$$\n\n#### 关于隐层（LSTM单元）——关于三门各自输出的梯度\n\n由公式$(7)$、$(10)$计算，关于遗忘门输出的梯度为：\n$$\ngrad(f_{t})=\\frac{\\partial{E}}{\\partial{f_{t}}}=\\frac{\\partial{C}_{t}}{\\partial{f}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=C_{t-1}\\ast grad(C_{t}) \\tag{23}\n$$\n\n$$\ngrad(F_{t})=\\frac{\\partial{E}}{\\partial{F_{t}}}=\\frac{\\partial{f}_{t}}{\\partial{F}_{t}}\\ast\\frac{\\partial{E}}{\\partial{f}_{t}}={\\sigma}'(F_{t})\\ast grad(f_{t}) \\tag{24}\n$$\n\n关于输入门输出的梯度为：\n$$\ngrad(i_{t})=\\frac{\\partial{E}}{\\partial{i_{t}}}=\\frac{\\partial{C}_{t}}{\\partial{i}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}=\\widetilde{C}_{t}\\ast grad(C_{t}) \\tag{25}\n$$\n\n$$\ngrad(I_{t})=\\frac{\\partial{E}}{\\partial{I_{t}}}=\\frac{\\partial{i}_{t}}{\\partial{I}_{t}}\\ast\\frac{\\partial{E}}{\\partial{i}_{t}}={\\sigma}'(I_{t})\\ast grad(i_{t}) \\tag{26}\n$$\n\n关于新记忆信息输出的梯度为：\n$$\ngrad(\\widetilde{c}_{t})=\\frac{\\partial{E}}{\\partial{\\widetilde{c}_{t}}}=\\frac{\\partial{C}_{t}}{\\partial\\widetilde{c}_{t}}\\ast\\frac{\\partial{E}}{\\partial{C}_{t}}={i}_{t}\\ast grad(C_{t}) \\tag{27}\n$$\n\n$$\ngrad(\\widetilde{C}_{t})=\\frac{\\partial{E}}{\\partial{\\widetilde{C}_{t}}}=\\frac{\\partial{\\widetilde{c}}_{t}}{\\partial{\\widetilde{C}}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{c}}_{t}}={tanh}'(\\widetilde{C}_{t})\\ast grad(\\widetilde{c}_{t}) \\tag{28}\n$$\n\n关于输出门输出的梯度为：\n$$\ngrad(o_{t})=\\frac{\\partial{E}}{\\partial{o_{t}}}=\\frac{\\partial{h}_{t}}{\\partial{o}_{t}}\\ast\\frac{\\partial{E}}{\\partial{h}_{t}}=tanh(C_{t})\\ast grad(h_{t}) \\tag{29}\n$$\n\n$$\ngrad(O_{t})=\\frac{\\partial{E}}{\\partial{O_{t}}}=\\frac{\\partial{o}_{t}}{\\partial{O}_{t}}\\ast\\frac{\\partial{E}}{\\partial{o}_{t}}={\\sigma}'(O_{t})\\ast grad(o_{t}) \\tag{30}\n$$\n\n#### 关于隐层（LSTM单元）——关于输出门连接权的梯度\n\n\n$$\ngrad(W_{oh})=\\frac{\\partial{E}}{\\partial{W}_{oh}}=\\frac{\\partial{O}_{t}}{\\partial{W}_{oh}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=h_{t-1}\\ast grad({O}_{t}) \\tag{31}\n$$\n\n$$\ngrad(W_{ox})=\\frac{\\partial{E}}{\\partial{W}_{ox}}=\\frac{\\partial{O}_{t}}{\\partial{W}_{ox}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=x_{t}\\ast grad({O}_{t}) \\tag{32}\n$$\n\n$$\ngrad(b_{o})=\\frac{\\partial{E}}{\\partial{b}_{o}}=\\frac{\\partial{O}_{t}}{\\partial{b}_{o}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t}}=grad({O}_{t}) \\tag{33}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第2部分梯度：\n$$\ngrad(h^{2}_{t})=\\frac{\\partial{E}}{\\partial{h}^{2}_{t}}=\\frac{\\partial{O}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{O}_{t+1}}=W_{oh}\\ast grad({O}_{t+1}) \\tag{34}\n$$\n\n#### 关于隐层（LSTM单元）——关于产生新记忆信息部分连接权的梯度\n\n\n$$\ngrad(W_{ch})=\\frac{\\partial{E}}{\\partial{W}_{ch}}=\\frac{\\partial\\widetilde{C}_{t}}{\\partial{W}_{ch}} \\ast \\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=h_{t-1}\\ast grad(\\widetilde{C}_{t}) \\tag{35}\n$$\n\n$$\ngrad(W_{cx})=\\frac{\\partial{E}}{\\partial{W}_{cx}}=\\frac{\\partial{\\widetilde{C}}_{t}}{\\partial{W}_{cx}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=x_{t}\\ast grad({\\widetilde{C}}_{t}) \\tag{36}\n$$\n\n$$\ngrad(b_{c})=\\frac{\\partial{E}}{\\partial{b}_{c}}=\\frac{\\partial{\\widetilde{C}}_{t}}{\\partial{b}_{c}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t}}=grad({\\widetilde{C}}_{t}) \\tag{37}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第3部分梯度：\n$$\ngrad(h^{3}_{t})=\\frac{\\partial{E}}{\\partial{h}^{3}_{t}}=\\frac{\\partial{\\widetilde{C}}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{\\widetilde{C}}_{t+1}}=W_{ch}\\ast grad({\\widetilde{C}}_{t+1}) \\tag{38}\n$$\n\n#### 关于隐层（LSTM单元）——关于输入门连接权的梯度\n\n\n$$\ngrad(W_{ih})=\\frac{\\partial{E}}{\\partial{W}_{ih}}=\\frac{\\partial{I}_{t}}{\\partial{W}_{ih}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=h_{t-1}\\ast grad({I}_{t}) \\tag{39}\n$$\n\n$$\ngrad(W_{ix})=\\frac{\\partial{E}}{\\partial{W}_{ix}}=\\frac{\\partial{I}_{t}}{\\partial{W}_{ix}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=x_{t}\\ast grad({I}_{t}) \\tag{40}\n$$\n\n$$\ngrad(b_{i})=\\frac{\\partial{E}}{\\partial{b}_{i}}=\\frac{\\partial{I}_{t}}{\\partial{b}_{i}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t}}=grad({I}_{t}) \\tag{41}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第4部分梯度：\n$$\ngrad(h^{4}_{t})=\\frac{\\partial{E}}{\\partial{h}^{4}_{t}}=\\frac{\\partial{I}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{I}_{t+1}}=W_{ih}\\ast grad({I}_{t+1}) \\tag{42}\n$$\n\n#### 关于隐层（LSTM单元）——关于遗忘门连接权的梯度\n\n\n$$\ngrad(W_{fh})=\\frac{\\partial{E}}{\\partial{W}_{fh}}=\\frac{\\partial{F}_{t}}{\\partial{W}_{fh}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=h_{t-1}\\ast grad({F}_{t}) \\tag{43}\n$$\n\n$$\ngrad(W_{fx})=\\frac{\\partial{E}}{\\partial{W}_{fx}}=\\frac{\\partial{F}_{t}}{\\partial{W}_{fx}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=x_{t}\\ast grad({F}_{t}) \\tag{44}\n$$\n\n$$\ngrad(b_{f})=\\frac{\\partial{E}}{\\partial{b}_{f}}=\\frac{\\partial{F}_{t}}{\\partial{b}_{f}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t}}=grad({F}_{t}) \\tag{45}\n$$\n\n这里计算得到关于短时记忆$h_{t}$的第5部分梯度：\n$$\ngrad(h^{5}_{t})=\\frac{\\partial{E}}{\\partial{h}^{5}_{t}}=\\frac{\\partial{F}_{t+1}}{\\partial{h}_{t}}\\ast\\frac{\\partial{E}}{\\partial{F}_{t+1}}=W_{fh}\\ast grad({F}_{t+1}) \\tag{46}\n$$\n\n这里将上述计算的部分梯度累加，得到关于短时记忆$h_{t}$的梯度：\n$$\ngrad(h_{t})=grad(h^{1}_{t})+grad(h^{2}_{t})+grad(h^{3}_{t})+grad(h^{4}_{t})+grad(h^{5}_{t}) \\tag{47}\n$$\n\n## LSTM的C语言实现\n\n> 实现单向的、一层的LSTM。\n\n### 读取数据集\n\n#### 需求背景\n\n假设有这样一个需求：城市的货运量受不同产业GDP、市场消费额度、居民可支配收入等因素的影响，需要根据某城市上一年的货运量预测下一年的货运量，给定数据集如下：\n\n| YEAR | GDP1   | GDP2    | GDP3    | AC      | TI       | VI       | TARGET   |\n| ---- | ------ | ------- | ------- | ------- | -------- | -------- | -------- |\n| 2002 | 90.4   | 635.5   | 741.9   | 798.64  | 7820.24  | 3295     | 15942.57 |\n| 2003 | 95.13  | 701.87  | 825.18  | 885.69  | 8524.52  | 3497     | 16609.79 |\n| 2004 | 102.23 | 825.78  | 954.23  | 996.22  | 9564.05  | 3954.5   | 17044.8  |\n| 2005 | 109.57 | 1026.27 | 1125.33 | 1128.64 | 10849.72 | 4341     | 19611.72 |\n| 2006 | 115.91 | 1205.42 | 1358    | 1293.33 | 12360    | 4748     | 20485.76 |\n| 2007 | 129.15 | 1440    | 1540.32 | 1518.3  | 14357.64 | 5371     | 22554.93 |\n| 2008 | 144.7  | 1867.21 | 2103.6  | 1850.05 | 16712.44 | 6349     | 29142.98 |\n| 2009 | 149.06 | 2142.14 | 2329.66 | 2164.09 | 18385.02 | 7161     | 34208.9  |\n| 2010 | 170.04 | 2532.82 | 2863.07 | 2570.4  | 20806.32 | 8294.81  | 40287.93 |\n| 2011 | 198.7  | 3254.02 | 3309.48 | 3031.79 | 23738    | 9814     | 41804.45 |\n| 2012 | 301.21 | 3859.56 | 3843.05 | 3467.37 | 27061    | 11190    | 43892.49 |\n| 2013 | 335.4  | 4396.17 | 4319.7  | 3916.6  | 29821.22 | 12713    | 44528.75 |\n| 2014 | 350.06 | 4785.66 | 4933.76 | 4573.54 | 33270.39 | 16160.14 | 48529.99 |\n| 2015 | 359.81 | 4981.54 | 5564.25 | 5102.24 | 36436    | 17722.18 | 48185.19 |\n| 2016 | 390.62 | 5227.05 | 6294.94 | 5610.59 | 39737    | 19152    | 49981.81 |\n| 2017 | 408.2  | 5862.35 | 7140.49 | 6196.3  | 43405    | 20887    | 57271.17 |\n\n分析数据集可知：\n\n+ 给定的是某个城市的数据，因此$样本数=1$。\n+ 第1列为年份，因此可知$数据集行数(减去第一行)=时间序列的长度$。\n+ 第2-7列为影响货运量的输入，即为$特征输入维度=6$。\n+ 第8列为货运量，即为$标签值$。\n\n#### 代码实现\n\n> 注：以下代码，声明放在.h文件中，定义放在.c文件中。\n\n```cpp\n//获取行列数\nvoid get_row_and_column(char *filename, int *row, int *column);\n//读取数据\nvoid read_data(double **data, char *filename);\n```\n\n```cpp\n//获取行列数\nvoid get_row_and_column(char *filename, int *row, int *column)\n{\n\tchar line[1024];\n\tFILE *fp = fopen(filename, \"r\");\n\tint i = 0, j = 0;\n\t/*先读取第一行，以便从中划分出列*/\n\tfgets(line, 1024, fp);\n\ti++;\n\tconst char *delim = \",\"; //分节符为逗号\n\tchar *token = strtok(line, delim);\n\twhile (token)\n\t{\n\t\ttoken = strtok(NULL, delim);\n\t\tj++;\n\t}\n\t/*继续读取每一行， 计算行数*/\n\twhile (fgets(line, 1024, fp))\n\t{\n\t\ti++;\n\t}\n\t*row = i;\n\t*column = j;\n\n\tfclose(fp);\n}\n\n// 获取完整数据集\nvoid read_data(double **data, char *filename)\n{\n\tchar line[1024];\n\tFILE *stream = fopen(filename, \"r\");\n\tint i = 0;\n\t//过滤掉第一行\n\tfgets(line, 1024, stream);\n\twhile (fgets(line, 1024, stream)) //逐行读取\n\t{\n\t\tint j = 0;\n\t\tchar *tok;\n\t\t//这里过滤掉第一列\n\t\ttok = strtok(line, \",\");\n\t\ttok = strtok(NULL, \",\");\n\t\tfor (; tok && *tok; j++, tok = strtok(NULL, \",\"))\n\t\t{\n\t\t\tdata[i][j] = atof(tok); //转换成浮点数\n\t\t}                         //字符串拆分操作\n\t\ti++;\n\t}\n\tfclose(stream); //文件打开后要进行关闭操作\n\n}\n```\n\n### 数据标准化\n\n这里采用最大最小标准化方式，将原数据线性映射到$[0,1]$之间。公式为：\n$$\nx^{*}=\\frac{x-min}{max-min} \\tag{48}\n$$\n这里对每列数据求得的最大最小值需要保存下来，用于后面的数据还原操作；该值也需要保存为模型参数，后续使用该模型来预测时，测试数据的标准化依赖于这两个值。\n\n```cpp\n//数据标准化:最大最小标准化\nvoid normalize_dataset(double **dataset, int row, int col);\n//数据还原，返回原来值\ndouble restore_data(double y_data, int col_number); //col_number：在原来数据集中的列号,从0开始的\n```\n\n```cpp\ndouble *MAX = NULL;  //保存每列数据的最大值\ndouble *MIN = NULL;  //保存每列数据的最小值\n\n//数据标准化\nvoid normalize_dataset(double **dataset, int row, int col)\n{\n\tMAX = (double*)malloc(col * sizeof(double));\n\tMIN = (double*)malloc(col * sizeof(double));\n\n\t// 先 对列循环\n\tdouble maximum, minimum;\n\tfor (int i = 0; i < col; i++)\n\t{\n\t\tmaximum = dataset[0][i];\n\t\tminimum = dataset[0][i];\n\t\t//再 对行循环\n\t\tfor (int j = 0; j < row; j++)\n\t\t{\n\t\t\tmaximum = (dataset[j][i] > maximum) ? dataset[j][i] : maximum;\n\t\t\tminimum = (dataset[j][i] < minimum) ? dataset[j][i] : minimum;\n\t\t}\n\t\t// 归一化处理\n\t\tfor (int j = 0; j < row; j++)\n\t\t{\n\t\t\tdataset[j][i] = (dataset[j][i] - minimum) / (maximum - minimum);\n\t\t}\n\n\t\tMAX[i] = maximum;\n\t\tMIN[i] = minimum;\n\t}\n}\n\n//数据还原\ndouble restore_data(double y_data, int col_number)\n{\n\ty_data = (y_data * (MAX[col_number] - MIN[col_number])) + MIN[col_number];\n\n\treturn y_data;\n}\n```\n\n### 损失函数\n\n```cpp\n//损失函数:均方差MSE\n//输入：实际标签值；预测值；时间序列长度\ndouble mse(double *actual, double *predicted, int n);\n```\n\n```cpp\n//损失函数\ndouble mse(double *actual, double *predicted, int n)\n{\n\tdouble sum_err = 0.0;\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tdouble err = predicted[i] - actual[i];\n\t\tsum_err += err * err;\n\t}\n\tdouble mean_err = sum_err / n;\n\treturn mean_err;\n}\n```\n\n### 评价指标\n\n这里采用**MAPE**（Mean Absolute Percentage Error，平均绝对百分比误差）。公式为：\n$$\nMAPE=\\frac{100\\%}{n} \\sum^{n}_{t=1}{|{\\frac{\\hat{y}_{t}-y_{t}}{y_{t}}|}} \\tag{49}\n$$\n\n> + 范围[0,+∞)，MAPE 为0%表示完美模型，MAPE 大于 100 %则表示劣质模型。\n> + 根据公式，分母不能为0，因此标签值不能为0。所以需要对标准化的标签数据进行还原。\n\n```cpp\n//预测评价指标：平均绝对百分比误差MAPE\ndouble mape(double *actual, double *predicted, int n);\n```\n\n```cpp\n//预测评价指标\ndouble mape(double *actual, double *predicted, int n)\n{\n\tdouble sum_err = 0.0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsum_err += fabs((predicted[i] - actual[i]) / actual[i]);\n\t}\n\tdouble mean_err = sum_err / n;\n\treturn mean_err;\n}\n```\n\n### 激活函数及其导数\n\n```cpp\n//激活函数及其导数\ndouble sigmoid(double x);\ndouble dsigmoid(double y);\ndouble dtanh(double y);\n```\n\n```cpp\n//simoid函数\ndouble sigmoid(double x)\n{\n\treturn 1.0 / (1.0 + exp(-x));\n}\n\n//simoid的导数，y为simoid值\ndouble dsigmoid(double y)\n{\n\treturn y * (1.0 - y);\n}\n\n// tanh的导数，y为tanh值\ndouble dtanh(double y)\n{\n\treturn 1.0 - y * y;\n}\n```\n\n### 优化算法\n\n这里采用的是Adam（Adaptive Moment Estimation，自适应矩估计）算法。\n\n> 设在$t$时刻下：\n>\n> + $w_{t}$为权重，$g_{t}$为$w_{t}$的梯度，$m_{t}$为$w_{t}$的一阶矩估计，$r_{t}$为$w_{t}$的二阶矩估计。\n> + $\\alpha$为学习率，$\\beta_{1}$和$\\beta_{2}$为控制指数衰减的常数，$\\epsilon$为用于数值稳定的常数。\n> + $\\alpha$一般需要调节，其他均可采用默认设置：$\\beta_{1}=0.9$，$\\beta_{2}=0.999$，$\\epsilon=10^{-8}$。\n\n算法流程如下：\n\n>1. 更新一阶矩估计$m_{t}$：$m_{t}=\\beta_{1} \\ast m_{t-1}+(1-\\beta_{1}) \\ast g_{t}$\n>\n>2. 更新二阶矩估计$r_{t}$：$r_{t}=\\beta_{2} \\ast r_{t-1}+(1-\\beta_{2}) \\ast g_{t}^{2}$\n>3. 求得$m_{t}$的偏差修正$\\hat{m}_{t}$：$\\hat{m}_{t}=\\frac{m_{t}}{1-\\beta_{1}}$\n>4. 求得$r_{t}$的偏差修正$\\hat{r}_{t}$：$\\hat{r}_{t}=\\frac{r_{t}}{1-\\beta_{2}}$\n>5. 更新权重$w_{t}$：$w_{t}=w_{t-1}-\\alpha \\ast  \\frac{\\hat{m}_{t}}{\\sqrt{\\hat{r}_{t}}+\\epsilon}$\n\n```cpp\n//优化算法: Adam算法\n//输入: 权重,一阶矩估计,二阶矩估计,学习率,w的梯度dw，beta1、beta2为矩估计的指数衰减速率,epsilon为步长\nvoid adam(double* w, double* m, double* r, double g, double l_rate, double beta1, double beta2, double epsilon);\n```\n\n> 注：这里的函数形参采用指针形式传入地址，以修改值。\n\n```cpp\n//优化算法: Adam算法\n//输入: 权重,一阶矩估计,二阶矩估计,w的梯度dw，学习率,beta1、beta2为矩估计的指数衰减速率,epsilon为步长\nvoid adam(double* w, double* m, double* r, double g, double l_rate, double beta1, double beta2, double epsilon)\n{\n\tdouble temp_w = *w;\n\tdouble temp_m = *m;\n\tdouble temp_r = *r;\n\n\ttemp_m = beta1 * temp_m + (1 - beta1)*g;//一阶矩：梯度的指数移动平均值\n\ttemp_r = beta2 * temp_r + (1 - beta2)*g*g;//二阶矩：平方梯度\n\n\t//偏差修正\n\tdouble temp_m_correction = temp_m / (1 - beta1); \n\tdouble temp_r_correction = temp_r / (1 - beta2);\n\n\t//更新权重\n\ttemp_w = temp_w - l_rate * ((temp_m_correction) / (sqrt(temp_r_correction) + epsilon));\n\n\t*w = temp_w;\n\t*m = temp_m;\n\t*r = temp_r;\n}\n```\n\n### 构建LSTM网络\n\n> + 定义全局的二维数组作为权值矩阵，并在开始时分配内存，在结束时释放。\n> + 由优化算法可知，每个权值都有对应的一阶矩估计和二阶矩估计，因此需要定义的参数除了上述算法中的$(12+2)$个之外，还需要$(12+2)*2$个参数，总共$14*3=42$个参数。\n> + **不足之处：为了更好的可扩展性和可读性，事实上应当定义一个LSTM单元为结构体**。\n> + 网络建立后就需要对权值进行初始化，这里采用正太分布初始化权重，一、二阶矩估计和偏置初始化为0。\n\n```cpp\n//随机数生成\ndouble normal_standard(); //标准正态分布随机数生成\ndouble normal(double mean, double stdev); //正太分布随机数生成：指定期望为mean，方差为stdev\n//构建网络：申请内存建立权重数组，初始化权重\n//输入：特征维度；隐层节点数（LSTM单元数）\nvoid init_normal_weight(int dim, int hidenode_num); //正太分布初始化\n```\n\n```cpp\n/* F_t = sigmoid(X_t * W_fx + H_pre * W_fh + B_f) */\ndouble** W_fx = NULL;   //连接输入X_t与本细胞中遗忘门的权值矩阵\ndouble** W_fx_m = NULL; //adam优化算法的权值参数\ndouble** W_fx_r = NULL; //adam优化算法的权值参数\ndouble** W_fh = NULL;   //连接上一细胞输出H_pre与本细胞中遗忘门的权值矩阵\ndouble** W_fh_m = NULL;\ndouble** W_fh_r = NULL;\ndouble* B_f = NULL;     //偏置\ndouble* B_f_m = NULL;\ndouble* B_f_r = NULL;\n/* I_t = sigmoid(X_t * W_ix + H_pre * W_ih + B_i) */\ndouble** W_ix = NULL;  \ndouble** W_ix_m = NULL;\ndouble** W_ix_r = NULL;\ndouble** W_ih = NULL;\ndouble** W_ih_m = NULL;\ndouble** W_ih_r = NULL;\ndouble* B_i = NULL;\ndouble* B_i_m = NULL;\ndouble* B_i_r = NULL;\n/* O_t = sigmoid(X_t * W_ox + H_pre * W_oh + B_o) */\ndouble** W_ox = NULL;     \ndouble** W_ox_m = NULL;\ndouble** W_ox_r = NULL;\ndouble** W_oh = NULL; \ndouble** W_oh_m = NULL;\ndouble** W_oh_r = NULL;\ndouble* B_o = NULL;\ndouble* B_o_m = NULL;\ndouble* B_o_r = NULL;\n/* C`_t = tanh(X_t * W_cx + H_pre * W_ch + B_c) */\ndouble** W_cx = NULL; \ndouble** W_cx_m = NULL;\ndouble** W_cx_r = NULL;\ndouble** W_ch = NULL;\ndouble** W_ch_m = NULL;\ndouble** W_ch_r = NULL;\ndouble* B_c = NULL;\ndouble* B_c_m = NULL;\ndouble* B_c_r = NULL;\n/* Y_t = sigmoid(H_t * W_out + b_out)*/\ndouble* W_out = NULL; \ndouble* W_out_m = NULL;\ndouble* W_out_r = NULL;\ndouble b_out;\ndouble b_out_m;\ndouble b_out_r;\n\n// Box-Muller法\n//生成的正太分布随机数序列的期望为0.0，方差为1.0。若指定期望为E，标准为V，则只需增加：X = X * V + E;\ndouble normal_standard()\n{\n\tstatic double U, V, S;\n\tstatic int phase = 0;\n\tdouble X;\n\t// srand((unsigned int)time(NULL));\n\tif (phase == 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\tU = (double)rand() / RAND_MAX;\n\t\t\tV = (double)rand() / RAND_MAX;\n\t\t\tU = 2 * U - 1;\n\t\t\tV = 2 * V - 1;\n\t\t\tS = U * U + V * V;\n\t\t} while (S >= 1 || S == 0);\n\t\tX = U * sqrt(-2 * log(S) / S);\n\t}\n\telse\n\t{\n\t\tX = U * sqrt(-2 * log(S) / S);\n\t}\n\tphase = 1 - phase;\n\treturn X;\n}\n\n//正太分布随机数生成：指定期望为mean，标准差为stdev\ndouble normal(double mean, double stdev)\n{\n\treturn mean + stdev * normal_standard();\n}\n\n/* 建立权重数组，初始化权重 */\nvoid init_normal_weight(int dim, int hidenode_num) //正太分布初始化\n{\n\tint i, j;\n\tdouble mean = 0.0, stdev = 0.001;\n\n\tW_ix = (double **)malloc(dim * sizeof(double *));\n\tW_fx = (double **)malloc(dim * sizeof(double *));\n\tW_ox = (double **)malloc(dim * sizeof(double *));\n\tW_cx = (double **)malloc(dim * sizeof(double *));\n\tW_ix_m = (double **)malloc(dim * sizeof(double *));\n\tW_fx_m = (double **)malloc(dim * sizeof(double *));\n\tW_ox_m = (double **)malloc(dim * sizeof(double *));\n\tW_cx_m = (double **)malloc(dim * sizeof(double *));\n\tW_ix_r = (double **)malloc(dim * sizeof(double *));\n\tW_fx_r = (double **)malloc(dim * sizeof(double *));\n\tW_ox_r = (double **)malloc(dim * sizeof(double *));\n\tW_cx_r = (double **)malloc(dim * sizeof(double *));\n\tfor (i = 0; i < dim; i++)\n\t{\n\t\tW_ix[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ix_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ix_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fx_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ox_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_cx_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tW_ix[i][j] = normal(mean, stdev);\n\t\t\tW_fx[i][j] = normal(mean, stdev);\n\t\t\tW_ox[i][j] = normal(mean, stdev);\n\t\t\tW_cx[i][j] = normal(mean, stdev);\n\n\t\t\tW_ix_m[i][j] = 0;\n\t\t\tW_fx_m[i][j] = 0;\n\t\t\tW_ox_m[i][j] = 0;\n\t\t\tW_cx_m[i][j] = 0;\n\n\t\t\tW_ix_r[i][j] = 0;\n\t\t\tW_fx_r[i][j] = 0;\n\t\t\tW_ox_r[i][j] = 0;\n\t\t\tW_cx_r[i][j] = 0;\n\t\t}\n\t}\n\t\n\tW_ih = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ih_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch_m = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ih_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_fh_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_oh_r = (double **)malloc(hidenode_num * sizeof(double *));\n\tW_ch_r = (double **)malloc(hidenode_num * sizeof(double *));\n\n\tB_i = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c = (double *)malloc(hidenode_num * sizeof(double));\n\tB_i_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c_m = (double *)malloc(hidenode_num * sizeof(double));\n\tB_i_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_f_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_o_r = (double *)malloc(hidenode_num * sizeof(double));\n\tB_c_r = (double *)malloc(hidenode_num * sizeof(double));\n\n\tW_out = (double *)malloc(hidenode_num * sizeof(double));\n\tW_out_m = (double *)malloc(hidenode_num * sizeof(double));\n\tW_out_r = (double *)malloc(hidenode_num * sizeof(double));\n\n\tfor (i = 0; i < hidenode_num; i++)\n\t{\n\t\tW_ih[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ih_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch_m[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ih_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_fh_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_oh_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tW_ch_r[i] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tW_ih[i][j] = normal(mean, stdev);\n\t\t\tW_fh[i][j] = normal(mean, stdev);\n\t\t\tW_oh[i][j] = normal(mean, stdev);\n\t\t\tW_ch[i][j] = normal(mean, stdev);\n\n\t\t\tW_ih_m[i][j] = 0;\n\t\t\tW_fh_m[i][j] = 0;\n\t\t\tW_oh_m[i][j] = 0;\n\t\t\tW_ch_m[i][j] = 0;\n\n\t\t\tW_ih_r[i][j] = 0;\n\t\t\tW_fh_r[i][j] = 0;\n\t\t\tW_oh_r[i][j] = 0;\n\t\t\tW_ch_r[i][j] = 0;\n\t\t}\n\t\tB_f[i] = 0.0;\n\t\tB_i[i] = 0.0;\n\t\tB_c[i] = 0.0;\n\t\tB_o[i] = 0.0;\n\n\t\tB_f_m[i] = 0.0;\n\t\tB_i_m[i] = 0.0;\n\t\tB_c_m[i] = 0.0;\n\t\tB_o_m[i] = 0.0;\n\n\t\tB_f_r[i] = 0.0;\n\t\tB_i_r[i] = 0.0;\n\t\tB_c_r[i] = 0.0;\n\t\tB_o_r[i] = 0.0;\n\n\t\tW_out[i] = normal(mean, stdev);\n\t\tW_out_m[i] = 0.0;\n\t\tW_out_r[i] = 0.0;\n\t}\n\tb_out = 0.0;\n\n\tb_out_m = 0.0;\n\tb_out_r = 0.0;\n}\n```\n\n### 训练模型\n\n> + 训练过程分为正向传播和反向传播两个过程。\n> + 由于训练过程中需要保存LSTM单元中各个门的临时信息，这里继续定义全局变量用于分配内存来存储。\n> + 对每一次正向传播计算MSE和MAPE。\n\n#### 临时内存的分配和释放\n\n```cpp\n//临时内存的申请释放\n//输入：时间序列长度；LSTM单元节点数\nvoid setup_memory(int seq_size, int hidenode_num);\nvoid free_memory(int seq_size, int hidenode_num);\n```\n\n```cpp\ndouble* y_delta = NULL; //保存误差关于输出层的梯度\ndouble* predictions = NULL; //保存每次生成的预测值\ndouble **F_vector = NULL;     //保存遗忘门信息\ndouble **I_vector = NULL;     //保存输入门信息\ndouble **C_tmp_vector = NULL; //保存新记忆信息(C`t)\ndouble **O_vector = NULL;     //保存输出门信息\ndouble **C_vector = NULL;     //保存长时记忆信息(Ct)\ndouble **H_vector = NULL;     //保存细胞输出信息\n\n/* 为存储记忆信息的数组建立内存 */\nvoid setup_memory(int seq_size, int hidenode_num)\n{\n\ty_delta = (double *)malloc(seq_size * sizeof(double));\n\tpredictions = (double *)malloc(seq_size * sizeof(double));\n\n\tI_vector = (double **)malloc((seq_size) * sizeof(double *));\n\tF_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tO_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tC_tmp_vector = (double **)malloc((seq_size) * sizeof(double *)); \n\tC_vector = (double **)malloc((seq_size + 1) * sizeof(double *));\n\tH_vector = (double **)malloc((seq_size + 1) * sizeof(double *));\n\n\tfor (int j = 0; j < seq_size; j++)\n\t{\n\t\tC_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tH_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tI_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tF_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tO_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\tC_tmp_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t}\n\n\tC_vector[seq_size] = (double *)malloc(hidenode_num * sizeof(double));\n\tH_vector[seq_size] = (double *)malloc(hidenode_num * sizeof(double));\n}\n\n/* 为存储记忆信息的数组释放内存 */\nvoid free_memory(int seq_size, int hidenode_num)\n{\n\tint i;\n\tfor (i = 0; i < seq_size; i++)\n\t{\n\t\tfree(F_vector[i]);\n\t\tfree(I_vector[i]);\n\t\tfree(C_tmp_vector[i]);\n\t\tfree(O_vector[i]);\n\t\tfree(C_vector[i]);\n\t\tfree(H_vector[i]);\n\t}\n\tfree(C_vector[i]);\n\tfree(H_vector[i]);\n\n\tfree(F_vector);\n\tfree(I_vector);\n\tfree(C_tmp_vector);\n\tfree(O_vector);\n\tfree(C_vector);\n\tfree(H_vector);\n\n\tfree(y_delta);\n\tfree(predictions);\n}\n```\n\n#### 正向传播过程\n\n```cpp\n//前向传播\nvoid forward(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num);\n```\n\n```cpp\n// 前向传播 \nvoid forward(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num)\n{\n\tint p, k, m, j;\n\n\t//遍历时刻序列\n\tfor (p = 0; p < train_seq_size; p++)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double)); //遗忘门，存储要遗忘的信息f_t，激活函数sigmoid()\n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));    //输入门，存储要更新的信息i_t，激活函数sigmoid()\n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));      // c_t ，存储当前时刻计算得到新记忆c_t，激活函数tanh()\n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double));    //输出门，存储输出的信息o_t，激活函数sigmoid()\n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double));      //记忆值，由遗忘门和输入们组合得到的当前时刻的长时记忆C_t\n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));           //输出值，由(tanh(C_t)*o_t)得到的当前时刻的输出值h_t\n\n\t\tdouble *h_pre = H_vector[p];\n\t\tdouble *memory_pre = C_vector[p];\n\n\t\tfor (k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\t\n\t\t\tdouble inGate = 0.0;\n\t\t\tdouble outGate = 0.0;\n\t\t\tdouble forgetGate = 0.0;\n\t\t\tdouble gGate = 0.0;\n\t\t\t//输入层转播到隐层\n\t\t\tfor (m = 0; m < dim; m++)\n\t\t\t{\n\t\t\t\tforgetGate += X_train_seq[p][m] * W_fx[m][k];//输入x 与 遗忘门 的权重运算\n\t\t\t\tinGate += X_train_seq[p][m] * W_ix[m][k];    //输入x 与 输入门 的权重运算\n\t\t\t\tgGate += X_train_seq[p][m] * W_cx[m][k];     //输入x 与 当前时刻的Cell状态 的权重运算\n\t\t\t\toutGate += X_train_seq[p][m] * W_ox[m][k];   //输入x 与 输出门 的权重运算\n\t\t\t}\n\t\t\tfor (m = 0; m < hidenode_num; m++)\n\t\t\t{\n\t\t\t\tforgetGate += h_pre[m] * W_fh[m][k];//上一时刻的输出值h_pre 与 遗忘门 的权重运算\n\t\t\t\tinGate += h_pre[m] * W_ih[m][k];    //上一时刻的输出值h_pre 与 输入门 的权重运算\n\t\t\t\tgGate += h_pre[m] * W_ch[m][k];     //上一时刻的输出值h_pre 与 当前时刻的Cell状态 的权重运算\n\t\t\t\toutGate += h_pre[m] * W_oh[m][k];   //上一时刻的输出值h_pre 与 输出门 的权重运算\n\t\t\t}\n\t\t\t//添加偏置b\n\t\t\tinGate += B_i[k];\n\t\t\toutGate += B_o[k];\n\t\t\tforgetGate += B_f[k];\n\t\t\tgGate += B_c[k];\n\n\t\t\tforget_gate[k] = sigmoid(forgetGate); //得到决定要舍弃的信息f_t\n\t\t\tin_gate[k] = sigmoid(inGate);   //得到要更新的信息i_t\n\t\t\tg_gate[k] = tanh(gGate);     //得到当前时刻的Cell状态ｃ_t\n\t\t\tout_gate[k] = sigmoid(outGate); //得到决定要输出的信息o_t\n\n\t\t\tdouble m_pre = memory_pre[k];  //前一时刻的cell状态C_pre\n\n\t\t\t//整合遗忘门和输入门,得到当前时刻的cell状态C_t(长时信息)\n\t\t\tmemory[k] = forget_gate[k] * m_pre + g_gate[k] * in_gate[k];//f_t * C_pre + i_t * c_t\n\n\t\t\t//最后整合输出门，得到当前时刻的输出值h_t(短时信息)\n\t\t\th[k] = out_gate[k] * tanh(memory[k]); //o_t * tanh(C_t)\n\n\t        //将这些所有信息全部保存\n\t\t\tI_vector[p][k] = in_gate[k];\n\t\t\tF_vector[p][k] = forget_gate[k];\n\t\t\tO_vector[p][k] = out_gate[k];\n\t\t\tC_vector[p + 1][k] = memory[k];\n\t\t\tC_tmp_vector[p][k] = g_gate[k];\n\t\t\tH_vector[p + 1][k] = h[k];\n\t\t}\n\n\t\t//隐藏层传播到输出层\n\t\tdouble out = 0.0;\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tout += h[j] * W_out[j];\n\t\t}\n\t\tout += b_out;\n\n\t\t//输出层各单元输出\n\t\tpredictions[p] = sigmoid(out); //激活函数sigmoid()\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n}\n```\n\n#### 反向传播过程\n\n```cpp\n//反向传播\nvoid backward(double **X_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon);\n```\n\n```cpp\n//反向传播\nvoid backward(double **X_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon)\n{\n\t//隐层误差，通过当前之后一个时间点的隐含层误差和当前输出层的误差计算\n\tdouble* h_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* O_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* I_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* F_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* G_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* memory_delta = (double *)malloc(hidenode_num * sizeof(double));\n\t//当前时间之后的一个隐层误差\n\tdouble* O_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* I_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* F_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* G_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* memory_future_delta = (double *)malloc(hidenode_num * sizeof(double));\n\tdouble* forget_gate_future = (double *)malloc(hidenode_num * sizeof(double));\n\n\tdouble g = 0.0; //临时变量，存储梯度\n\tfor (int j = 0; j < hidenode_num; j++)\n\t{\n\t\tO_future_delta[j] = 0.0;\n\t\tI_future_delta[j] = 0.0;\n\t\tF_future_delta[j] = 0.0;\n\t\tG_future_delta[j] = 0.0;\n\t\tmemory_future_delta[j] = 0.0;\n\t\tforget_gate_future[j] = 0.0;\n\t}\n\n\t//从最后一个时刻序列从后往前传播\n\tfor (int p = train_seq_size - 1; p >= 0; p--)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double));\n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));   \n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));   \n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));   \n\n\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\tin_gate[k] = I_vector[p][k];\n\t\t\tout_gate[k] = O_vector[p][k];\n\t\t\tforget_gate[k] = F_vector[p][k];\n\t\t\tg_gate[k] = C_tmp_vector[p][k];\n\t\t\tmemory[k] = C_vector[p + 1][k];\n\t\t\th[k] = H_vector[p + 1][k];\n\t\t}\n\t\t\n\t\t//前一个时刻的长短记忆\n\t\tdouble *h_pre = H_vector[p];\n\t\tdouble *memory_pre = C_vector[p];\n\n\t\t//更新隐层和输出层之间的连接权\n\t\tfor (int j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tg = y_delta[p] * h[j];\n\t\t\tadam(&W_out[j], &W_out_m[j], &W_out_r[j], g,l_rate, beta1, beta2, epsilon);\n\t\t}\n\t\t//偏置的误差更新\n\t\tg = y_delta[p];\n\t\tadam(&b_out, &b_out_m, &b_out_r, g, l_rate, beta1, beta2, epsilon);\n\n\t\t//对于网络中每个隐藏单元，计算误差项，并更新权值\n\t\tfor (int j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\th_delta[j] = y_delta[p] * W_out[j];\n\t\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t\t{\n\t\t\t\th_delta[j] += I_future_delta[k] * W_ih[j][k];\n\t\t\t\th_delta[j] += F_future_delta[k] * W_fh[j][k];\n\t\t\t\th_delta[j] += O_future_delta[k] * W_oh[j][k];\n\t\t\t\th_delta[j] += G_future_delta[k] * W_ch[j][k];\n\t\t\t}\n\n\t\t\tO_delta[j] = 0.0;\n\t\t\tI_delta[j] = 0.0;\n\t\t\tF_delta[j] = 0.0;\n\t\t\tG_delta[j] = 0.0;\n\t\t\tmemory_delta[j] = 0.0;\n\n\t\t\t//隐含层的校正误差\n\t\t\tO_delta[j] = h_delta[j] * tanh(memory[j]) * dsigmoid(out_gate[j]);\n\t\t\tmemory_delta[j] = h_delta[j] * out_gate[j] * dtanh(tanh(memory[j])) +\n\t\t\t\tmemory_future_delta[j] * forget_gate_future[j];\n\t\t\tF_delta[j] = memory_delta[j] * memory_pre[j] * dsigmoid(forget_gate[j]);\n\t\t\tI_delta[j] = memory_delta[j] * g_gate[j] * dsigmoid(in_gate[j]);\n\t\t\tG_delta[j] = memory_delta[j] * in_gate[j] * dtanh(g_gate[j]);\n\n\t\t\tO_future_delta[j] = O_delta[j];\n\t\t\tF_future_delta[j] = F_delta[j];\n\t\t\tI_future_delta[j] = I_delta[j];\n\t\t\tG_future_delta[j] = G_delta[j];\n\t\t\tmemory_future_delta[j] = memory_delta[j];\n\t\t\tforget_gate_future[j] = forget_gate[j];\n\n\t\t\t//更新前一个时刻和当前时刻隐层之间的权值\n\t\t\tfor (int k = 0; k < hidenode_num; k++)\n\t\t\t{\n\t\t\t\tg = I_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_ih[k][j], &W_ih_m[k][j], &W_ih_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = F_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_fh[k][j], &W_fh_m[k][j], &W_fh_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = O_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_oh[k][j], &W_oh_m[k][j], &W_oh_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = G_delta[j] * h_pre[k];\n\t\t\t\tadam(&W_ch[k][j], &W_ch_m[k][j], &W_ch_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\t\t\t}\n\n\t\t\t//更新输入层和隐层之间的权值\n\t\t\tfor (int k = 0; k < dim; k++)\n\t\t\t{\n\t\t\t\tg = I_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_ix[k][j], &W_ix_m[k][j], &W_ix_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = F_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_fx[k][j], &W_fx_m[k][j], &W_fx_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = O_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_ox[k][j], &W_ox_m[k][j], &W_ox_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\t\tg = G_delta[j] * X_train_seq[p][k];\n\t\t\t\tadam(&W_cx[k][j], &W_cx_m[k][j], &W_cx_r[k][j], g, l_rate, beta1, beta2, epsilon);\n\t\t\t}\n\n\t\t\t//偏置误差更新\n\t\t\tg = I_delta[j];\n\t\t\tadam(&B_i[j], &B_i_m[j], &B_i_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = F_delta[j];\n\t\t\tadam(&B_f[j], &B_f_m[j], &B_f_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = O_delta[j];\n\t\t\tadam(&B_o[j], &B_o_m[j], &B_o_r[j], g, l_rate, beta1, beta2, epsilon);\n\n\t\t\tg = G_delta[j];\n\t\t\tadam(&B_c[j], &B_c_m[j], &B_c_r[j], g, l_rate, beta1, beta2, epsilon);\n\t\t}\n\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n\n\tfree(h_delta);\n\tfree(O_delta);\n\tfree(I_delta);\n\tfree(F_delta);\n\tfree(G_delta);\n\tfree(memory_delta);\n\tfree(O_future_delta);\n\tfree(I_future_delta);\n\tfree(F_future_delta);\n\tfree(G_future_delta);\n\tfree(memory_future_delta);\n\tfree(forget_gate_future);\n}\n```\n\n#### 模型训练\n\n```cpp\n//训练模型: 包括前向传播和反向传播两部分\n//输入：特征输入；标签值；时间序列大小；特征输入维度；隐层节点数；学习率；beta1；beta2；epsilon；训练轮数\nvoid train_model(double **X_train_seq, double* Y_train_seq, int train_seq_size, int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon, int n_epoch);\n\n```\n\n```cpp\n/训练模型: 包括前向传播和反向传播两部分\n//输入：特征输入；标签值；时间序列大小；特征输入维度；隐层节点数；学习率；beta1；beta2；epsilon；训练轮数\nvoid train_model(double **X_train_seq, double* Y_train_seq, int train_seq_size,int dim, int hidenode_num, double l_rate, double beta1, double beta2, double epsilon, int n_epoch)\n{\n\tint epoch, i, j;\n\n\tfor (epoch = 0; epoch < n_epoch; epoch++)\n\t{//对每一轮\n\n\t\t//申请内存存储细胞信息\n\t\tsetup_memory(train_seq_size, hidenode_num);\n\t\t//对于第一个时间序列，前序记忆信息为0\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tC_vector[0][j] = 0;\n\t\t\tH_vector[0][j] = 0;\n\t\t}\n\n\t\t//前向传播\n\t\tforward(X_train_seq, Y_train_seq, train_seq_size, dim, hidenode_num);\n\n\t\t//计算该次训练的MAPE和MSE\n\t\tfor (i = 0; i < train_seq_size; i++)\n\t\t{\n\t\t\t//保存标准误差关于输出层的偏导\n\t\t\ty_delta[i] = 2.0 * (predictions[i] - Y_train_seq[i]) * dsigmoid(predictions[i]) / train_seq_size;\n\t\t}\n\t\tdouble MSE = mse(Y_train_seq, predictions, train_seq_size);//对于MSE计算不还原数据\n\t\tdouble* y = (double *)malloc(train_seq_size * sizeof(double)); //这里将实际输出拷贝一下，避免对原数据进行还原\n\t\tfor (i = 0; i < train_seq_size; i++)\n\t\t{\n\t\t\tpredictions[i] = restore_data(predictions[i], dim);\n\t\t\ty[i] = restore_data(Y_train_seq[i], dim);\n\t\t}\n\t\tdouble MAPE = mape(y, predictions, train_seq_size);//对于MAPE计算需要还原数据\n\t\tif ((epoch + 1) % 100 == 0)\n\t\t{\n\t\t\tprintf(\"\\nepoch %d MAPE为 %f%%, MSE为 %f\\n\", epoch + 1, MAPE * 100, MSE);\n\t\t}\n\n\t\t//反向传播\n\t\tbackward(X_train_seq, train_seq_size, dim, hidenode_num, l_rate, beta1, beta2, epsilon);\n\n\t\tfree_memory(dim, hidenode_num);\n\t}\n\n}\n```\n\n### 预测模型\n\n```cpp\n// 预测模型：与前向传播一样，只不过这里只需要保存细胞的长时记忆、短时记忆信息\nvoid test_model(double **X_test_seq, double* Y_test_seq, int test_seq_size, int dim, int hidenode_num);\n\n```\n\n```cpp\n// 预测模型：与前向传播一样，只不过这里只需要保存细胞的长时记忆、短时记忆信息\nvoid test_model(double **X_test_seq, double* Y_test_seq, int test_seq_size, int dim, int hidenode_num)\n{\n\t// 预测\n\tint p, k, m, j, i;\n\t//定义存储记忆信息和输出值的数组\n\tdouble **M_vector = (double **)malloc((test_seq_size + 1) * sizeof(double *));\n\tdouble **h_vector = (double **)malloc((test_seq_size + 1) * sizeof(double *));\n\tfor (j = 0; j < test_seq_size + 1; j++)\n\t{\n\t\tM_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t\th_vector[j] = (double *)malloc(hidenode_num * sizeof(double));\n\t}\n\tdouble* predict = (double *)malloc(test_seq_size * sizeof(double));\n\tfor (j = 0; j < hidenode_num; j++)\n\t{\n\t\tM_vector[0][j] = 0;\n\t\th_vector[0][j] = 0;\n\t}\n\t\n\tfor (p = 0; p < test_seq_size; p++)\n\t{\n\t\tdouble* forget_gate = (double *)malloc(hidenode_num * sizeof(double)); \n\t\tdouble* in_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* g_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* out_gate = (double *)malloc(hidenode_num * sizeof(double));    \n\t\tdouble* memory = (double *)malloc(hidenode_num * sizeof(double));      \n\t\tdouble* h = (double *)malloc(hidenode_num * sizeof(double));           \n\n\t\tdouble *h_pre = h_vector[p];\n\t\tdouble *memory_pre = M_vector[p];\n\n\t\tfor (k = 0; k < hidenode_num; k++)\n\t\t{\n\t\t\tdouble inGate = 0.0;\n\t\t\tdouble outGate = 0.0;\n\t\t\tdouble forgetGate = 0.0;\n\t\t\tdouble gGate = 0.0;\n\n\t\t\tfor (m = 0; m < dim; m++)\n\t\t\t{\n\t\t\t\tforgetGate += X_test_seq[p][m] * W_fx[m][k];\n\t\t\t\tinGate += X_test_seq[p][m] * W_ix[m][k];  \n\t\t\t\tgGate += X_test_seq[p][m] * W_cx[m][k];    \n\t\t\t\toutGate += X_test_seq[p][m] * W_ox[m][k];  \n\t\t\t}\n\n\t\t\tfor (m = 0; m < hidenode_num; m++)\n\t\t\t{\n\t\t\t\tforgetGate += h_pre[m] * W_fh[m][k];\n\t\t\t\tinGate += h_pre[m] * W_ih[m][k];   \n\t\t\t\tgGate += h_pre[m] * W_ch[m][k];     \n\t\t\t\toutGate += h_pre[m] * W_oh[m][k];   \n\t\t\t}\n\n\t\t\tinGate += B_i[k];\n\t\t\toutGate += B_o[k];\n\t\t\tforgetGate += B_f[k];\n\t\t\tgGate += B_c[k];\n\n\t\t\tforget_gate[k] = sigmoid(forgetGate);\n\t\t\tin_gate[k] = sigmoid(inGate);\n\t\t\tg_gate[k] = tanh(gGate); \n\t\t\tout_gate[k] = sigmoid(outGate);\n\t\t\tdouble m_pre = memory_pre[k];  \n\t\t\tmemory[k] = forget_gate[k] * m_pre + g_gate[k] * in_gate[k];\n\n\t\t\th[k] = out_gate[k] * tanh(memory[k]); \n\n\t\t\tM_vector[p + 1][k] = memory[k];\n\t\t\th_vector[p + 1][k] = h[k];\n\t\t}\n\n\t\tdouble out = 0.0;\n\t\tfor (j = 0; j < hidenode_num; j++)\n\t\t{\n\t\t\tout += h[j] * W_out[j];\n\t\t}\n\t\tout += b_out;\n\n\t\tpredict[p] = sigmoid(out);\n\n\t\tfree(forget_gate);\n\t\tfree(in_gate);\n\t\tfree(g_gate);\n\t\tfree(out_gate);\n\t\tfree(memory);\n\t\tfree(h);\n\t}\n\n\t//计算MAPE和MSE\n\tdouble MSE = mse(Y_test_seq, predict, test_seq_size);//对于MSE计算不还原数据\n\tfor (i = 0; i < test_seq_size; i++)\n\t{\n\t\tpredict[i] = restore_data(predict[i], dim);\n\t\tY_test_seq[i] = restore_data(Y_test_seq[i], dim);\n\t}\n\tdouble MAPE = mape(Y_test_seq, predict, test_seq_size);//对于MAPE计算需要还原数据\n\n\tprintf(\"\\nMAPE为 %f%%, MSE为 %f\\n\", MAPE * 100, MSE);\n\n\tfor (j = 0; j < test_seq_size + 1; j++)\n\t{\n\t\tfree(M_vector[j]);\n\t\tfree(h_vector[j]);\n\t}\n\tfree(M_vector);\n\tfree(h_vector);\n\tfree(predict);\n}\n```\n\n### 销毁网络\n\n> 注：在销毁网络之前，应当将训练好的权值参数保存到文件中。\n\n```cpp\n// 销毁网络，释放内存\nvoid destroy_network(int dim, int hidenode_num);\n```\n\n```cpp\nvoid destroy_network(int dim, int hidenode_num)\n{\n\tint i;\n\n\tfor (i = 0; i < dim; i++)\n\t{\n\t\tfree(W_ix[i]);\n\t\tfree(W_fx[i]);\n\t\tfree(W_ox[i]);\n\t\tfree(W_cx[i]);\n\t\tfree(W_ix_m[i]);\n\t\tfree(W_fx_m[i]);\n\t\tfree(W_ox_m[i]);\n\t\tfree(W_cx_m[i]);\n\t\tfree(W_ix_r[i]);\n\t\tfree(W_fx_r[i]);\n\t\tfree(W_ox_r[i]);\n\t\tfree(W_cx_r[i]);\n\t}\n\tfree(W_ix);\n\tfree(W_fx);\n\tfree(W_ox);\n\tfree(W_cx);\n\tfree(W_ix_m);\n\tfree(W_fx_m);\n\tfree(W_ox_m);\n\tfree(W_cx_m);\n\tfree(W_ix_r);\n\tfree(W_fx_r);\n\tfree(W_ox_r);\n\tfree(W_cx_r);\n\n\tfree(B_i);\n\tfree(B_f);\n\tfree(B_o);\n\tfree(B_c);\n\tfree(B_i_m);\n\tfree(B_f_m);\n\tfree(B_o_m);\n\tfree(B_c_m);\n\tfree(B_i_r);\n\tfree(B_f_r);\n\tfree(B_o_r);\n\tfree(B_c_r);\n\tfree(W_out);\n\tfree(W_out_m);\n\tfree(W_out_r);\n\n\tfor (i = 0; i < hidenode_num; i++)\n\t{\n\t\tfree(W_ih[i]);\n\t\tfree(W_fh[i]);\n\t\tfree(W_oh[i]);\n\t\tfree(W_ch[i]);\n\t\tfree(W_ih_m[i]);\n\t\tfree(W_fh_m[i]);\n\t\tfree(W_oh_m[i]);\n\t\tfree(W_ch_m[i]);\n\t\tfree(W_ih_r[i]);\n\t\tfree(W_fh_r[i]);\n\t\tfree(W_oh_r[i]);\n\t\tfree(W_ch_r[i]);\n\t}\n\tfree(W_ih);\n\tfree(W_fh);\n\tfree(W_oh);\n\tfree(W_ch);\n\tfree(W_ih_m);\n\tfree(W_fh_m);\n\tfree(W_oh_m);\n\tfree(W_ch_m);\n\tfree(W_ih_r);\n\tfree(W_fh_r);\n\tfree(W_oh_r);\n\tfree(W_ch_r);\n}\n```\n\n### 主函数调用\n\n```cpp\nvoid main()\n{\n\n\tchar filename[] = \"GraInput_1.csv\";\n\tint row = 0, col = 0;\n\n\tget_row_and_column(filename, &row, &col);//读取行列\n\n\t//动态申请二维数组,需要过滤掉第一行和第一列\n\trow--;\n\tcol--;\n\tdouble **dataset = (double **)malloc(row * sizeof(int *));\n\tfor (int i = 0; i < row; ++i)\n\t{\n\t\tdataset[i] = (double *)malloc(col * sizeof(double));\n\t}\n\t//读取数据\n\tread_data(dataset, filename);\n\t//print_data(dataset, row, col);\n\t//数据标准化\n\tnormalize_dataset(dataset, row, col);\n\t//print_data(dataset, row, col);\n\n\t//划分训练集和测试集\n\tdouble distribute_ratio = 0.70;//数据集中前70%为训练集,后30%为测试集\n\tint train_seq_size = row * distribute_ratio; //训练集的时间序列长度\n\tint test_seq_size = row - train_seq_size;  //测试集的时间序列长度\n\tint k = 0,i = 0,j = 0;\n\tdouble** X_train_seq = (double**)malloc(train_seq_size * sizeof(double*));\n\tdouble* Y_train_seq = (double*)malloc(train_seq_size * sizeof(double));\n\tdouble** X_test_seq = (double**)malloc(test_seq_size * sizeof(double*));\n\tdouble* Y_test_seq = (double*)malloc(test_seq_size * sizeof(double));\n\tint dim = col - 1; //输入特征维度\n\tfor (k = 0; k < row; k++) {\n\t\tif (k < train_seq_size)\n\t\t{\n\t\t\tX_train_seq[k] = (double*)malloc(dim * sizeof(double));\n\t\t\tfor (j = 0; j < dim; j++)\n\t\t\t{\n\t\t\t\tX_train_seq[k][j] = dataset[k][j]; //这里对值进行拷贝\n\t\t\t}\n\t\t\tY_train_seq[k] = dataset[k][j];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tX_test_seq[i] = (double*)malloc(dim * sizeof(double));\n\t\t\tfor (j = 0; j < dim; j++)\n\t\t\t{\n\t\t\t\tX_test_seq[i][j] = dataset[k][j];\n\t\t\t}\n\t\t\tY_test_seq[i] = dataset[k][j];\n\t\t\ti++;\n\t\t}\n\t}\n\n\tdouble l_rate = 0.001; //学习率\n\tdouble beta1 = 0.9;   //adam算法更新所需超参数beta1\n\tdouble beta2 = 0.999; //adam算法更新所需超参数beta2\n\tdouble epsilon = 10e-8;////adam算法更新所需超参数epsilon\n\tint hidenode_num = 32; //隐层节点数，隐层默认为1层\n\tint n_epoch = 1000;   //训练轮数\n\n\t//构建网络并初始化：建立权重数组，并进行正太分布随机初始化\n\tinit_normal_weight(dim, hidenode_num);\n\n\t//模型训练\n\tprintf(\"模型训练：\\n\");\n\ttrain_model(X_train_seq, Y_train_seq, train_seq_size, dim,hidenode_num, l_rate,beta1,beta2,epsilon, n_epoch);\n\n\t//模型预测\n\tprintf(\"\\n模型预测：\\n\");\n\ttest_model(X_test_seq, Y_test_seq, test_seq_size, dim, hidenode_num);\n\n\t//保存权值\n\tchar output[] = \"weight_output.txt\";\n\t//saveWeight(output, dim, 32);\n\n\t//销毁网络\n\tdestroy_network(dim, hidenode_num);\n\n\t//释放内存\n\tfor (int j = 0; j < train_seq_size; j++)\n\t{\n\t\tfree(X_train_seq[j]);\n\t}\n\tfree(X_train_seq);\n\tfree(Y_train_seq);\n\tfor (int j = 0; j < test_seq_size; j++)\n\t{\n\t\tfree(X_test_seq[j]);\n\t}\n\tfree(X_test_seq);\n\tfree(Y_test_seq);\n\tfor (int j = 0; j < row; j++)\n\t{\n\t\tfree(dataset[j]);\n\t}\n\tfree(dataset);\n}\n```\n\n## 参考\n\n1. [C语言实现LSTM算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/262132576)\n2. [LSTM模型结构的可视化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/139617364)\n3. [Step-by-step to LSTM: 解析LSTM神经网络设计原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/30465140)\n4. [Understanding LSTM Networks -- colah's blog](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)\n4. [LSTM还没「死」！ (qq.com)](https://mp.weixin.qq.com/s/DEHSiPP1IHEnfLdDYxmjOA)\n\n<!--Completed on 2022.04.07 15:51, by GoeJoody LV-->\n\n","tags":["C","LSTM","神经网络"],"categories":["机器学习"]},{"title":"RSA算法","url":"/hexo-blogs/2022/04/03/RSA算法/","content":"\n# RSA算法\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.04.03 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n>\n> {% endtimeline %}\n\n<!--start: 2022.03.12-->\n\n## 什么是RSA\n\n非对称加密算法也叫公钥密码算法，通过生成的公私钥来对明文密文进行加密解密。RSA加密算法就是一种非对称加密算法，1977年由麻省理工学院的三位密码学家和计算机科学家共同发明，这种算法非常可靠，密钥越长，它就越难破解。 RSA的名字是由它的三个开发者Ron Rivest, Adi Shamir和 Leonard Adleman的首字母而来的[<sup>1</sup>](#refer-anchor-1)。\n\nRSA公钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。\n\n## RSA的加密\n\nRSA的加密可以用下面的公式来表示：\n\n> $密文=明文^E mod N$\n\n通过公式我们可以知道RSA的密文是通过明文的E次方再对$N$进行$mod$运算得到的。\n\n如果知道了$E$和$N$，那么就可以得到密文，所以我们把$E$和$N$的组合称为公钥，表示为 公钥{$E$,$N$}。\n\n## RSA的解密\n\nRSA的解密可以用下面的公式来表示：\n\n> $明文 = 密文^D mod N$\n\n通过公式可以看到，明文是通过密文的$D$次方，再和$N$取模得到的。这里的$N$和加密的$N$是同一个数字。\n\n$D$和$N$的组合表示为私钥{$D$,$N$}。\n\n## RSA的工作流程\n\n1. 选择两个比较大的质数$p$和$q$，计算$N = p * q$。[<sup>2</sup>](#refer-anchor-2)\n2. 计算$N$的欧拉函数$\\lambda(N)$，$\\lambda(N)=(p-1)*(q-1)$\n3.  选择一个小于$\\lambda(N)$且与之互质的数$E$（一般$E$可以取65537），并求得$E$关于$\\lambda(N)$的[模逆元](https://zh.wikipedia.org/zh-cn/模反元素)$D = E^{-1}(mod \\lambda(N))$。\n   + 模逆元的定义是，找到$D$使得$（E*D） mod \\lambda(N) = 1$。\n   + 模逆元可以用[扩展的欧几里得算法](https://zh.wikipedia.org/zh-cn/扩展欧几里得算法)得出。\n4. $(N,E)$是公钥，$(N,D)$是私钥\n   + 公钥公开，私钥必须密藏。\n   + 销毁所有 $p$,$q$,$\\lambda(N)$ 的记录。\n5. 发送方先按照双方约定好的编码格式将消息转化为一个小于$N$的正整数$m$，然后使用接收方的公钥计算出密文$c$，计算公式是 $c≡m^E(modN)$。\n6. 接收方收到密文后，使用自己的私钥计算出明文$m$，计算公式是 $m≡c^D(modN)$，然后解码成原始消息。\n7. 使用私钥加密的消息也可以由公钥解密，即如果 $s≡m^D(modN)$，则 $m≡s^E(modN)$。这就是所支持的数字签名功能\n\n## RSA的安全性\n\n1. 历经40多年的广泛研究和现实应用的考验，虽然发现了不少精巧的攻击手段，总体上RSA是安全的。这些攻击手段都是利用RSA的不当使用或软硬件实现中脆弱性，并不能动摇其加密算法的安全性根基。另一方面，对这些攻击手段的研究表明，实现一个安全而牢固的RSA应用并不是一个简单的任务。实际上，密码学和网络安全软硬件工程实践中的一个共识就是：不要试图从头开始实现RSA！恰当的方案，是使用现有的、久经测试并有可靠维护的库或API，去实现RSA算法和协议的应用。\n2. 查询[RSA大数分解挑战](https://en.wikipedia.org/wiki/RSA_Factoring_Challenge)网站公布的最新纪录，2020二月法国计算数学家保罗·齐默尔曼 (Paul Zimmermann) 领导的团队成功分解了250位十进制数字 (**829比特**) 的大数 [RSA-250](https://en.wikipedia.org/wiki/RSA_numbers#RSA-250)[<sup>3</sup>](#refer-anchor-3)。因此目前来说，1024位的RSA密钥基本安全，2048位的RSA密钥极其安全。\n\n## RSA算法实现（C++）\n\n### 安装GMP\n\n> 生成并存储一个1024位128个字节的高精度整数，用C++自带的库很难完成这个工作，就需要第三方库：GMP，这个库支持任意精度的大整数存储与运算。\n\n> 使用MinGW安装GMP，执行命令`mingw-get install mingw32-gmp`。\n\n> 编写程序时，包含`#include<gmpxx.h>`头文件，编译时需要加上`-lgmp -lgmpxx`（由于这个原因，一直没能找到在VScode下运行的正确解决方案），因此在命令行进行编译。\n\n### 代码实现\n\n```cpp\n/*\n * @Author: JoeGoody LV\n * @Date: 2022-04-02\n * @LastEditors: JoeGoody LV\n * @LastEditTime: 2022-04-02\n * @Description: RSA算法实现\n */\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"gmpxx.h\"\n\nusing namespace std;\n\nvoid RSA_get_key(string &e, string &d, string &n) {\n  mpz_t p, q;        //两个大质数\n  mpz_t N, L, E, D;  // L为欧拉函数\n\n  //初始化\n  mpz_init(p);\n  mpz_init(q);\n  mpz_init(N);\n  mpz_init(L);\n  mpz_init(E);\n  mpz_init(D);\n\n  /*\n   * 生成随机1024位质数\n   */\n  gmp_randstate_t grat;  //随机数种子\n  gmp_randinit_default(grat);  //默认生成方式,在随机性与效率之间取一个折中\n  //生成两个1024位的随机整数\n  mpz_urandomb(p, grat, 1024);\n  mpz_urandomb(q, grat, 1024);  //随机生成一个0-2^1024的一个数\n  //生成素数\n  mpz_nextprime(p, p);  // GMP自带的素数生成函数\n  mpz_nextprime(q, q);\n\n  /*\n   * 求得N, L\n   */\n  mpz_mul(N, p, q);     // N = p*q;\n  mpz_sub_ui(p, p, 1);  // p = (p-1)\n  mpz_sub_ui(q, q, 1);  // p = (q-1)\n  mpz_mul(L, p, q);     // L = (p-1)*(q-1)\n\n  /*\n   * 求得E到公钥e此值可取65537、17、37、47;但除65537以外其他小值*\n   * 做公钥得到的密文是固定不变的，安全性不可靠!\n   */\n  mpz_set_ui(E, 65537);  // E = 65537\n  /*\n   * 逆元运算\n   */\n  mpz_invert(D, E, L);  //(D*E)%L = 1\n\n  /*\n   * 将D,E,N转为字符串\n   */\n  mpz_class temp_D(D);  //构造函数mpz_class x(z); #z为mpz_t类型\n  mpz_class temp_E(E);\n  mpz_class temp_N(N);\n  d = temp_D.get_str();\n  e = temp_E.get_str();\n  n = temp_N.get_str();\n\n  /*\n   * 释放变量\n   */\n  mpz_clear(q);\n  mpz_clear(p);\n  mpz_clear(N);\n  mpz_clear(D);\n  mpz_clear(E);\n  mpz_clear(L);\n}\n\nstring RSA_encode(string in_data, string e, string n) {\n  mpz_t m, pub_e, temp_n;\n  mpz_init(m);\n  mpz_init(pub_e);\n  mpz_init(temp_n);\n  //将公钥{N,E}统一转化为十进制高精度整数\n  mpz_set_str(pub_e, e.c_str(), 10);\n  mpz_set_str(temp_n, n.c_str(), 10);\n\n  int length = in_data.size();\n  /*\n   * 对字符串循环加密\n   */\n  string out_data;\n  for (int i = 0; i < length; i++) {\n    mpz_set_ui(m, (unsigned long)in_data[i]);\n    mpz_powm(m, m, pub_e, temp_n);  // c = (m^e) mod n\n\n    mpz_class c_data(m);\n    out_data.append(c_data.get_str());  //取得字符串\n    out_data.append(\"\\n\");  //用回车隔开防止字符串密文混乱无法辨识\n  }\n\n  mpz_clear(m);\n  mpz_clear(pub_e);\n  mpz_clear(temp_n);\n\n  return out_data;\n}\n\nstring RSA_decode(string in_data, string d, string n) {\n  vector<string> C_List;\n  string temp_str;\n  int length = in_data.size();\n  //循环拆分字符串，根据原有字符个数拆分为字符串容器列表\n  for (int i = 0; i < length; i++) {\n    if (in_data.at(i) == '\\n') {\n      C_List.push_back(temp_str);\n      temp_str.clear();\n      continue;\n    }\n    temp_str += in_data.at(i);\n  }\n\n  mpz_t pri_key, temp_n, temp_Data;\n  mpz_init(pri_key);\n  mpz_init(temp_n);\n  mpz_init(temp_Data);\n  //将字符串转为mpz_t高精度整数\n  mpz_set_str(pri_key, d.c_str(), 10);\n  mpz_set_str(temp_n, n.c_str(), 10);\n\n  //循环根据容器个数来判断原本有几个字符，并将其密文解析为明文\n  string back_data;\n  for (int i = 0; i < C_List.size(); i++) {\n    //从字符串取值转化为十进制大整数\n    mpz_set_str(temp_Data, C_List.at(i).c_str(), 10);\n    //模幂运算M=(C^d) mod n\n    mpz_powm(temp_Data, temp_Data, pri_key, temp_n);\n\n    //先将取到的明文ASCII转化为C语言基本类型\n    //再直接将ASCII码转为字符，再将字符追加进字符串\n    //这样就完美还原了明文\n    mpz_class CD(temp_Data);\n    unsigned long lchar = CD.get_ui();\n    char words = (char)lchar;\n    back_data += words;\n  }\n\n  mpz_clear(pri_key);\n  mpz_clear(temp_n);\n  mpz_clear(temp_Data);\n  //返回明文\n  return back_data;\n}\n\nint main() {\n  string e, d, n;\n  string plaintext = \"我是一串明文\";\n  RSA_get_key(e, d, n);\n  string ciphertext = RSA_encode(plaintext, e, n);\n  string plaintext_1 = RSA_decode(ciphertext, d, n);\n\n  ofstream os;\n  string filename = \"output.txt\";\n  os.open(filename);\n\n  os << \"E:\\n\" << e << endl;\n  os << \"D:\\n\" << d << endl;\n  os << \"N:\\n\" << n << endl;\n  os << \"原始明文: \\n\" << plaintext << endl;\n  os << \"加密密文: \\n\" << ciphertext << endl;\n  os << \"解密明文: \\n\" << plaintext_1 << endl;\n  os.close();\n\n  return 0;\n}\n```\n\n### 编译运行\n\n在项目目录下，命令行执行：\n\n```shell\ng++ RSA_algorithm.cpp -lgmp -lgmpxx -o test\n\ntest.exe\n```\n\n### 运行结果\n\n![image-20220403000519735](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202204030005162.png)\n\n## 参考\n\n<div id=\"refer-anchor-1\"></div>\n+ [1] Rivest R.L. ,  Shamir A. ,   Adelman L. . A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Comm.ACM, 1977.\n<div id=\"refer-anchor-2\"></div>\n+ [2] 子曦. RSA的攻与防（一）[EB]/[OL].https://www.packetmania.net/2020/12/01/RSA-attack-defense/. 2021-11-27.\n<div id=\"refer-anchor-3\"></div>\n+ [3] 维基百科“RSA Factoring Challenge”[EB]/[OL].https://en.wikipedia.org/wiki/RSA_Factoring_Challenge. 2022-04-02.\n+ [4] [GMP大法教你重新做人(从入门到实战) - Angel_Kitty](https://www.cnblogs.com/ECJTUACM-873284962/p/8350320.html)\n+ [5] [ RSA加密算法解释与C++实现_Anansi_safe](https://blog.csdn.net/weixin_43815930/article/details/105887662)\n\n\n\n","tags":["C-plus-plus","RSA","GMP"],"categories":["课程作业"]},{"title":"正则表达式","url":"/hexo-blogs/2022/03/26/正则表达式/","content":"# 正则表达式\n\n> {% timeline 更新时间线, pink %}\n> <!-- timeline 2022.03.27 -->\n>\n> 第一次提交\n> <!-- endtimeline -->\n> {% endtimeline %}\n\n## 结构组成\n\n+ 普通字符：大小写字母，数字。只作为字符，不具备其他含义。\n+ 元字符：除了本身作为字符，还可以表达其他含义。对于元字符来说，要表示其原本的普通字符含义，可使用转义字符`\\`。\n\n## 用途场景\n\n1. 字符串规则验证。\n2. 字符串替换。\n3. 字符（串）提取。\n\n## 正则元字符\n\n### 正则：普通字符\n\n> 正则表达式为一串普通字符（不包含元字符）时，校验字符串只有和正则串一致时，才会校验通过。\n\n```markdown\n//regex: a1b2c3\na1b2c: false\na1b2c3: true\na1b2c3d: false\n```\n\n### 正则：\\d\n\n> **\\d**表示一个数字。\n\n```markdown\n//regex: aaa\\d  //表示三个“a”再加一个数字组成的字符串。\naaaa1: false\naaa1: true\naaa5: true\naaa8: true\naaa: false\n```\n\n### 正则：\\D\n\n> **\\D** 表示一个非数字，它和 \\d 的意思恰好相反。\n\n```markdown\n//regex: \\D\\D\\D   //表示一个长度为3且不包含数字的字符串\naaa: true\naaaa: false\nas1: false\na+c: true\n```\n\n### 正则：\\w\n\n> **\\w**表示一个字母（大小写均可）、数字，或下划线。\n\n```markdown\n// regex: \\d\\w\\D\n111: false\n12d: true\n1dd: true\nddd: false\n1_d: true\n```\n\n### 正则：\\W\n\n> **\\W**与\\w相反，表示这个位置的字符既不是字母、数字，也不是下划线。也就是：特殊符号（除下划线），或者空格等满足。\n\n```markdown\n// regex: \\d\\W\\D\n11d: false\n1wd: false\n1_d: false\n1+d: true\n```\n\n### 正则：\\s\n\n> **\\s**表示匹配一个看不见的符号（空白符），即空格、制表符（Tab键）、换行符。\n\n```markdown\n// regex: \\d\\s\\w\n1f5: false\n1+f: false\n1 d: true\n1\tf: true\n```\n\n### 正则：\\S\n\n>  **\\S** 与 \\s 相反，表示一个可以看得见的符号（非空白符）。\n>\n>  + `\\s\\S`：匹配所有。\n\n```markdown\nregex: \\d\\S\\w\n1f5: true\n1+f: true\n1 d: false\n1\tf: false\n```\n\n### 正则：.\n\n> **.** (小数点) 则表示“\\n”和\"\\r\"之外的任何单个字符，等价于`[^\\n\\r]` 。如果要表示点号，最好用`[.]`或者`\\.`\n\n```markdown\n// regex: ....    //表示任意四个字符\nafdv: true\nsf15: true\nd^%#: true\n5c:<: true\n```\n\n### 正则：|\n\n> **|**（竖线）表示“或”的关系，表示检测的字符串需满足其中一个时，才满足条件。\n\n```markdown\n// regex: aa|bb|cc\naa: true\nbb: true\ncc: true\ndd: false\n```\n\n### 正则：[abc]\n\n> **[]**表示匹配其中任意一个字符。\n\n```markdown\n// regex: \\D[bcd]\\W\nfb+: true\nfc+: true\nfd+: true\nfd+: false\n```\n\n### 正则：**[^abc]**\n\n> **[^]**表示不与括号里的任意字符匹配。\n\n```markdown\n// regex: \\D[^bcd]\\W\nfb+: false\nfc+: false\nfd+: false\nfd+: true\n```\n\n### 正则：[a-z]\n\n> **[值1-值2]**表示值1到值2中间的所有字符都满足（包括值1和值2）。常见范围为大小写字母范围和数字范围：[a-z]，[A-Z]，[0-9]。\n\n```markdown\n// regex: a[b-e]g   //即a[bcde]g、a(b|c|d|e)g\nabg: true\naeg: true\nadg: true\navg: false\n// regex: a[0-9]e  //等价于a\\de\n```\n\n### 正则：**[^a-z]**\n\n> **[^值1-值2]**表示除值1和值2之外的所有字符，都可以满足。\n\n```markdown\n// regex: a[^a-z]e\naae: false\nage: false\naze: false\na1e: true\n```\n\n### 正则：\\num\n\n> 这里的num指number，也就是数字，当\\后面跟数字，表示匹配第几个括号中的结果。\n>\n> 例如：\n>\n> + `ab(c)d(e)\\1`：`\\1`表示匹配第一个括号里的结果，即`\\1`指`c`。等价于`abcdec`。\n> + `ab(c)d(e)\\2`：等价于`abcdee`。\n> + `12(\\w)d\\1`：等价于`12\\wd\\w`。\n\n### 正则：(?:pattern)\n\n> 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n\n### 正则：限定符\n\n#### 正则：?\n\n> **`?`** 表示匹配前面的子表达式**零次或一次**。\n>\n> 例如：`abc?de`: 表示可匹配的字符串为 `abde` (匹配0次`c`) 或 `abcde` (匹配1次`c`)。\n\n> 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。\n\n```markdown\n// regex: abc?de\nabde: true\nabcde: true\nabccde: false\n```\n\n#### 正则：+\n\n> **`+`**表示匹配前面的表达式**一次或多次**。（至少一次）\n\n```markdown\n// regex: abc+de\nabde: false\nabcde: true\nabccde: true\nabcccde: true\n```\n\n#### 正则：*\n\n> **`*`**表示匹配前面的子表达式任意次(可以为0次)。\n\n```markdown\n// regex: abc*de   //表示ab和de之间有任意个c\nabde: true\nabccde: true\nabcccde: true\nabccccde: true\n```\n\n#### 正则：{n}\n\n> 这里的 `n` 是一个非负整数。匹配确定的前面的子表达式 `n` 次。\n\n```markdown\n// regex: abc{3}de   //表示 ab 和 de 之间有3个 c ，等价于 abcccde。\n\n// regex: aa(xx|yy){3}de  //表示 ab 和 de 之间有 xx 或 yy 的个数， 一起合计为3个。\naaxxxxxxde: true\naaxxyyxxde: true\naaxyxyxyde: false\naaxxyyyyyyde: false\n```\n\n#### 正则：{n,}\n\n> `{n,}`表示匹配 n 次及以上。\n>\n> + `{1,}`：等价于`+`。\n> + `{0,}`：等价于`*`。\n\n#### 正则：{n,m}\n\n> $m$ 和 $n$ 均为非负整数，其中 $n<=m$。最少匹配 $n$ 次且最多匹配 $m$ 次。\n>\n> + `{0,1}`：等价于`?`。\n\n```markdown\n// regex: abc{2,4}de   //表示ab和de之间有2-4个c\nabcde: false\nabccde: true\nabcccde: true\nabccccde: true\n```\n\n### 正则：定位符\n\n| 字符 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| `^`  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |\n| `$`  | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |\n| `\\b` | 匹配一个单词边界，即单词与空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| `\\B` | 非单词边界匹配。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n\n<font color=#ff0000>注：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\\*** 之类的表达式。</font>\n\n### 先行断言(lookahead)和后行断言(lookbehind)\n\n> + 如同 **^** 代表开头，**$** 代表结尾，**\\b** 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为**\"零宽\"**。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。\n> + 对于后行断言，在不同语言中的支持有所限制。\n> + **所谓的先行/后行，正向/负向，断言。事实上这些翻译都不准确。不过能理解具体意思就好**。\n> + **可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存**。这里的<font color=#ff0000>**重写捕获**</font>，需要作详细理解。\n>\n> ![image-20220327223107787](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272231884.png)\n\n>参考：[正则表达式的先行断言(lookahead)和后行断言(lookbehind) | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html)\n\n\n\n#### `(?=pattern)`零宽正向先行断言(zero-width positive lookahead assertion)\n\n> `exp1(?=exp2)`：查找exp2前面的exp1。\n\n![image-20220327214439476](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272144588.png)\n\n#### `(?<=pattern)`零宽正向后行断言(zero-width positive lookbehind assertion)\n\n> `(?<=exp2)exp1`：查找exp2后面的exp1。\n\n![image-20220327214656998](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272146086.png)\n\n#### `(?!pattern)`零宽负向先行断言(zero-width negative lookahead assertion)\n\n> `exp1(?!exp2)`：查找后面不是exp2的exp1。\n\n![image-20220327214847158](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272148270.png)\n\n#### `(?<!pattern)`零宽负向后行断言(zero-width negative lookbehindassertion)\n\n> `(?<!exp2)exp1`：查找前面不是exp2的exp1。\n\n![image-20220327215006162](https://picture-cloud-storage-bed.oss-cn-chengdu.aliyuncs.com/images/202203272150258.png)\n\n## Tips\n\n### 3个重要的正则式命令\n\nBracket（括号）, Caret（插入符号）和Dollars（美元符号）。\n\n+ **B**在正则表达式中有3种类型的括号。\n  + 方括号`[]`内是需要匹配的字符。\n  + 花括号`{}`内是指定匹配字符的数量。\n  + 圆括号`()` 则是用来分组的。\n\n+ **C** 插入符号 `^` 表示正则式的开始。用在`[]`中，`[^]`表示非。\n\n+ **D** 美元符号`$` 表示正则式的结束。\n\n### 快捷命令\n\n| 实际命令       | 快捷命令 |\n| :------------- | -------- |\n| `[0-9]`        | `\\d`     |\n| `[^0-9]`       | `\\D`     |\n| `[a-zA-Z0-9_]` | `\\w`     |\n\n### 其他\n\n1. ***** 和 **+** 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个**?** 就可以实现非贪婪或最小匹配。\n\n```markdown\n// 字符串： <h1>JoeGoodyLv</h1>\n// regex: <.*>    直接匹配到 <h1>JoeGoodyLv</h1>\n// regex: <.*?>   匹配到 <h1>、</h1>\n```\n\n## 常用正则表达式\n\n+ 国内手机号码\n\n  ```md\n  ^(13[0-9]|14[0-9]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$\n  ```\n\n## Reference\n\n1. [正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)\n\n","tags":["正则表达式"],"categories":["学习笔记"]}]